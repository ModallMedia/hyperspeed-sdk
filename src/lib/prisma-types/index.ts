
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Collection
 * 
 */
export type Collection = $Result.DefaultSelection<Prisma.$CollectionPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model CompletionUsage
 * 
 */
export type CompletionUsage = $Result.DefaultSelection<Prisma.$CompletionUsagePayload>
/**
 * Model Content
 * 
 */
export type Content = $Result.DefaultSelection<Prisma.$ContentPayload>
/**
 * Model ContentTemplateInstance
 * 
 */
export type ContentTemplateInstance = $Result.DefaultSelection<Prisma.$ContentTemplateInstancePayload>
/**
 * Model Field
 * 
 */
export type Field = $Result.DefaultSelection<Prisma.$FieldPayload>
/**
 * Model ImageGenerationBilling
 * 
 */
export type ImageGenerationBilling = $Result.DefaultSelection<Prisma.$ImageGenerationBillingPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model LinkPage
 * 
 */
export type LinkPage = $Result.DefaultSelection<Prisma.$LinkPagePayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model Messages
 * 
 */
export type Messages = $Result.DefaultSelection<Prisma.$MessagesPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model Page
 * 
 */
export type Page = $Result.DefaultSelection<Prisma.$PagePayload>
/**
 * Model Run
 * 
 */
export type Run = $Result.DefaultSelection<Prisma.$RunPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Template
 * 
 */
export type Template = $Result.DefaultSelection<Prisma.$TemplatePayload>
/**
 * Model TemplateInstance
 * 
 */
export type TemplateInstance = $Result.DefaultSelection<Prisma.$TemplateInstancePayload>
/**
 * Model Thread
 * 
 */
export type Thread = $Result.DefaultSelection<Prisma.$ThreadPayload>
/**
 * Model ThreadMessage
 * 
 */
export type ThreadMessage = $Result.DefaultSelection<Prisma.$ThreadMessagePayload>
/**
 * Model Usage
 * 
 */
export type Usage = $Result.DefaultSelection<Prisma.$UsagePayload>
/**
 * Model UserOrganization
 * 
 */
export type UserOrganization = $Result.DefaultSelection<Prisma.$UserOrganizationPayload>
/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model author
 * 
 */
export type author = $Result.DefaultSelection<Prisma.$authorPayload>
/**
 * Model form_field
 * 
 */
export type form_field = $Result.DefaultSelection<Prisma.$form_fieldPayload>
/**
 * Model org_details
 * 
 */
export type org_details = $Result.DefaultSelection<Prisma.$org_detailsPayload>
/**
 * Model struct
 * 
 */
export type struct = $Result.DefaultSelection<Prisma.$structPayload>
/**
 * Model struct_set
 * 
 */
export type struct_set = $Result.DefaultSelection<Prisma.$struct_setPayload>
/**
 * Model struct_set_instance
 * 
 */
export type struct_set_instance = $Result.DefaultSelection<Prisma.$struct_set_instancePayload>

/**
 * Enums
 */
export namespace $Enums {
  export declare const field_type: {
  text: 'text',
  integer: 'integer',
  date: 'date',
  email: 'email',
  tel: 'tel',
  url: 'url',
  float: 'float',
  long_text: 'long_text',
  media: 'media',
  dropdown: 'dropdown',
  checkbox: 'checkbox',
  boolean: 'boolean',
  media_gallery: 'media_gallery',
  json: 'json',
  custom_json: 'custom_json',
  icon: 'icon',
  tag: 'tag',
  rich_text: 'rich_text',
  struct_array: 'struct_array'
};

export type field_type = (typeof field_type)[keyof typeof field_type]

}

export type field_type = $Enums.field_type


/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Categories
 * const categories = await prisma.category.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types:any }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Categories
   * const categories = await prisma.category.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.3.0
   * Query Engine version: acc0b9dd43eb689cbd20c9470515d719db10d0b0
   */
  export type PrismaVersion = {
    client: string
  }
  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      
    }
  }
  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  export type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>




  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    category?: CategoryOmit
    collection?: CollectionOmit
    comment?: CommentOmit
    completionUsage?: CompletionUsageOmit
    content?: ContentOmit
    contentTemplateInstance?: ContentTemplateInstanceOmit
    field?: FieldOmit
    imageGenerationBilling?: ImageGenerationBillingOmit
    invoice?: InvoiceOmit
    linkPage?: LinkPageOmit
    media?: MediaOmit
    messages?: MessagesOmit
    organization?: OrganizationOmit
    page?: PageOmit
    run?: RunOmit
    subscription?: SubscriptionOmit
    template?: TemplateOmit
    templateInstance?: TemplateInstanceOmit
    thread?: ThreadOmit
    threadMessage?: ThreadMessageOmit
    usage?: UsageOmit
    userOrganization?: UserOrganizationOmit
    users?: UsersOmit
    author?: authorOmit
    form_field?: form_fieldOmit
    org_details?: org_detailsOmit
    struct?: structOmit
    struct_set?: struct_setOmit
    struct_set_instance?: struct_set_instanceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    other_Category: number
    Content: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_Category?: boolean | CategoryCountOutputTypeCountOther_CategoryArgs
    Content?: boolean | CategoryCountOutputTypeCountContentArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountOther_CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentWhereInput
  }


  /**
   * Count Type CollectionCountOutputType
   */

  export type CollectionCountOutputType = {
    Category: number
    Content: number
    Field: number
    Template: number
    form_field: number
  }

  export type CollectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Category?: boolean | CollectionCountOutputTypeCountCategoryArgs
    Content?: boolean | CollectionCountOutputTypeCountContentArgs
    Field?: boolean | CollectionCountOutputTypeCountFieldArgs
    Template?: boolean | CollectionCountOutputTypeCountTemplateArgs
    form_field?: boolean | CollectionCountOutputTypeCountForm_fieldArgs
  }

  // Custom InputTypes
  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCountOutputType
     */
    select?: CollectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentWhereInput
  }

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountFieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldWhereInput
  }

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateWhereInput
  }

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountForm_fieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: form_fieldWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    other_Comment: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_Comment?: boolean | CommentCountOutputTypeCountOther_CommentArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountOther_CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type ContentCountOutputType
   */

  export type ContentCountOutputType = {
    Comment: number
    ContentTemplateInstance: number
    Category: number
  }

  export type ContentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comment?: boolean | ContentCountOutputTypeCountCommentArgs
    ContentTemplateInstance?: boolean | ContentCountOutputTypeCountContentTemplateInstanceArgs
    Category?: boolean | ContentCountOutputTypeCountCategoryArgs
  }

  // Custom InputTypes
  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCountOutputType
     */
    select?: ContentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeCountContentTemplateInstanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentTemplateInstanceWhereInput
  }

  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeCountCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }


  /**
   * Count Type MediaCountOutputType
   */

  export type MediaCountOutputType = {
    LinkPage: number
    Users: number
    author: number
    struct: number
  }

  export type MediaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LinkPage?: boolean | MediaCountOutputTypeCountLinkPageArgs
    Users?: boolean | MediaCountOutputTypeCountUsersArgs
    author?: boolean | MediaCountOutputTypeCountAuthorArgs
    struct?: boolean | MediaCountOutputTypeCountStructArgs
  }

  // Custom InputTypes
  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCountOutputType
     */
    select?: MediaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountLinkPageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkPageWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountAuthorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: authorWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountStructArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: structWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    Category: number
    Collection: number
    Comment: number
    CompletionUsage: number
    Content: number
    ImageGenerationBilling: number
    Invoice: number
    LinkPage: number
    Media: number
    Messages: number
    Page: number
    Subscription: number
    Thread: number
    Usage: number
    UserOrganization: number
    Users: number
    author: number
    form_field: number
    struct: number
    struct_set: number
    struct_set_instance: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Category?: boolean | OrganizationCountOutputTypeCountCategoryArgs
    Collection?: boolean | OrganizationCountOutputTypeCountCollectionArgs
    Comment?: boolean | OrganizationCountOutputTypeCountCommentArgs
    CompletionUsage?: boolean | OrganizationCountOutputTypeCountCompletionUsageArgs
    Content?: boolean | OrganizationCountOutputTypeCountContentArgs
    ImageGenerationBilling?: boolean | OrganizationCountOutputTypeCountImageGenerationBillingArgs
    Invoice?: boolean | OrganizationCountOutputTypeCountInvoiceArgs
    LinkPage?: boolean | OrganizationCountOutputTypeCountLinkPageArgs
    Media?: boolean | OrganizationCountOutputTypeCountMediaArgs
    Messages?: boolean | OrganizationCountOutputTypeCountMessagesArgs
    Page?: boolean | OrganizationCountOutputTypeCountPageArgs
    Subscription?: boolean | OrganizationCountOutputTypeCountSubscriptionArgs
    Thread?: boolean | OrganizationCountOutputTypeCountThreadArgs
    Usage?: boolean | OrganizationCountOutputTypeCountUsageArgs
    UserOrganization?: boolean | OrganizationCountOutputTypeCountUserOrganizationArgs
    Users?: boolean | OrganizationCountOutputTypeCountUsersArgs
    author?: boolean | OrganizationCountOutputTypeCountAuthorArgs
    form_field?: boolean | OrganizationCountOutputTypeCountForm_fieldArgs
    struct?: boolean | OrganizationCountOutputTypeCountStructArgs
    struct_set?: boolean | OrganizationCountOutputTypeCountStruct_setArgs
    struct_set_instance?: boolean | OrganizationCountOutputTypeCountStruct_set_instanceArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountCollectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountCompletionUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompletionUsageWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountImageGenerationBillingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageGenerationBillingWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountLinkPageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkPageWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessagesWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountPageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountThreadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThreadWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUserOrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOrganizationWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountAuthorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: authorWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountForm_fieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: form_fieldWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountStructArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: structWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountStruct_setArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: struct_setWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountStruct_set_instanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: struct_set_instanceWhereInput
  }


  /**
   * Count Type RunCountOutputType
   */

  export type RunCountOutputType = {
    ThreadMessage: number
  }

  export type RunCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ThreadMessage?: boolean | RunCountOutputTypeCountThreadMessageArgs
  }

  // Custom InputTypes
  /**
   * RunCountOutputType without action
   */
  export type RunCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RunCountOutputType
     */
    select?: RunCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RunCountOutputType without action
   */
  export type RunCountOutputTypeCountThreadMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThreadMessageWhereInput
  }


  /**
   * Count Type TemplateCountOutputType
   */

  export type TemplateCountOutputType = {
    Field: number
    TemplateInstance: number
  }

  export type TemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Field?: boolean | TemplateCountOutputTypeCountFieldArgs
    TemplateInstance?: boolean | TemplateCountOutputTypeCountTemplateInstanceArgs
  }

  // Custom InputTypes
  /**
   * TemplateCountOutputType without action
   */
  export type TemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateCountOutputType
     */
    select?: TemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TemplateCountOutputType without action
   */
  export type TemplateCountOutputTypeCountFieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldWhereInput
  }

  /**
   * TemplateCountOutputType without action
   */
  export type TemplateCountOutputTypeCountTemplateInstanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateInstanceWhereInput
  }


  /**
   * Count Type TemplateInstanceCountOutputType
   */

  export type TemplateInstanceCountOutputType = {
    ContentTemplateInstance: number
  }

  export type TemplateInstanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ContentTemplateInstance?: boolean | TemplateInstanceCountOutputTypeCountContentTemplateInstanceArgs
  }

  // Custom InputTypes
  /**
   * TemplateInstanceCountOutputType without action
   */
  export type TemplateInstanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateInstanceCountOutputType
     */
    select?: TemplateInstanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TemplateInstanceCountOutputType without action
   */
  export type TemplateInstanceCountOutputTypeCountContentTemplateInstanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentTemplateInstanceWhereInput
  }


  /**
   * Count Type ThreadCountOutputType
   */

  export type ThreadCountOutputType = {
    Run: number
    ThreadMessage: number
  }

  export type ThreadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Run?: boolean | ThreadCountOutputTypeCountRunArgs
    ThreadMessage?: boolean | ThreadCountOutputTypeCountThreadMessageArgs
  }

  // Custom InputTypes
  /**
   * ThreadCountOutputType without action
   */
  export type ThreadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadCountOutputType
     */
    select?: ThreadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ThreadCountOutputType without action
   */
  export type ThreadCountOutputTypeCountRunArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunWhereInput
  }

  /**
   * ThreadCountOutputType without action
   */
  export type ThreadCountOutputTypeCountThreadMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThreadMessageWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    UserOrganization: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserOrganization?: boolean | UsersCountOutputTypeCountUserOrganizationArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUserOrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOrganizationWhereInput
  }


  /**
   * Count Type AuthorCountOutputType
   */

  export type AuthorCountOutputType = {
    Content: number
  }

  export type AuthorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Content?: boolean | AuthorCountOutputTypeCountContentArgs
  }

  // Custom InputTypes
  /**
   * AuthorCountOutputType without action
   */
  export type AuthorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorCountOutputType
     */
    select?: AuthorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuthorCountOutputType without action
   */
  export type AuthorCountOutputTypeCountContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentWhereInput
  }


  /**
   * Count Type StructCountOutputType
   */

  export type StructCountOutputType = {
    form_field: number
    struct_set_instance: number
  }

  export type StructCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form_field?: boolean | StructCountOutputTypeCountForm_fieldArgs
    struct_set_instance?: boolean | StructCountOutputTypeCountStruct_set_instanceArgs
  }

  // Custom InputTypes
  /**
   * StructCountOutputType without action
   */
  export type StructCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StructCountOutputType
     */
    select?: StructCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StructCountOutputType without action
   */
  export type StructCountOutputTypeCountForm_fieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: form_fieldWhereInput
  }

  /**
   * StructCountOutputType without action
   */
  export type StructCountOutputTypeCountStruct_set_instanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: struct_set_instanceWhereInput
  }


  /**
   * Count Type Struct_setCountOutputType
   */

  export type Struct_setCountOutputType = {
    struct_set_instance: number
  }

  export type Struct_setCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    struct_set_instance?: boolean | Struct_setCountOutputTypeCountStruct_set_instanceArgs
  }

  // Custom InputTypes
  /**
   * Struct_setCountOutputType without action
   */
  export type Struct_setCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Struct_setCountOutputType
     */
    select?: Struct_setCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Struct_setCountOutputType without action
   */
  export type Struct_setCountOutputTypeCountStruct_set_instanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: struct_set_instanceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
    parent_id: number | null
    collection_id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
    organization_id: number | null
    parent_id: number | null
    collection_id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    organization_id: number | null
    slug: string | null
    description: string | null
    parent_id: number | null
    collection_id: number | null
    created_at: Date | null
    updated_at: Date | null
    short_name: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    organization_id: number | null
    slug: string | null
    description: string | null
    parent_id: number | null
    collection_id: number | null
    created_at: Date | null
    updated_at: Date | null
    short_name: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    organization_id: number
    slug: number
    description: number
    parent_id: number
    collection_id: number
    created_at: number
    updated_at: number
    short_name: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
    organization_id?: true
    parent_id?: true
    collection_id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
    organization_id?: true
    parent_id?: true
    collection_id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    organization_id?: true
    slug?: true
    description?: true
    parent_id?: true
    collection_id?: true
    created_at?: true
    updated_at?: true
    short_name?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    organization_id?: true
    slug?: true
    description?: true
    parent_id?: true
    collection_id?: true
    created_at?: true
    updated_at?: true
    short_name?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    organization_id?: true
    slug?: true
    description?: true
    parent_id?: true
    collection_id?: true
    created_at?: true
    updated_at?: true
    short_name?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    name: string
    organization_id: number
    slug: string
    description: string | null
    parent_id: number | null
    collection_id: number
    created_at: Date
    updated_at: Date
    short_name: string
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organization_id?: boolean
    slug?: boolean
    description?: boolean
    parent_id?: boolean
    collection_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    short_name?: boolean
    Collection?: boolean | CollectionDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Category?: boolean | Category$CategoryArgs<ExtArgs>
    other_Category?: boolean | Category$other_CategoryArgs<ExtArgs>
    Content?: boolean | Category$ContentArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organization_id?: boolean
    slug?: boolean
    description?: boolean
    parent_id?: boolean
    collection_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    short_name?: boolean
    Collection?: boolean | CollectionDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Category?: boolean | Category$CategoryArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organization_id?: boolean
    slug?: boolean
    description?: boolean
    parent_id?: boolean
    collection_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    short_name?: boolean
    Collection?: boolean | CollectionDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Category?: boolean | Category$CategoryArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    organization_id?: boolean
    slug?: boolean
    description?: boolean
    parent_id?: boolean
    collection_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    short_name?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "organization_id" | "slug" | "description" | "parent_id" | "collection_id" | "created_at" | "updated_at" | "short_name", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Collection?: boolean | CollectionDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Category?: boolean | Category$CategoryArgs<ExtArgs>
    other_Category?: boolean | Category$other_CategoryArgs<ExtArgs>
    Content?: boolean | Category$ContentArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Collection?: boolean | CollectionDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Category?: boolean | Category$CategoryArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Collection?: boolean | CollectionDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Category?: boolean | Category$CategoryArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      Collection: Prisma.$CollectionPayload<ExtArgs>
      Organization: Prisma.$OrganizationPayload<ExtArgs>
      Category: Prisma.$CategoryPayload<ExtArgs> | null
      other_Category: Prisma.$CategoryPayload<ExtArgs>[]
      Content: Prisma.$ContentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      organization_id: number
      slug: string
      description: string | null
      parent_id: number | null
      collection_id: number
      created_at: Date
      updated_at: Date
      short_name: string
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

export type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Collection<T extends CollectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionDefaultArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Category<T extends Category$CategoryArgs<ExtArgs> = {}>(args?: Subset<T, Category$CategoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    other_Category<T extends Category$other_CategoryArgs<ExtArgs> = {}>(args?: Subset<T, Category$other_CategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Content<T extends Category$ContentArgs<ExtArgs> = {}>(args?: Subset<T, Category$ContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly name: FieldRef<"Category", 'String'>
    readonly organization_id: FieldRef<"Category", 'Int'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly parent_id: FieldRef<"Category", 'Int'>
    readonly collection_id: FieldRef<"Category", 'Int'>
    readonly created_at: FieldRef<"Category", 'DateTime'>
    readonly updated_at: FieldRef<"Category", 'DateTime'>
    readonly short_name: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.Category
   */
  export type Category$CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Category.other_Category
   */
  export type Category$other_CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category.Content
   */
  export type Category$ContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    where?: ContentWhereInput
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    cursor?: ContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Collection
   */

  export type AggregateCollection = {
    _count: CollectionCountAggregateOutputType | null
    _avg: CollectionAvgAggregateOutputType | null
    _sum: CollectionSumAggregateOutputType | null
    _min: CollectionMinAggregateOutputType | null
    _max: CollectionMaxAggregateOutputType | null
  }

  export type CollectionAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
  }

  export type CollectionSumAggregateOutputType = {
    id: number | null
    organization_id: number | null
  }

  export type CollectionMinAggregateOutputType = {
    id: number | null
    name: string | null
    organization_id: number | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
    icon: string | null
    page_content: boolean | null
    enable_author: boolean | null
    enable_comments: boolean | null
    enable_featured_posts: boolean | null
    enable_rating: boolean | null
    path_prefix: string | null
    title: string | null
  }

  export type CollectionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    organization_id: number | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
    icon: string | null
    page_content: boolean | null
    enable_author: boolean | null
    enable_comments: boolean | null
    enable_featured_posts: boolean | null
    enable_rating: boolean | null
    path_prefix: string | null
    title: string | null
  }

  export type CollectionCountAggregateOutputType = {
    id: number
    name: number
    organization_id: number
    description: number
    created_at: number
    updated_at: number
    icon: number
    page_content: number
    enable_author: number
    enable_comments: number
    enable_featured_posts: number
    enable_rating: number
    path_prefix: number
    title: number
    _all: number
  }


  export type CollectionAvgAggregateInputType = {
    id?: true
    organization_id?: true
  }

  export type CollectionSumAggregateInputType = {
    id?: true
    organization_id?: true
  }

  export type CollectionMinAggregateInputType = {
    id?: true
    name?: true
    organization_id?: true
    description?: true
    created_at?: true
    updated_at?: true
    icon?: true
    page_content?: true
    enable_author?: true
    enable_comments?: true
    enable_featured_posts?: true
    enable_rating?: true
    path_prefix?: true
    title?: true
  }

  export type CollectionMaxAggregateInputType = {
    id?: true
    name?: true
    organization_id?: true
    description?: true
    created_at?: true
    updated_at?: true
    icon?: true
    page_content?: true
    enable_author?: true
    enable_comments?: true
    enable_featured_posts?: true
    enable_rating?: true
    path_prefix?: true
    title?: true
  }

  export type CollectionCountAggregateInputType = {
    id?: true
    name?: true
    organization_id?: true
    description?: true
    created_at?: true
    updated_at?: true
    icon?: true
    page_content?: true
    enable_author?: true
    enable_comments?: true
    enable_featured_posts?: true
    enable_rating?: true
    path_prefix?: true
    title?: true
    _all?: true
  }

  export type CollectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Collection to aggregate.
     */
    where?: CollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Collections
    **/
    _count?: true | CollectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CollectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CollectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionMaxAggregateInputType
  }

  export type GetCollectionAggregateType<T extends CollectionAggregateArgs> = {
        [P in keyof T & keyof AggregateCollection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollection[P]>
      : GetScalarType<T[P], AggregateCollection[P]>
  }




  export type CollectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionWhereInput
    orderBy?: CollectionOrderByWithAggregationInput | CollectionOrderByWithAggregationInput[]
    by: CollectionScalarFieldEnum[] | CollectionScalarFieldEnum
    having?: CollectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionCountAggregateInputType | true
    _avg?: CollectionAvgAggregateInputType
    _sum?: CollectionSumAggregateInputType
    _min?: CollectionMinAggregateInputType
    _max?: CollectionMaxAggregateInputType
  }

  export type CollectionGroupByOutputType = {
    id: number
    name: string
    organization_id: number
    description: string | null
    created_at: Date
    updated_at: Date
    icon: string
    page_content: boolean
    enable_author: boolean
    enable_comments: boolean
    enable_featured_posts: boolean
    enable_rating: boolean
    path_prefix: string | null
    title: string | null
    _count: CollectionCountAggregateOutputType | null
    _avg: CollectionAvgAggregateOutputType | null
    _sum: CollectionSumAggregateOutputType | null
    _min: CollectionMinAggregateOutputType | null
    _max: CollectionMaxAggregateOutputType | null
  }

  type GetCollectionGroupByPayload<T extends CollectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionGroupByOutputType[P]>
        }
      >
    >


  export type CollectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organization_id?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    icon?: boolean
    page_content?: boolean
    enable_author?: boolean
    enable_comments?: boolean
    enable_featured_posts?: boolean
    enable_rating?: boolean
    path_prefix?: boolean
    title?: boolean
    Category?: boolean | Collection$CategoryArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Content?: boolean | Collection$ContentArgs<ExtArgs>
    Field?: boolean | Collection$FieldArgs<ExtArgs>
    Template?: boolean | Collection$TemplateArgs<ExtArgs>
    form_field?: boolean | Collection$form_fieldArgs<ExtArgs>
    _count?: boolean | CollectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection"]>

  export type CollectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organization_id?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    icon?: boolean
    page_content?: boolean
    enable_author?: boolean
    enable_comments?: boolean
    enable_featured_posts?: boolean
    enable_rating?: boolean
    path_prefix?: boolean
    title?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection"]>

  export type CollectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organization_id?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    icon?: boolean
    page_content?: boolean
    enable_author?: boolean
    enable_comments?: boolean
    enable_featured_posts?: boolean
    enable_rating?: boolean
    path_prefix?: boolean
    title?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection"]>

  export type CollectionSelectScalar = {
    id?: boolean
    name?: boolean
    organization_id?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    icon?: boolean
    page_content?: boolean
    enable_author?: boolean
    enable_comments?: boolean
    enable_featured_posts?: boolean
    enable_rating?: boolean
    path_prefix?: boolean
    title?: boolean
  }

  export type CollectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "organization_id" | "description" | "created_at" | "updated_at" | "icon" | "page_content" | "enable_author" | "enable_comments" | "enable_featured_posts" | "enable_rating" | "path_prefix" | "title", ExtArgs["result"]["collection"]>
  export type CollectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Category?: boolean | Collection$CategoryArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Content?: boolean | Collection$ContentArgs<ExtArgs>
    Field?: boolean | Collection$FieldArgs<ExtArgs>
    Template?: boolean | Collection$TemplateArgs<ExtArgs>
    form_field?: boolean | Collection$form_fieldArgs<ExtArgs>
    _count?: boolean | CollectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CollectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type CollectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $CollectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Collection"
    objects: {
      Category: Prisma.$CategoryPayload<ExtArgs>[]
      Organization: Prisma.$OrganizationPayload<ExtArgs>
      Content: Prisma.$ContentPayload<ExtArgs>[]
      Field: Prisma.$FieldPayload<ExtArgs>[]
      Template: Prisma.$TemplatePayload<ExtArgs>[]
      form_field: Prisma.$form_fieldPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      organization_id: number
      description: string | null
      created_at: Date
      updated_at: Date
      icon: string
      page_content: boolean
      enable_author: boolean
      enable_comments: boolean
      enable_featured_posts: boolean
      enable_rating: boolean
      path_prefix: string | null
      title: string | null
    }, ExtArgs["result"]["collection"]>
    composites: {}
  }

  export type CollectionGetPayload<S extends boolean | null | undefined | CollectionDefaultArgs> = $Result.GetResult<Prisma.$CollectionPayload, S>

  type CollectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CollectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CollectionCountAggregateInputType | true
    }

  export interface CollectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'Collection' } }
    /**
     * Find zero or one Collection that matches the filter.
     * @param {CollectionFindUniqueArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollectionFindUniqueArgs>(args: SelectSubset<T, CollectionFindUniqueArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Collection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CollectionFindUniqueOrThrowArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollectionFindUniqueOrThrowArgs>(args: SelectSubset<T, CollectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Collection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionFindFirstArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollectionFindFirstArgs>(args?: SelectSubset<T, CollectionFindFirstArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Collection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionFindFirstOrThrowArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollectionFindFirstOrThrowArgs>(args?: SelectSubset<T, CollectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Collections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collections
     * const collections = await prisma.collection.findMany()
     * 
     * // Get first 10 Collections
     * const collections = await prisma.collection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionWithIdOnly = await prisma.collection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollectionFindManyArgs>(args?: SelectSubset<T, CollectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Collection.
     * @param {CollectionCreateArgs} args - Arguments to create a Collection.
     * @example
     * // Create one Collection
     * const Collection = await prisma.collection.create({
     *   data: {
     *     // ... data to create a Collection
     *   }
     * })
     * 
     */
    create<T extends CollectionCreateArgs>(args: SelectSubset<T, CollectionCreateArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Collections.
     * @param {CollectionCreateManyArgs} args - Arguments to create many Collections.
     * @example
     * // Create many Collections
     * const collection = await prisma.collection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollectionCreateManyArgs>(args?: SelectSubset<T, CollectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Collections and returns the data saved in the database.
     * @param {CollectionCreateManyAndReturnArgs} args - Arguments to create many Collections.
     * @example
     * // Create many Collections
     * const collection = await prisma.collection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Collections and only return the `id`
     * const collectionWithIdOnly = await prisma.collection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollectionCreateManyAndReturnArgs>(args?: SelectSubset<T, CollectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Collection.
     * @param {CollectionDeleteArgs} args - Arguments to delete one Collection.
     * @example
     * // Delete one Collection
     * const Collection = await prisma.collection.delete({
     *   where: {
     *     // ... filter to delete one Collection
     *   }
     * })
     * 
     */
    delete<T extends CollectionDeleteArgs>(args: SelectSubset<T, CollectionDeleteArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Collection.
     * @param {CollectionUpdateArgs} args - Arguments to update one Collection.
     * @example
     * // Update one Collection
     * const collection = await prisma.collection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollectionUpdateArgs>(args: SelectSubset<T, CollectionUpdateArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Collections.
     * @param {CollectionDeleteManyArgs} args - Arguments to filter Collections to delete.
     * @example
     * // Delete a few Collections
     * const { count } = await prisma.collection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollectionDeleteManyArgs>(args?: SelectSubset<T, CollectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collections
     * const collection = await prisma.collection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollectionUpdateManyArgs>(args: SelectSubset<T, CollectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collections and returns the data updated in the database.
     * @param {CollectionUpdateManyAndReturnArgs} args - Arguments to update many Collections.
     * @example
     * // Update many Collections
     * const collection = await prisma.collection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Collections and only return the `id`
     * const collectionWithIdOnly = await prisma.collection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CollectionUpdateManyAndReturnArgs>(args: SelectSubset<T, CollectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Collection.
     * @param {CollectionUpsertArgs} args - Arguments to update or create a Collection.
     * @example
     * // Update or create a Collection
     * const collection = await prisma.collection.upsert({
     *   create: {
     *     // ... data to create a Collection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collection we want to update
     *   }
     * })
     */
    upsert<T extends CollectionUpsertArgs>(args: SelectSubset<T, CollectionUpsertArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCountArgs} args - Arguments to filter Collections to count.
     * @example
     * // Count the number of Collections
     * const count = await prisma.collection.count({
     *   where: {
     *     // ... the filter for the Collections we want to count
     *   }
     * })
    **/
    count<T extends CollectionCountArgs>(
      args?: Subset<T, CollectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionAggregateArgs>(args: Subset<T, CollectionAggregateArgs>): Prisma.PrismaPromise<GetCollectionAggregateType<T>>

    /**
     * Group by Collection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionGroupByArgs['orderBy'] }
        : { orderBy?: CollectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Collection model
   */
  readonly fields: CollectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Collection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Category<T extends Collection$CategoryArgs<ExtArgs> = {}>(args?: Subset<T, Collection$CategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Content<T extends Collection$ContentArgs<ExtArgs> = {}>(args?: Subset<T, Collection$ContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Field<T extends Collection$FieldArgs<ExtArgs> = {}>(args?: Subset<T, Collection$FieldArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Template<T extends Collection$TemplateArgs<ExtArgs> = {}>(args?: Subset<T, Collection$TemplateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    form_field<T extends Collection$form_fieldArgs<ExtArgs> = {}>(args?: Subset<T, Collection$form_fieldArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$form_fieldPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Collection model
   */ 
  interface CollectionFieldRefs {
    readonly id: FieldRef<"Collection", 'Int'>
    readonly name: FieldRef<"Collection", 'String'>
    readonly organization_id: FieldRef<"Collection", 'Int'>
    readonly description: FieldRef<"Collection", 'String'>
    readonly created_at: FieldRef<"Collection", 'DateTime'>
    readonly updated_at: FieldRef<"Collection", 'DateTime'>
    readonly icon: FieldRef<"Collection", 'String'>
    readonly page_content: FieldRef<"Collection", 'Boolean'>
    readonly enable_author: FieldRef<"Collection", 'Boolean'>
    readonly enable_comments: FieldRef<"Collection", 'Boolean'>
    readonly enable_featured_posts: FieldRef<"Collection", 'Boolean'>
    readonly enable_rating: FieldRef<"Collection", 'Boolean'>
    readonly path_prefix: FieldRef<"Collection", 'String'>
    readonly title: FieldRef<"Collection", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Collection findUnique
   */
  export type CollectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collection to fetch.
     */
    where: CollectionWhereUniqueInput
  }

  /**
   * Collection findUniqueOrThrow
   */
  export type CollectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collection to fetch.
     */
    where: CollectionWhereUniqueInput
  }

  /**
   * Collection findFirst
   */
  export type CollectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collection to fetch.
     */
    where?: CollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Collections.
     */
    cursor?: CollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Collections.
     */
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * Collection findFirstOrThrow
   */
  export type CollectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collection to fetch.
     */
    where?: CollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Collections.
     */
    cursor?: CollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Collections.
     */
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * Collection findMany
   */
  export type CollectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collections to fetch.
     */
    where?: CollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Collections.
     */
    cursor?: CollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collections.
     */
    skip?: number
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * Collection create
   */
  export type CollectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Collection.
     */
    data: XOR<CollectionCreateInput, CollectionUncheckedCreateInput>
  }

  /**
   * Collection createMany
   */
  export type CollectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Collections.
     */
    data: CollectionCreateManyInput | CollectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Collection createManyAndReturn
   */
  export type CollectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * The data used to create many Collections.
     */
    data: CollectionCreateManyInput | CollectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Collection update
   */
  export type CollectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Collection.
     */
    data: XOR<CollectionUpdateInput, CollectionUncheckedUpdateInput>
    /**
     * Choose, which Collection to update.
     */
    where: CollectionWhereUniqueInput
  }

  /**
   * Collection updateMany
   */
  export type CollectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Collections.
     */
    data: XOR<CollectionUpdateManyMutationInput, CollectionUncheckedUpdateManyInput>
    /**
     * Filter which Collections to update
     */
    where?: CollectionWhereInput
    /**
     * Limit how many Collections to update.
     */
    limit?: number
  }

  /**
   * Collection updateManyAndReturn
   */
  export type CollectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * The data used to update Collections.
     */
    data: XOR<CollectionUpdateManyMutationInput, CollectionUncheckedUpdateManyInput>
    /**
     * Filter which Collections to update
     */
    where?: CollectionWhereInput
    /**
     * Limit how many Collections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Collection upsert
   */
  export type CollectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Collection to update in case it exists.
     */
    where: CollectionWhereUniqueInput
    /**
     * In case the Collection found by the `where` argument doesn't exist, create a new Collection with this data.
     */
    create: XOR<CollectionCreateInput, CollectionUncheckedCreateInput>
    /**
     * In case the Collection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollectionUpdateInput, CollectionUncheckedUpdateInput>
  }

  /**
   * Collection delete
   */
  export type CollectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter which Collection to delete.
     */
    where: CollectionWhereUniqueInput
  }

  /**
   * Collection deleteMany
   */
  export type CollectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Collections to delete
     */
    where?: CollectionWhereInput
    /**
     * Limit how many Collections to delete.
     */
    limit?: number
  }

  /**
   * Collection.Category
   */
  export type Collection$CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Collection.Content
   */
  export type Collection$ContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    where?: ContentWhereInput
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    cursor?: ContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Collection.Field
   */
  export type Collection$FieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    where?: FieldWhereInput
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    cursor?: FieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldScalarFieldEnum | FieldScalarFieldEnum[]
  }

  /**
   * Collection.Template
   */
  export type Collection$TemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    where?: TemplateWhereInput
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    cursor?: TemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Collection.form_field
   */
  export type Collection$form_fieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_field
     */
    select?: form_fieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form_field
     */
    omit?: form_fieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: form_fieldInclude<ExtArgs> | null
    where?: form_fieldWhereInput
    orderBy?: form_fieldOrderByWithRelationInput | form_fieldOrderByWithRelationInput[]
    cursor?: form_fieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Form_fieldScalarFieldEnum | Form_fieldScalarFieldEnum[]
  }

  /**
   * Collection without action
   */
  export type CollectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    content_id: number | null
    parent_id: number | null
    organization_id: number | null
    rating: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    content_id: number | null
    parent_id: number | null
    organization_id: number | null
    rating: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    text: string | null
    author: string | null
    content_id: number | null
    parent_id: number | null
    created_at: Date | null
    updated_at: Date | null
    approved: boolean | null
    organization_id: number | null
    email: string | null
    image_url: string | null
    rating: number | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    text: string | null
    author: string | null
    content_id: number | null
    parent_id: number | null
    created_at: Date | null
    updated_at: Date | null
    approved: boolean | null
    organization_id: number | null
    email: string | null
    image_url: string | null
    rating: number | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    text: number
    author: number
    content_id: number
    parent_id: number
    created_at: number
    updated_at: number
    approved: number
    organization_id: number
    email: number
    image_url: number
    rating: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    content_id?: true
    parent_id?: true
    organization_id?: true
    rating?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    content_id?: true
    parent_id?: true
    organization_id?: true
    rating?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    text?: true
    author?: true
    content_id?: true
    parent_id?: true
    created_at?: true
    updated_at?: true
    approved?: true
    organization_id?: true
    email?: true
    image_url?: true
    rating?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    text?: true
    author?: true
    content_id?: true
    parent_id?: true
    created_at?: true
    updated_at?: true
    approved?: true
    organization_id?: true
    email?: true
    image_url?: true
    rating?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    text?: true
    author?: true
    content_id?: true
    parent_id?: true
    created_at?: true
    updated_at?: true
    approved?: true
    organization_id?: true
    email?: true
    image_url?: true
    rating?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: number
    text: string
    author: string
    content_id: number
    parent_id: number | null
    created_at: Date
    updated_at: Date
    approved: boolean
    organization_id: number
    email: string
    image_url: string | null
    rating: number | null
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    author?: boolean
    content_id?: boolean
    parent_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    approved?: boolean
    organization_id?: boolean
    email?: boolean
    image_url?: boolean
    rating?: boolean
    Content?: boolean | ContentDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Comment?: boolean | Comment$CommentArgs<ExtArgs>
    other_Comment?: boolean | Comment$other_CommentArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    author?: boolean
    content_id?: boolean
    parent_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    approved?: boolean
    organization_id?: boolean
    email?: boolean
    image_url?: boolean
    rating?: boolean
    Content?: boolean | ContentDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Comment?: boolean | Comment$CommentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    author?: boolean
    content_id?: boolean
    parent_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    approved?: boolean
    organization_id?: boolean
    email?: boolean
    image_url?: boolean
    rating?: boolean
    Content?: boolean | ContentDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Comment?: boolean | Comment$CommentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    text?: boolean
    author?: boolean
    content_id?: boolean
    parent_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    approved?: boolean
    organization_id?: boolean
    email?: boolean
    image_url?: boolean
    rating?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "text" | "author" | "content_id" | "parent_id" | "created_at" | "updated_at" | "approved" | "organization_id" | "email" | "image_url" | "rating", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Content?: boolean | ContentDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Comment?: boolean | Comment$CommentArgs<ExtArgs>
    other_Comment?: boolean | Comment$other_CommentArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Content?: boolean | ContentDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Comment?: boolean | Comment$CommentArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Content?: boolean | ContentDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Comment?: boolean | Comment$CommentArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      Content: Prisma.$ContentPayload<ExtArgs>
      Organization: Prisma.$OrganizationPayload<ExtArgs>
      Comment: Prisma.$CommentPayload<ExtArgs> | null
      other_Comment: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      text: string
      author: string
      content_id: number
      parent_id: number | null
      created_at: Date
      updated_at: Date
      approved: boolean
      organization_id: number
      email: string
      image_url: string | null
      rating: number | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

 export type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Content<T extends ContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentDefaultArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Comment<T extends Comment$CommentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$CommentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    other_Comment<T extends Comment$other_CommentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$other_CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'Int'>
    readonly text: FieldRef<"Comment", 'String'>
    readonly author: FieldRef<"Comment", 'String'>
    readonly content_id: FieldRef<"Comment", 'Int'>
    readonly parent_id: FieldRef<"Comment", 'Int'>
    readonly created_at: FieldRef<"Comment", 'DateTime'>
    readonly updated_at: FieldRef<"Comment", 'DateTime'>
    readonly approved: FieldRef<"Comment", 'Boolean'>
    readonly organization_id: FieldRef<"Comment", 'Int'>
    readonly email: FieldRef<"Comment", 'String'>
    readonly image_url: FieldRef<"Comment", 'String'>
    readonly rating: FieldRef<"Comment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.Comment
   */
  export type Comment$CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.other_Comment
   */
  export type Comment$other_CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model CompletionUsage
   */

  export type AggregateCompletionUsage = {
    _count: CompletionUsageCountAggregateOutputType | null
    _avg: CompletionUsageAvgAggregateOutputType | null
    _sum: CompletionUsageSumAggregateOutputType | null
    _min: CompletionUsageMinAggregateOutputType | null
    _max: CompletionUsageMaxAggregateOutputType | null
  }

  export type CompletionUsageAvgAggregateOutputType = {
    prompt_tokens: number | null
    completion_tokens: number | null
    total_tokens: number | null
    prompt_tokens_cost: number | null
    completion_tokens_cost: number | null
    total_tokens_cost: number | null
    prompt_tokens_price: number | null
    completion_tokens_price: number | null
    total_tokens_price: number | null
    id: number | null
    organization_id: number | null
  }

  export type CompletionUsageSumAggregateOutputType = {
    prompt_tokens: number | null
    completion_tokens: number | null
    total_tokens: number | null
    prompt_tokens_cost: number | null
    completion_tokens_cost: number | null
    total_tokens_cost: number | null
    prompt_tokens_price: number | null
    completion_tokens_price: number | null
    total_tokens_price: number | null
    id: number | null
    organization_id: number | null
  }

  export type CompletionUsageMinAggregateOutputType = {
    created_at: Date | null
    prompt_tokens: number | null
    completion_tokens: number | null
    total_tokens: number | null
    prompt_tokens_cost: number | null
    completion_tokens_cost: number | null
    total_tokens_cost: number | null
    prompt_tokens_price: number | null
    completion_tokens_price: number | null
    total_tokens_price: number | null
    id: number | null
    organization_id: number | null
  }

  export type CompletionUsageMaxAggregateOutputType = {
    created_at: Date | null
    prompt_tokens: number | null
    completion_tokens: number | null
    total_tokens: number | null
    prompt_tokens_cost: number | null
    completion_tokens_cost: number | null
    total_tokens_cost: number | null
    prompt_tokens_price: number | null
    completion_tokens_price: number | null
    total_tokens_price: number | null
    id: number | null
    organization_id: number | null
  }

  export type CompletionUsageCountAggregateOutputType = {
    created_at: number
    prompt_tokens: number
    completion_tokens: number
    total_tokens: number
    prompt_tokens_cost: number
    completion_tokens_cost: number
    total_tokens_cost: number
    prompt_tokens_price: number
    completion_tokens_price: number
    total_tokens_price: number
    id: number
    organization_id: number
    _all: number
  }


  export type CompletionUsageAvgAggregateInputType = {
    prompt_tokens?: true
    completion_tokens?: true
    total_tokens?: true
    prompt_tokens_cost?: true
    completion_tokens_cost?: true
    total_tokens_cost?: true
    prompt_tokens_price?: true
    completion_tokens_price?: true
    total_tokens_price?: true
    id?: true
    organization_id?: true
  }

  export type CompletionUsageSumAggregateInputType = {
    prompt_tokens?: true
    completion_tokens?: true
    total_tokens?: true
    prompt_tokens_cost?: true
    completion_tokens_cost?: true
    total_tokens_cost?: true
    prompt_tokens_price?: true
    completion_tokens_price?: true
    total_tokens_price?: true
    id?: true
    organization_id?: true
  }

  export type CompletionUsageMinAggregateInputType = {
    created_at?: true
    prompt_tokens?: true
    completion_tokens?: true
    total_tokens?: true
    prompt_tokens_cost?: true
    completion_tokens_cost?: true
    total_tokens_cost?: true
    prompt_tokens_price?: true
    completion_tokens_price?: true
    total_tokens_price?: true
    id?: true
    organization_id?: true
  }

  export type CompletionUsageMaxAggregateInputType = {
    created_at?: true
    prompt_tokens?: true
    completion_tokens?: true
    total_tokens?: true
    prompt_tokens_cost?: true
    completion_tokens_cost?: true
    total_tokens_cost?: true
    prompt_tokens_price?: true
    completion_tokens_price?: true
    total_tokens_price?: true
    id?: true
    organization_id?: true
  }

  export type CompletionUsageCountAggregateInputType = {
    created_at?: true
    prompt_tokens?: true
    completion_tokens?: true
    total_tokens?: true
    prompt_tokens_cost?: true
    completion_tokens_cost?: true
    total_tokens_cost?: true
    prompt_tokens_price?: true
    completion_tokens_price?: true
    total_tokens_price?: true
    id?: true
    organization_id?: true
    _all?: true
  }

  export type CompletionUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompletionUsage to aggregate.
     */
    where?: CompletionUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompletionUsages to fetch.
     */
    orderBy?: CompletionUsageOrderByWithRelationInput | CompletionUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompletionUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompletionUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompletionUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompletionUsages
    **/
    _count?: true | CompletionUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompletionUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompletionUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompletionUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompletionUsageMaxAggregateInputType
  }

  export type GetCompletionUsageAggregateType<T extends CompletionUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateCompletionUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompletionUsage[P]>
      : GetScalarType<T[P], AggregateCompletionUsage[P]>
  }




  export type CompletionUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompletionUsageWhereInput
    orderBy?: CompletionUsageOrderByWithAggregationInput | CompletionUsageOrderByWithAggregationInput[]
    by: CompletionUsageScalarFieldEnum[] | CompletionUsageScalarFieldEnum
    having?: CompletionUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompletionUsageCountAggregateInputType | true
    _avg?: CompletionUsageAvgAggregateInputType
    _sum?: CompletionUsageSumAggregateInputType
    _min?: CompletionUsageMinAggregateInputType
    _max?: CompletionUsageMaxAggregateInputType
  }

  export type CompletionUsageGroupByOutputType = {
    created_at: Date
    prompt_tokens: number
    completion_tokens: number
    total_tokens: number
    prompt_tokens_cost: number
    completion_tokens_cost: number
    total_tokens_cost: number
    prompt_tokens_price: number
    completion_tokens_price: number
    total_tokens_price: number
    id: number
    organization_id: number
    _count: CompletionUsageCountAggregateOutputType | null
    _avg: CompletionUsageAvgAggregateOutputType | null
    _sum: CompletionUsageSumAggregateOutputType | null
    _min: CompletionUsageMinAggregateOutputType | null
    _max: CompletionUsageMaxAggregateOutputType | null
  }

  type GetCompletionUsageGroupByPayload<T extends CompletionUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompletionUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompletionUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompletionUsageGroupByOutputType[P]>
            : GetScalarType<T[P], CompletionUsageGroupByOutputType[P]>
        }
      >
    >


  export type CompletionUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    prompt_tokens?: boolean
    completion_tokens?: boolean
    total_tokens?: boolean
    prompt_tokens_cost?: boolean
    completion_tokens_cost?: boolean
    total_tokens_cost?: boolean
    prompt_tokens_price?: boolean
    completion_tokens_price?: boolean
    total_tokens_price?: boolean
    id?: boolean
    organization_id?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["completionUsage"]>

  export type CompletionUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    prompt_tokens?: boolean
    completion_tokens?: boolean
    total_tokens?: boolean
    prompt_tokens_cost?: boolean
    completion_tokens_cost?: boolean
    total_tokens_cost?: boolean
    prompt_tokens_price?: boolean
    completion_tokens_price?: boolean
    total_tokens_price?: boolean
    id?: boolean
    organization_id?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["completionUsage"]>

  export type CompletionUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    prompt_tokens?: boolean
    completion_tokens?: boolean
    total_tokens?: boolean
    prompt_tokens_cost?: boolean
    completion_tokens_cost?: boolean
    total_tokens_cost?: boolean
    prompt_tokens_price?: boolean
    completion_tokens_price?: boolean
    total_tokens_price?: boolean
    id?: boolean
    organization_id?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["completionUsage"]>

  export type CompletionUsageSelectScalar = {
    created_at?: boolean
    prompt_tokens?: boolean
    completion_tokens?: boolean
    total_tokens?: boolean
    prompt_tokens_cost?: boolean
    completion_tokens_cost?: boolean
    total_tokens_cost?: boolean
    prompt_tokens_price?: boolean
    completion_tokens_price?: boolean
    total_tokens_price?: boolean
    id?: boolean
    organization_id?: boolean
  }

  export type CompletionUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"created_at" | "prompt_tokens" | "completion_tokens" | "total_tokens" | "prompt_tokens_cost" | "completion_tokens_cost" | "total_tokens_cost" | "prompt_tokens_price" | "completion_tokens_price" | "total_tokens_price" | "id" | "organization_id", ExtArgs["result"]["completionUsage"]>
  export type CompletionUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type CompletionUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type CompletionUsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $CompletionUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompletionUsage"
    objects: {
      Organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      created_at: Date
      prompt_tokens: number
      completion_tokens: number
      total_tokens: number
      prompt_tokens_cost: number
      completion_tokens_cost: number
      total_tokens_cost: number
      prompt_tokens_price: number
      completion_tokens_price: number
      total_tokens_price: number
      id: number
      organization_id: number
    }, ExtArgs["result"]["completionUsage"]>
    composites: {}
  }

  type CompletionUsageGetPayload<S extends boolean | null | undefined | CompletionUsageDefaultArgs> = $Result.GetResult<Prisma.$CompletionUsagePayload, S>

  type CompletionUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompletionUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompletionUsageCountAggregateInputType | true
    }

  export interface CompletionUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'CompletionUsage' } }
    /**
     * Find zero or one CompletionUsage that matches the filter.
     * @param {CompletionUsageFindUniqueArgs} args - Arguments to find a CompletionUsage
     * @example
     * // Get one CompletionUsage
     * const completionUsage = await prisma.completionUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompletionUsageFindUniqueArgs>(args: SelectSubset<T, CompletionUsageFindUniqueArgs<ExtArgs>>): Prisma__CompletionUsageClient<$Result.GetResult<Prisma.$CompletionUsagePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CompletionUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompletionUsageFindUniqueOrThrowArgs} args - Arguments to find a CompletionUsage
     * @example
     * // Get one CompletionUsage
     * const completionUsage = await prisma.completionUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompletionUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, CompletionUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompletionUsageClient<$Result.GetResult<Prisma.$CompletionUsagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CompletionUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletionUsageFindFirstArgs} args - Arguments to find a CompletionUsage
     * @example
     * // Get one CompletionUsage
     * const completionUsage = await prisma.completionUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompletionUsageFindFirstArgs>(args?: SelectSubset<T, CompletionUsageFindFirstArgs<ExtArgs>>): Prisma__CompletionUsageClient<$Result.GetResult<Prisma.$CompletionUsagePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CompletionUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletionUsageFindFirstOrThrowArgs} args - Arguments to find a CompletionUsage
     * @example
     * // Get one CompletionUsage
     * const completionUsage = await prisma.completionUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompletionUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, CompletionUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompletionUsageClient<$Result.GetResult<Prisma.$CompletionUsagePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CompletionUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletionUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompletionUsages
     * const completionUsages = await prisma.completionUsage.findMany()
     * 
     * // Get first 10 CompletionUsages
     * const completionUsages = await prisma.completionUsage.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const completionUsageWithCreated_atOnly = await prisma.completionUsage.findMany({ select: { created_at: true } })
     * 
     */
    findMany<T extends CompletionUsageFindManyArgs>(args?: SelectSubset<T, CompletionUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompletionUsagePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CompletionUsage.
     * @param {CompletionUsageCreateArgs} args - Arguments to create a CompletionUsage.
     * @example
     * // Create one CompletionUsage
     * const CompletionUsage = await prisma.completionUsage.create({
     *   data: {
     *     // ... data to create a CompletionUsage
     *   }
     * })
     * 
     */
    create<T extends CompletionUsageCreateArgs>(args: SelectSubset<T, CompletionUsageCreateArgs<ExtArgs>>): Prisma__CompletionUsageClient<$Result.GetResult<Prisma.$CompletionUsagePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CompletionUsages.
     * @param {CompletionUsageCreateManyArgs} args - Arguments to create many CompletionUsages.
     * @example
     * // Create many CompletionUsages
     * const completionUsage = await prisma.completionUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompletionUsageCreateManyArgs>(args?: SelectSubset<T, CompletionUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompletionUsages and returns the data saved in the database.
     * @param {CompletionUsageCreateManyAndReturnArgs} args - Arguments to create many CompletionUsages.
     * @example
     * // Create many CompletionUsages
     * const completionUsage = await prisma.completionUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompletionUsages and only return the `created_at`
     * const completionUsageWithCreated_atOnly = await prisma.completionUsage.createManyAndReturn({
     *   select: { created_at: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompletionUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, CompletionUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompletionUsagePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CompletionUsage.
     * @param {CompletionUsageDeleteArgs} args - Arguments to delete one CompletionUsage.
     * @example
     * // Delete one CompletionUsage
     * const CompletionUsage = await prisma.completionUsage.delete({
     *   where: {
     *     // ... filter to delete one CompletionUsage
     *   }
     * })
     * 
     */
    delete<T extends CompletionUsageDeleteArgs>(args: SelectSubset<T, CompletionUsageDeleteArgs<ExtArgs>>): Prisma__CompletionUsageClient<$Result.GetResult<Prisma.$CompletionUsagePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CompletionUsage.
     * @param {CompletionUsageUpdateArgs} args - Arguments to update one CompletionUsage.
     * @example
     * // Update one CompletionUsage
     * const completionUsage = await prisma.completionUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompletionUsageUpdateArgs>(args: SelectSubset<T, CompletionUsageUpdateArgs<ExtArgs>>): Prisma__CompletionUsageClient<$Result.GetResult<Prisma.$CompletionUsagePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CompletionUsages.
     * @param {CompletionUsageDeleteManyArgs} args - Arguments to filter CompletionUsages to delete.
     * @example
     * // Delete a few CompletionUsages
     * const { count } = await prisma.completionUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompletionUsageDeleteManyArgs>(args?: SelectSubset<T, CompletionUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompletionUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletionUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompletionUsages
     * const completionUsage = await prisma.completionUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompletionUsageUpdateManyArgs>(args: SelectSubset<T, CompletionUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompletionUsages and returns the data updated in the database.
     * @param {CompletionUsageUpdateManyAndReturnArgs} args - Arguments to update many CompletionUsages.
     * @example
     * // Update many CompletionUsages
     * const completionUsage = await prisma.completionUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompletionUsages and only return the `created_at`
     * const completionUsageWithCreated_atOnly = await prisma.completionUsage.updateManyAndReturn({
     *   select: { created_at: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompletionUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, CompletionUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompletionUsagePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CompletionUsage.
     * @param {CompletionUsageUpsertArgs} args - Arguments to update or create a CompletionUsage.
     * @example
     * // Update or create a CompletionUsage
     * const completionUsage = await prisma.completionUsage.upsert({
     *   create: {
     *     // ... data to create a CompletionUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompletionUsage we want to update
     *   }
     * })
     */
    upsert<T extends CompletionUsageUpsertArgs>(args: SelectSubset<T, CompletionUsageUpsertArgs<ExtArgs>>): Prisma__CompletionUsageClient<$Result.GetResult<Prisma.$CompletionUsagePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CompletionUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletionUsageCountArgs} args - Arguments to filter CompletionUsages to count.
     * @example
     * // Count the number of CompletionUsages
     * const count = await prisma.completionUsage.count({
     *   where: {
     *     // ... the filter for the CompletionUsages we want to count
     *   }
     * })
    **/
    count<T extends CompletionUsageCountArgs>(
      args?: Subset<T, CompletionUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompletionUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompletionUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletionUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompletionUsageAggregateArgs>(args: Subset<T, CompletionUsageAggregateArgs>): Prisma.PrismaPromise<GetCompletionUsageAggregateType<T>>

    /**
     * Group by CompletionUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletionUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompletionUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompletionUsageGroupByArgs['orderBy'] }
        : { orderBy?: CompletionUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompletionUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompletionUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompletionUsage model
   */
  readonly fields: CompletionUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompletionUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompletionUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompletionUsage model
   */ 
  interface CompletionUsageFieldRefs {
    readonly created_at: FieldRef<"CompletionUsage", 'DateTime'>
    readonly prompt_tokens: FieldRef<"CompletionUsage", 'Int'>
    readonly completion_tokens: FieldRef<"CompletionUsage", 'Int'>
    readonly total_tokens: FieldRef<"CompletionUsage", 'Int'>
    readonly prompt_tokens_cost: FieldRef<"CompletionUsage", 'Float'>
    readonly completion_tokens_cost: FieldRef<"CompletionUsage", 'Float'>
    readonly total_tokens_cost: FieldRef<"CompletionUsage", 'Float'>
    readonly prompt_tokens_price: FieldRef<"CompletionUsage", 'Float'>
    readonly completion_tokens_price: FieldRef<"CompletionUsage", 'Float'>
    readonly total_tokens_price: FieldRef<"CompletionUsage", 'Float'>
    readonly id: FieldRef<"CompletionUsage", 'Int'>
    readonly organization_id: FieldRef<"CompletionUsage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CompletionUsage findUnique
   */
  export type CompletionUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionUsage
     */
    select?: CompletionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionUsage
     */
    omit?: CompletionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletionUsageInclude<ExtArgs> | null
    /**
     * Filter, which CompletionUsage to fetch.
     */
    where: CompletionUsageWhereUniqueInput
  }

  /**
   * CompletionUsage findUniqueOrThrow
   */
  export type CompletionUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionUsage
     */
    select?: CompletionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionUsage
     */
    omit?: CompletionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletionUsageInclude<ExtArgs> | null
    /**
     * Filter, which CompletionUsage to fetch.
     */
    where: CompletionUsageWhereUniqueInput
  }

  /**
   * CompletionUsage findFirst
   */
  export type CompletionUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionUsage
     */
    select?: CompletionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionUsage
     */
    omit?: CompletionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletionUsageInclude<ExtArgs> | null
    /**
     * Filter, which CompletionUsage to fetch.
     */
    where?: CompletionUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompletionUsages to fetch.
     */
    orderBy?: CompletionUsageOrderByWithRelationInput | CompletionUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompletionUsages.
     */
    cursor?: CompletionUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompletionUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompletionUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompletionUsages.
     */
    distinct?: CompletionUsageScalarFieldEnum | CompletionUsageScalarFieldEnum[]
  }

  /**
   * CompletionUsage findFirstOrThrow
   */
  export type CompletionUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionUsage
     */
    select?: CompletionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionUsage
     */
    omit?: CompletionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletionUsageInclude<ExtArgs> | null
    /**
     * Filter, which CompletionUsage to fetch.
     */
    where?: CompletionUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompletionUsages to fetch.
     */
    orderBy?: CompletionUsageOrderByWithRelationInput | CompletionUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompletionUsages.
     */
    cursor?: CompletionUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompletionUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompletionUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompletionUsages.
     */
    distinct?: CompletionUsageScalarFieldEnum | CompletionUsageScalarFieldEnum[]
  }

  /**
   * CompletionUsage findMany
   */
  export type CompletionUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionUsage
     */
    select?: CompletionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionUsage
     */
    omit?: CompletionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletionUsageInclude<ExtArgs> | null
    /**
     * Filter, which CompletionUsages to fetch.
     */
    where?: CompletionUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompletionUsages to fetch.
     */
    orderBy?: CompletionUsageOrderByWithRelationInput | CompletionUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompletionUsages.
     */
    cursor?: CompletionUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompletionUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompletionUsages.
     */
    skip?: number
    distinct?: CompletionUsageScalarFieldEnum | CompletionUsageScalarFieldEnum[]
  }

  /**
   * CompletionUsage create
   */
  export type CompletionUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionUsage
     */
    select?: CompletionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionUsage
     */
    omit?: CompletionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletionUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a CompletionUsage.
     */
    data: XOR<CompletionUsageCreateInput, CompletionUsageUncheckedCreateInput>
  }

  /**
   * CompletionUsage createMany
   */
  export type CompletionUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompletionUsages.
     */
    data: CompletionUsageCreateManyInput | CompletionUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompletionUsage createManyAndReturn
   */
  export type CompletionUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionUsage
     */
    select?: CompletionUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionUsage
     */
    omit?: CompletionUsageOmit<ExtArgs> | null
    /**
     * The data used to create many CompletionUsages.
     */
    data: CompletionUsageCreateManyInput | CompletionUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletionUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompletionUsage update
   */
  export type CompletionUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionUsage
     */
    select?: CompletionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionUsage
     */
    omit?: CompletionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletionUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a CompletionUsage.
     */
    data: XOR<CompletionUsageUpdateInput, CompletionUsageUncheckedUpdateInput>
    /**
     * Choose, which CompletionUsage to update.
     */
    where: CompletionUsageWhereUniqueInput
  }

  /**
   * CompletionUsage updateMany
   */
  export type CompletionUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompletionUsages.
     */
    data: XOR<CompletionUsageUpdateManyMutationInput, CompletionUsageUncheckedUpdateManyInput>
    /**
     * Filter which CompletionUsages to update
     */
    where?: CompletionUsageWhereInput
    /**
     * Limit how many CompletionUsages to update.
     */
    limit?: number
  }

  /**
   * CompletionUsage updateManyAndReturn
   */
  export type CompletionUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionUsage
     */
    select?: CompletionUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionUsage
     */
    omit?: CompletionUsageOmit<ExtArgs> | null
    /**
     * The data used to update CompletionUsages.
     */
    data: XOR<CompletionUsageUpdateManyMutationInput, CompletionUsageUncheckedUpdateManyInput>
    /**
     * Filter which CompletionUsages to update
     */
    where?: CompletionUsageWhereInput
    /**
     * Limit how many CompletionUsages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletionUsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompletionUsage upsert
   */
  export type CompletionUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionUsage
     */
    select?: CompletionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionUsage
     */
    omit?: CompletionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletionUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the CompletionUsage to update in case it exists.
     */
    where: CompletionUsageWhereUniqueInput
    /**
     * In case the CompletionUsage found by the `where` argument doesn't exist, create a new CompletionUsage with this data.
     */
    create: XOR<CompletionUsageCreateInput, CompletionUsageUncheckedCreateInput>
    /**
     * In case the CompletionUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompletionUsageUpdateInput, CompletionUsageUncheckedUpdateInput>
  }

  /**
   * CompletionUsage delete
   */
  export type CompletionUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionUsage
     */
    select?: CompletionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionUsage
     */
    omit?: CompletionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletionUsageInclude<ExtArgs> | null
    /**
     * Filter which CompletionUsage to delete.
     */
    where: CompletionUsageWhereUniqueInput
  }

  /**
   * CompletionUsage deleteMany
   */
  export type CompletionUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompletionUsages to delete
     */
    where?: CompletionUsageWhereInput
    /**
     * Limit how many CompletionUsages to delete.
     */
    limit?: number
  }

  /**
   * CompletionUsage without action
   */
  export type CompletionUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionUsage
     */
    select?: CompletionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionUsage
     */
    omit?: CompletionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletionUsageInclude<ExtArgs> | null
  }


  /**
   * Model Content
   */

  export type AggregateContent = {
    _count: ContentCountAggregateOutputType | null
    _avg: ContentAvgAggregateOutputType | null
    _sum: ContentSumAggregateOutputType | null
    _min: ContentMinAggregateOutputType | null
    _max: ContentMaxAggregateOutputType | null
  }

  export type ContentAvgAggregateOutputType = {
    id: number | null
    collection_id: number | null
    organization_id: number | null
    author_id: number | null
  }

  export type ContentSumAggregateOutputType = {
    id: number | null
    collection_id: number | null
    organization_id: number | null
    author_id: number | null
  }

  export type ContentMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    html: string | null
    archive: boolean | null
    collection_id: number | null
    description: string | null
    draft: boolean | null
    slug: string | null
    title: string | null
    comments_enabled: boolean | null
    organization_id: number | null
    author_id: number | null
    featured: boolean | null
  }

  export type ContentMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    html: string | null
    archive: boolean | null
    collection_id: number | null
    description: string | null
    draft: boolean | null
    slug: string | null
    title: string | null
    comments_enabled: boolean | null
    organization_id: number | null
    author_id: number | null
    featured: boolean | null
  }

  export type ContentCountAggregateOutputType = {
    id: number
    data: number
    created_at: number
    updated_at: number
    blocks: number
    html: number
    archive: number
    collection_id: number
    description: number
    draft: number
    slug: number
    title: number
    comments_enabled: number
    organization_id: number
    author_id: number
    featured: number
    content_category: number
    _all: number
  }


  export type ContentAvgAggregateInputType = {
    id?: true
    collection_id?: true
    organization_id?: true
    author_id?: true
  }

  export type ContentSumAggregateInputType = {
    id?: true
    collection_id?: true
    organization_id?: true
    author_id?: true
  }

  export type ContentMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    html?: true
    archive?: true
    collection_id?: true
    description?: true
    draft?: true
    slug?: true
    title?: true
    comments_enabled?: true
    organization_id?: true
    author_id?: true
    featured?: true
  }

  export type ContentMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    html?: true
    archive?: true
    collection_id?: true
    description?: true
    draft?: true
    slug?: true
    title?: true
    comments_enabled?: true
    organization_id?: true
    author_id?: true
    featured?: true
  }

  export type ContentCountAggregateInputType = {
    id?: true
    data?: true
    created_at?: true
    updated_at?: true
    blocks?: true
    html?: true
    archive?: true
    collection_id?: true
    description?: true
    draft?: true
    slug?: true
    title?: true
    comments_enabled?: true
    organization_id?: true
    author_id?: true
    featured?: true
    content_category?: true
    _all?: true
  }

  export type ContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Content to aggregate.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contents
    **/
    _count?: true | ContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentMaxAggregateInputType
  }

  export type GetContentAggregateType<T extends ContentAggregateArgs> = {
        [P in keyof T & keyof AggregateContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContent[P]>
      : GetScalarType<T[P], AggregateContent[P]>
  }




  export type ContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentWhereInput
    orderBy?: ContentOrderByWithAggregationInput | ContentOrderByWithAggregationInput[]
    by: ContentScalarFieldEnum[] | ContentScalarFieldEnum
    having?: ContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentCountAggregateInputType | true
    _avg?: ContentAvgAggregateInputType
    _sum?: ContentSumAggregateInputType
    _min?: ContentMinAggregateInputType
    _max?: ContentMaxAggregateInputType
  }

  export type ContentGroupByOutputType = {
    id: number
    data: JsonValue
    created_at: Date
    updated_at: Date
    blocks: JsonValue
    html: string
    archive: boolean
    collection_id: number
    description: string | null
    draft: boolean
    slug: string
    title: string | null
    comments_enabled: boolean
    organization_id: number | null
    author_id: number | null
    featured: boolean
    content_category: string[]
    _count: ContentCountAggregateOutputType | null
    _avg: ContentAvgAggregateOutputType | null
    _sum: ContentSumAggregateOutputType | null
    _min: ContentMinAggregateOutputType | null
    _max: ContentMaxAggregateOutputType | null
  }

  type GetContentGroupByPayload<T extends ContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentGroupByOutputType[P]>
            : GetScalarType<T[P], ContentGroupByOutputType[P]>
        }
      >
    >


  export type ContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
    blocks?: boolean
    html?: boolean
    archive?: boolean
    collection_id?: boolean
    description?: boolean
    draft?: boolean
    slug?: boolean
    title?: boolean
    comments_enabled?: boolean
    organization_id?: boolean
    author_id?: boolean
    featured?: boolean
    content_category?: boolean
    Comment?: boolean | Content$CommentArgs<ExtArgs>
    author?: boolean | Content$authorArgs<ExtArgs>
    Collection?: boolean | CollectionDefaultArgs<ExtArgs>
    Organization?: boolean | Content$OrganizationArgs<ExtArgs>
    ContentTemplateInstance?: boolean | Content$ContentTemplateInstanceArgs<ExtArgs>
    Category?: boolean | Content$CategoryArgs<ExtArgs>
    _count?: boolean | ContentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["content"]>

  export type ContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
    blocks?: boolean
    html?: boolean
    archive?: boolean
    collection_id?: boolean
    description?: boolean
    draft?: boolean
    slug?: boolean
    title?: boolean
    comments_enabled?: boolean
    organization_id?: boolean
    author_id?: boolean
    featured?: boolean
    content_category?: boolean
    author?: boolean | Content$authorArgs<ExtArgs>
    Collection?: boolean | CollectionDefaultArgs<ExtArgs>
    Organization?: boolean | Content$OrganizationArgs<ExtArgs>
  }, ExtArgs["result"]["content"]>

  export type ContentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
    blocks?: boolean
    html?: boolean
    archive?: boolean
    collection_id?: boolean
    description?: boolean
    draft?: boolean
    slug?: boolean
    title?: boolean
    comments_enabled?: boolean
    organization_id?: boolean
    author_id?: boolean
    featured?: boolean
    content_category?: boolean
    author?: boolean | Content$authorArgs<ExtArgs>
    Collection?: boolean | CollectionDefaultArgs<ExtArgs>
    Organization?: boolean | Content$OrganizationArgs<ExtArgs>
  }, ExtArgs["result"]["content"]>

  export type ContentSelectScalar = {
    id?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
    blocks?: boolean
    html?: boolean
    archive?: boolean
    collection_id?: boolean
    description?: boolean
    draft?: boolean
    slug?: boolean
    title?: boolean
    comments_enabled?: boolean
    organization_id?: boolean
    author_id?: boolean
    featured?: boolean
    content_category?: boolean
  }

  export type ContentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "data" | "created_at" | "updated_at" | "blocks" | "html" | "archive" | "collection_id" | "description" | "draft" | "slug" | "title" | "comments_enabled" | "organization_id" | "author_id" | "featured" | "content_category", ExtArgs["result"]["content"]>
  export type ContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comment?: boolean | Content$CommentArgs<ExtArgs>
    author?: boolean | Content$authorArgs<ExtArgs>
    Collection?: boolean | CollectionDefaultArgs<ExtArgs>
    Organization?: boolean | Content$OrganizationArgs<ExtArgs>
    ContentTemplateInstance?: boolean | Content$ContentTemplateInstanceArgs<ExtArgs>
    Category?: boolean | Content$CategoryArgs<ExtArgs>
    _count?: boolean | ContentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | Content$authorArgs<ExtArgs>
    Collection?: boolean | CollectionDefaultArgs<ExtArgs>
    Organization?: boolean | Content$OrganizationArgs<ExtArgs>
  }
  export type ContentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | Content$authorArgs<ExtArgs>
    Collection?: boolean | CollectionDefaultArgs<ExtArgs>
    Organization?: boolean | Content$OrganizationArgs<ExtArgs>
  }

  export type $ContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Content"
    objects: {
      Comment: Prisma.$CommentPayload<ExtArgs>[]
      author: Prisma.$authorPayload<ExtArgs> | null
      Collection: Prisma.$CollectionPayload<ExtArgs>
      Organization: Prisma.$OrganizationPayload<ExtArgs> | null
      ContentTemplateInstance: Prisma.$ContentTemplateInstancePayload<ExtArgs>[]
      Category: Prisma.$CategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      data: Prisma.JsonValue
      created_at: Date
      updated_at: Date
      blocks: Prisma.JsonValue
      html: string
      archive: boolean
      collection_id: number
      description: string | null
      draft: boolean
      slug: string
      title: string | null
      comments_enabled: boolean
      organization_id: number | null
      author_id: number | null
      featured: boolean
      content_category: string[]
    }, ExtArgs["result"]["content"]>
    composites: {}
  }

  export type ContentGetPayload<S extends boolean | null | undefined | ContentDefaultArgs> = $Result.GetResult<Prisma.$ContentPayload, S>

  type ContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentCountAggregateInputType | true
    }

  export interface ContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'Content' } }
    /**
     * Find zero or one Content that matches the filter.
     * @param {ContentFindUniqueArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentFindUniqueArgs>(args: SelectSubset<T, ContentFindUniqueArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Content that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentFindUniqueOrThrowArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Content that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindFirstArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentFindFirstArgs>(args?: SelectSubset<T, ContentFindFirstArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Content that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindFirstOrThrowArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contents
     * const contents = await prisma.content.findMany()
     * 
     * // Get first 10 Contents
     * const contents = await prisma.content.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentWithIdOnly = await prisma.content.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentFindManyArgs>(args?: SelectSubset<T, ContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Content.
     * @param {ContentCreateArgs} args - Arguments to create a Content.
     * @example
     * // Create one Content
     * const Content = await prisma.content.create({
     *   data: {
     *     // ... data to create a Content
     *   }
     * })
     * 
     */
    create<T extends ContentCreateArgs>(args: SelectSubset<T, ContentCreateArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Contents.
     * @param {ContentCreateManyArgs} args - Arguments to create many Contents.
     * @example
     * // Create many Contents
     * const content = await prisma.content.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentCreateManyArgs>(args?: SelectSubset<T, ContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contents and returns the data saved in the database.
     * @param {ContentCreateManyAndReturnArgs} args - Arguments to create many Contents.
     * @example
     * // Create many Contents
     * const content = await prisma.content.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contents and only return the `id`
     * const contentWithIdOnly = await prisma.content.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Content.
     * @param {ContentDeleteArgs} args - Arguments to delete one Content.
     * @example
     * // Delete one Content
     * const Content = await prisma.content.delete({
     *   where: {
     *     // ... filter to delete one Content
     *   }
     * })
     * 
     */
    delete<T extends ContentDeleteArgs>(args: SelectSubset<T, ContentDeleteArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Content.
     * @param {ContentUpdateArgs} args - Arguments to update one Content.
     * @example
     * // Update one Content
     * const content = await prisma.content.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentUpdateArgs>(args: SelectSubset<T, ContentUpdateArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Contents.
     * @param {ContentDeleteManyArgs} args - Arguments to filter Contents to delete.
     * @example
     * // Delete a few Contents
     * const { count } = await prisma.content.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentDeleteManyArgs>(args?: SelectSubset<T, ContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contents
     * const content = await prisma.content.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentUpdateManyArgs>(args: SelectSubset<T, ContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contents and returns the data updated in the database.
     * @param {ContentUpdateManyAndReturnArgs} args - Arguments to update many Contents.
     * @example
     * // Update many Contents
     * const content = await prisma.content.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contents and only return the `id`
     * const contentWithIdOnly = await prisma.content.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Content.
     * @param {ContentUpsertArgs} args - Arguments to update or create a Content.
     * @example
     * // Update or create a Content
     * const content = await prisma.content.upsert({
     *   create: {
     *     // ... data to create a Content
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Content we want to update
     *   }
     * })
     */
    upsert<T extends ContentUpsertArgs>(args: SelectSubset<T, ContentUpsertArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCountArgs} args - Arguments to filter Contents to count.
     * @example
     * // Count the number of Contents
     * const count = await prisma.content.count({
     *   where: {
     *     // ... the filter for the Contents we want to count
     *   }
     * })
    **/
    count<T extends ContentCountArgs>(
      args?: Subset<T, ContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentAggregateArgs>(args: Subset<T, ContentAggregateArgs>): Prisma.PrismaPromise<GetContentAggregateType<T>>

    /**
     * Group by Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentGroupByArgs['orderBy'] }
        : { orderBy?: ContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Content model
   */
  readonly fields: ContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Content.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Comment<T extends Content$CommentArgs<ExtArgs> = {}>(args?: Subset<T, Content$CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    author<T extends Content$authorArgs<ExtArgs> = {}>(args?: Subset<T, Content$authorArgs<ExtArgs>>): Prisma__authorClient<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Collection<T extends CollectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionDefaultArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Organization<T extends Content$OrganizationArgs<ExtArgs> = {}>(args?: Subset<T, Content$OrganizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    ContentTemplateInstance<T extends Content$ContentTemplateInstanceArgs<ExtArgs> = {}>(args?: Subset<T, Content$ContentTemplateInstanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTemplateInstancePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Category<T extends Content$CategoryArgs<ExtArgs> = {}>(args?: Subset<T, Content$CategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Content model
   */ 
  interface ContentFieldRefs {
    readonly id: FieldRef<"Content", 'Int'>
    readonly data: FieldRef<"Content", 'Json'>
    readonly created_at: FieldRef<"Content", 'DateTime'>
    readonly updated_at: FieldRef<"Content", 'DateTime'>
    readonly blocks: FieldRef<"Content", 'Json'>
    readonly html: FieldRef<"Content", 'String'>
    readonly archive: FieldRef<"Content", 'Boolean'>
    readonly collection_id: FieldRef<"Content", 'Int'>
    readonly description: FieldRef<"Content", 'String'>
    readonly draft: FieldRef<"Content", 'Boolean'>
    readonly slug: FieldRef<"Content", 'String'>
    readonly title: FieldRef<"Content", 'String'>
    readonly comments_enabled: FieldRef<"Content", 'Boolean'>
    readonly organization_id: FieldRef<"Content", 'Int'>
    readonly author_id: FieldRef<"Content", 'Int'>
    readonly featured: FieldRef<"Content", 'Boolean'>
    readonly content_category: FieldRef<"Content", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Content findUnique
   */
  export type ContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content findUniqueOrThrow
   */
  export type ContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content findFirst
   */
  export type ContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contents.
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contents.
     */
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Content findFirstOrThrow
   */
  export type ContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contents.
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contents.
     */
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Content findMany
   */
  export type ContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Contents to fetch.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contents.
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Content create
   */
  export type ContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * The data needed to create a Content.
     */
    data: XOR<ContentCreateInput, ContentUncheckedCreateInput>
  }

  /**
   * Content createMany
   */
  export type ContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contents.
     */
    data: ContentCreateManyInput | ContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Content createManyAndReturn
   */
  export type ContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * The data used to create many Contents.
     */
    data: ContentCreateManyInput | ContentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Content update
   */
  export type ContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * The data needed to update a Content.
     */
    data: XOR<ContentUpdateInput, ContentUncheckedUpdateInput>
    /**
     * Choose, which Content to update.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content updateMany
   */
  export type ContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contents.
     */
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyInput>
    /**
     * Filter which Contents to update
     */
    where?: ContentWhereInput
    /**
     * Limit how many Contents to update.
     */
    limit?: number
  }

  /**
   * Content updateManyAndReturn
   */
  export type ContentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * The data used to update Contents.
     */
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyInput>
    /**
     * Filter which Contents to update
     */
    where?: ContentWhereInput
    /**
     * Limit how many Contents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Content upsert
   */
  export type ContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * The filter to search for the Content to update in case it exists.
     */
    where: ContentWhereUniqueInput
    /**
     * In case the Content found by the `where` argument doesn't exist, create a new Content with this data.
     */
    create: XOR<ContentCreateInput, ContentUncheckedCreateInput>
    /**
     * In case the Content was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentUpdateInput, ContentUncheckedUpdateInput>
  }

  /**
   * Content delete
   */
  export type ContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter which Content to delete.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content deleteMany
   */
  export type ContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contents to delete
     */
    where?: ContentWhereInput
    /**
     * Limit how many Contents to delete.
     */
    limit?: number
  }

  /**
   * Content.Comment
   */
  export type Content$CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Content.author
   */
  export type Content$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    where?: authorWhereInput
  }

  /**
   * Content.Organization
   */
  export type Content$OrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Content.ContentTemplateInstance
   */
  export type Content$ContentTemplateInstanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTemplateInstance
     */
    select?: ContentTemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTemplateInstance
     */
    omit?: ContentTemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTemplateInstanceInclude<ExtArgs> | null
    where?: ContentTemplateInstanceWhereInput
    orderBy?: ContentTemplateInstanceOrderByWithRelationInput | ContentTemplateInstanceOrderByWithRelationInput[]
    cursor?: ContentTemplateInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentTemplateInstanceScalarFieldEnum | ContentTemplateInstanceScalarFieldEnum[]
  }

  /**
   * Content.Category
   */
  export type Content$CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Content without action
   */
  export type ContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
  }


  /**
   * Model ContentTemplateInstance
   */

  export type AggregateContentTemplateInstance = {
    _count: ContentTemplateInstanceCountAggregateOutputType | null
    _avg: ContentTemplateInstanceAvgAggregateOutputType | null
    _sum: ContentTemplateInstanceSumAggregateOutputType | null
    _min: ContentTemplateInstanceMinAggregateOutputType | null
    _max: ContentTemplateInstanceMaxAggregateOutputType | null
  }

  export type ContentTemplateInstanceAvgAggregateOutputType = {
    id: number | null
    content_id: number | null
    template_instance_id: number | null
  }

  export type ContentTemplateInstanceSumAggregateOutputType = {
    id: number | null
    content_id: number | null
    template_instance_id: number | null
  }

  export type ContentTemplateInstanceMinAggregateOutputType = {
    id: number | null
    content_id: number | null
    template_instance_id: number | null
  }

  export type ContentTemplateInstanceMaxAggregateOutputType = {
    id: number | null
    content_id: number | null
    template_instance_id: number | null
  }

  export type ContentTemplateInstanceCountAggregateOutputType = {
    id: number
    content_id: number
    template_instance_id: number
    _all: number
  }


  export type ContentTemplateInstanceAvgAggregateInputType = {
    id?: true
    content_id?: true
    template_instance_id?: true
  }

  export type ContentTemplateInstanceSumAggregateInputType = {
    id?: true
    content_id?: true
    template_instance_id?: true
  }

  export type ContentTemplateInstanceMinAggregateInputType = {
    id?: true
    content_id?: true
    template_instance_id?: true
  }

  export type ContentTemplateInstanceMaxAggregateInputType = {
    id?: true
    content_id?: true
    template_instance_id?: true
  }

  export type ContentTemplateInstanceCountAggregateInputType = {
    id?: true
    content_id?: true
    template_instance_id?: true
    _all?: true
  }

  export type ContentTemplateInstanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentTemplateInstance to aggregate.
     */
    where?: ContentTemplateInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTemplateInstances to fetch.
     */
    orderBy?: ContentTemplateInstanceOrderByWithRelationInput | ContentTemplateInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentTemplateInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTemplateInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTemplateInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentTemplateInstances
    **/
    _count?: true | ContentTemplateInstanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentTemplateInstanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentTemplateInstanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentTemplateInstanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentTemplateInstanceMaxAggregateInputType
  }

  export type GetContentTemplateInstanceAggregateType<T extends ContentTemplateInstanceAggregateArgs> = {
        [P in keyof T & keyof AggregateContentTemplateInstance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentTemplateInstance[P]>
      : GetScalarType<T[P], AggregateContentTemplateInstance[P]>
  }




  export type ContentTemplateInstanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentTemplateInstanceWhereInput
    orderBy?: ContentTemplateInstanceOrderByWithAggregationInput | ContentTemplateInstanceOrderByWithAggregationInput[]
    by: ContentTemplateInstanceScalarFieldEnum[] | ContentTemplateInstanceScalarFieldEnum
    having?: ContentTemplateInstanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentTemplateInstanceCountAggregateInputType | true
    _avg?: ContentTemplateInstanceAvgAggregateInputType
    _sum?: ContentTemplateInstanceSumAggregateInputType
    _min?: ContentTemplateInstanceMinAggregateInputType
    _max?: ContentTemplateInstanceMaxAggregateInputType
  }

  export type ContentTemplateInstanceGroupByOutputType = {
    id: number
    content_id: number
    template_instance_id: number
    _count: ContentTemplateInstanceCountAggregateOutputType | null
    _avg: ContentTemplateInstanceAvgAggregateOutputType | null
    _sum: ContentTemplateInstanceSumAggregateOutputType | null
    _min: ContentTemplateInstanceMinAggregateOutputType | null
    _max: ContentTemplateInstanceMaxAggregateOutputType | null
  }

  type GetContentTemplateInstanceGroupByPayload<T extends ContentTemplateInstanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentTemplateInstanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentTemplateInstanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentTemplateInstanceGroupByOutputType[P]>
            : GetScalarType<T[P], ContentTemplateInstanceGroupByOutputType[P]>
        }
      >
    >


  export type ContentTemplateInstanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content_id?: boolean
    template_instance_id?: boolean
    Content?: boolean | ContentDefaultArgs<ExtArgs>
    TemplateInstance?: boolean | TemplateInstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentTemplateInstance"]>

  export type ContentTemplateInstanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content_id?: boolean
    template_instance_id?: boolean
    Content?: boolean | ContentDefaultArgs<ExtArgs>
    TemplateInstance?: boolean | TemplateInstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentTemplateInstance"]>

  export type ContentTemplateInstanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content_id?: boolean
    template_instance_id?: boolean
    Content?: boolean | ContentDefaultArgs<ExtArgs>
    TemplateInstance?: boolean | TemplateInstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentTemplateInstance"]>

  export type ContentTemplateInstanceSelectScalar = {
    id?: boolean
    content_id?: boolean
    template_instance_id?: boolean
  }

  export type ContentTemplateInstanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content_id" | "template_instance_id", ExtArgs["result"]["contentTemplateInstance"]>
  export type ContentTemplateInstanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Content?: boolean | ContentDefaultArgs<ExtArgs>
    TemplateInstance?: boolean | TemplateInstanceDefaultArgs<ExtArgs>
  }
  export type ContentTemplateInstanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Content?: boolean | ContentDefaultArgs<ExtArgs>
    TemplateInstance?: boolean | TemplateInstanceDefaultArgs<ExtArgs>
  }
  export type ContentTemplateInstanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Content?: boolean | ContentDefaultArgs<ExtArgs>
    TemplateInstance?: boolean | TemplateInstanceDefaultArgs<ExtArgs>
  }

  export type $ContentTemplateInstancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentTemplateInstance"
    objects: {
      Content: Prisma.$ContentPayload<ExtArgs>
      TemplateInstance: Prisma.$TemplateInstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      content_id: number
      template_instance_id: number
    }, ExtArgs["result"]["contentTemplateInstance"]>
    composites: {}
  }

  type ContentTemplateInstanceGetPayload<S extends boolean | null | undefined | ContentTemplateInstanceDefaultArgs> = $Result.GetResult<Prisma.$ContentTemplateInstancePayload, S>

  type ContentTemplateInstanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentTemplateInstanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentTemplateInstanceCountAggregateInputType | true
    }

  export interface ContentTemplateInstanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'ContentTemplateInstance' } }
    /**
     * Find zero or one ContentTemplateInstance that matches the filter.
     * @param {ContentTemplateInstanceFindUniqueArgs} args - Arguments to find a ContentTemplateInstance
     * @example
     * // Get one ContentTemplateInstance
     * const contentTemplateInstance = await prisma.contentTemplateInstance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentTemplateInstanceFindUniqueArgs>(args: SelectSubset<T, ContentTemplateInstanceFindUniqueArgs<ExtArgs>>): Prisma__ContentTemplateInstanceClient<$Result.GetResult<Prisma.$ContentTemplateInstancePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ContentTemplateInstance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentTemplateInstanceFindUniqueOrThrowArgs} args - Arguments to find a ContentTemplateInstance
     * @example
     * // Get one ContentTemplateInstance
     * const contentTemplateInstance = await prisma.contentTemplateInstance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentTemplateInstanceFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentTemplateInstanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentTemplateInstanceClient<$Result.GetResult<Prisma.$ContentTemplateInstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ContentTemplateInstance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTemplateInstanceFindFirstArgs} args - Arguments to find a ContentTemplateInstance
     * @example
     * // Get one ContentTemplateInstance
     * const contentTemplateInstance = await prisma.contentTemplateInstance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentTemplateInstanceFindFirstArgs>(args?: SelectSubset<T, ContentTemplateInstanceFindFirstArgs<ExtArgs>>): Prisma__ContentTemplateInstanceClient<$Result.GetResult<Prisma.$ContentTemplateInstancePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ContentTemplateInstance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTemplateInstanceFindFirstOrThrowArgs} args - Arguments to find a ContentTemplateInstance
     * @example
     * // Get one ContentTemplateInstance
     * const contentTemplateInstance = await prisma.contentTemplateInstance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentTemplateInstanceFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentTemplateInstanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentTemplateInstanceClient<$Result.GetResult<Prisma.$ContentTemplateInstancePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ContentTemplateInstances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTemplateInstanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentTemplateInstances
     * const contentTemplateInstances = await prisma.contentTemplateInstance.findMany()
     * 
     * // Get first 10 ContentTemplateInstances
     * const contentTemplateInstances = await prisma.contentTemplateInstance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentTemplateInstanceWithIdOnly = await prisma.contentTemplateInstance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentTemplateInstanceFindManyArgs>(args?: SelectSubset<T, ContentTemplateInstanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTemplateInstancePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ContentTemplateInstance.
     * @param {ContentTemplateInstanceCreateArgs} args - Arguments to create a ContentTemplateInstance.
     * @example
     * // Create one ContentTemplateInstance
     * const ContentTemplateInstance = await prisma.contentTemplateInstance.create({
     *   data: {
     *     // ... data to create a ContentTemplateInstance
     *   }
     * })
     * 
     */
    create<T extends ContentTemplateInstanceCreateArgs>(args: SelectSubset<T, ContentTemplateInstanceCreateArgs<ExtArgs>>): Prisma__ContentTemplateInstanceClient<$Result.GetResult<Prisma.$ContentTemplateInstancePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ContentTemplateInstances.
     * @param {ContentTemplateInstanceCreateManyArgs} args - Arguments to create many ContentTemplateInstances.
     * @example
     * // Create many ContentTemplateInstances
     * const contentTemplateInstance = await prisma.contentTemplateInstance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentTemplateInstanceCreateManyArgs>(args?: SelectSubset<T, ContentTemplateInstanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentTemplateInstances and returns the data saved in the database.
     * @param {ContentTemplateInstanceCreateManyAndReturnArgs} args - Arguments to create many ContentTemplateInstances.
     * @example
     * // Create many ContentTemplateInstances
     * const contentTemplateInstance = await prisma.contentTemplateInstance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentTemplateInstances and only return the `id`
     * const contentTemplateInstanceWithIdOnly = await prisma.contentTemplateInstance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentTemplateInstanceCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentTemplateInstanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTemplateInstancePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ContentTemplateInstance.
     * @param {ContentTemplateInstanceDeleteArgs} args - Arguments to delete one ContentTemplateInstance.
     * @example
     * // Delete one ContentTemplateInstance
     * const ContentTemplateInstance = await prisma.contentTemplateInstance.delete({
     *   where: {
     *     // ... filter to delete one ContentTemplateInstance
     *   }
     * })
     * 
     */
    delete<T extends ContentTemplateInstanceDeleteArgs>(args: SelectSubset<T, ContentTemplateInstanceDeleteArgs<ExtArgs>>): Prisma__ContentTemplateInstanceClient<$Result.GetResult<Prisma.$ContentTemplateInstancePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ContentTemplateInstance.
     * @param {ContentTemplateInstanceUpdateArgs} args - Arguments to update one ContentTemplateInstance.
     * @example
     * // Update one ContentTemplateInstance
     * const contentTemplateInstance = await prisma.contentTemplateInstance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentTemplateInstanceUpdateArgs>(args: SelectSubset<T, ContentTemplateInstanceUpdateArgs<ExtArgs>>): Prisma__ContentTemplateInstanceClient<$Result.GetResult<Prisma.$ContentTemplateInstancePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ContentTemplateInstances.
     * @param {ContentTemplateInstanceDeleteManyArgs} args - Arguments to filter ContentTemplateInstances to delete.
     * @example
     * // Delete a few ContentTemplateInstances
     * const { count } = await prisma.contentTemplateInstance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentTemplateInstanceDeleteManyArgs>(args?: SelectSubset<T, ContentTemplateInstanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentTemplateInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTemplateInstanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentTemplateInstances
     * const contentTemplateInstance = await prisma.contentTemplateInstance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentTemplateInstanceUpdateManyArgs>(args: SelectSubset<T, ContentTemplateInstanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentTemplateInstances and returns the data updated in the database.
     * @param {ContentTemplateInstanceUpdateManyAndReturnArgs} args - Arguments to update many ContentTemplateInstances.
     * @example
     * // Update many ContentTemplateInstances
     * const contentTemplateInstance = await prisma.contentTemplateInstance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentTemplateInstances and only return the `id`
     * const contentTemplateInstanceWithIdOnly = await prisma.contentTemplateInstance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentTemplateInstanceUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentTemplateInstanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTemplateInstancePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ContentTemplateInstance.
     * @param {ContentTemplateInstanceUpsertArgs} args - Arguments to update or create a ContentTemplateInstance.
     * @example
     * // Update or create a ContentTemplateInstance
     * const contentTemplateInstance = await prisma.contentTemplateInstance.upsert({
     *   create: {
     *     // ... data to create a ContentTemplateInstance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentTemplateInstance we want to update
     *   }
     * })
     */
    upsert<T extends ContentTemplateInstanceUpsertArgs>(args: SelectSubset<T, ContentTemplateInstanceUpsertArgs<ExtArgs>>): Prisma__ContentTemplateInstanceClient<$Result.GetResult<Prisma.$ContentTemplateInstancePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ContentTemplateInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTemplateInstanceCountArgs} args - Arguments to filter ContentTemplateInstances to count.
     * @example
     * // Count the number of ContentTemplateInstances
     * const count = await prisma.contentTemplateInstance.count({
     *   where: {
     *     // ... the filter for the ContentTemplateInstances we want to count
     *   }
     * })
    **/
    count<T extends ContentTemplateInstanceCountArgs>(
      args?: Subset<T, ContentTemplateInstanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentTemplateInstanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentTemplateInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTemplateInstanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentTemplateInstanceAggregateArgs>(args: Subset<T, ContentTemplateInstanceAggregateArgs>): Prisma.PrismaPromise<GetContentTemplateInstanceAggregateType<T>>

    /**
     * Group by ContentTemplateInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTemplateInstanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentTemplateInstanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentTemplateInstanceGroupByArgs['orderBy'] }
        : { orderBy?: ContentTemplateInstanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentTemplateInstanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentTemplateInstanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentTemplateInstance model
   */
  readonly fields: ContentTemplateInstanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentTemplateInstance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentTemplateInstanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Content<T extends ContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentDefaultArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TemplateInstance<T extends TemplateInstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TemplateInstanceDefaultArgs<ExtArgs>>): Prisma__TemplateInstanceClient<$Result.GetResult<Prisma.$TemplateInstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentTemplateInstance model
   */ 
  interface ContentTemplateInstanceFieldRefs {
    readonly id: FieldRef<"ContentTemplateInstance", 'Int'>
    readonly content_id: FieldRef<"ContentTemplateInstance", 'Int'>
    readonly template_instance_id: FieldRef<"ContentTemplateInstance", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ContentTemplateInstance findUnique
   */
  export type ContentTemplateInstanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTemplateInstance
     */
    select?: ContentTemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTemplateInstance
     */
    omit?: ContentTemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTemplateInstanceInclude<ExtArgs> | null
    /**
     * Filter, which ContentTemplateInstance to fetch.
     */
    where: ContentTemplateInstanceWhereUniqueInput
  }

  /**
   * ContentTemplateInstance findUniqueOrThrow
   */
  export type ContentTemplateInstanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTemplateInstance
     */
    select?: ContentTemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTemplateInstance
     */
    omit?: ContentTemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTemplateInstanceInclude<ExtArgs> | null
    /**
     * Filter, which ContentTemplateInstance to fetch.
     */
    where: ContentTemplateInstanceWhereUniqueInput
  }

  /**
   * ContentTemplateInstance findFirst
   */
  export type ContentTemplateInstanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTemplateInstance
     */
    select?: ContentTemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTemplateInstance
     */
    omit?: ContentTemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTemplateInstanceInclude<ExtArgs> | null
    /**
     * Filter, which ContentTemplateInstance to fetch.
     */
    where?: ContentTemplateInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTemplateInstances to fetch.
     */
    orderBy?: ContentTemplateInstanceOrderByWithRelationInput | ContentTemplateInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentTemplateInstances.
     */
    cursor?: ContentTemplateInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTemplateInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTemplateInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentTemplateInstances.
     */
    distinct?: ContentTemplateInstanceScalarFieldEnum | ContentTemplateInstanceScalarFieldEnum[]
  }

  /**
   * ContentTemplateInstance findFirstOrThrow
   */
  export type ContentTemplateInstanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTemplateInstance
     */
    select?: ContentTemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTemplateInstance
     */
    omit?: ContentTemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTemplateInstanceInclude<ExtArgs> | null
    /**
     * Filter, which ContentTemplateInstance to fetch.
     */
    where?: ContentTemplateInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTemplateInstances to fetch.
     */
    orderBy?: ContentTemplateInstanceOrderByWithRelationInput | ContentTemplateInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentTemplateInstances.
     */
    cursor?: ContentTemplateInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTemplateInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTemplateInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentTemplateInstances.
     */
    distinct?: ContentTemplateInstanceScalarFieldEnum | ContentTemplateInstanceScalarFieldEnum[]
  }

  /**
   * ContentTemplateInstance findMany
   */
  export type ContentTemplateInstanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTemplateInstance
     */
    select?: ContentTemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTemplateInstance
     */
    omit?: ContentTemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTemplateInstanceInclude<ExtArgs> | null
    /**
     * Filter, which ContentTemplateInstances to fetch.
     */
    where?: ContentTemplateInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTemplateInstances to fetch.
     */
    orderBy?: ContentTemplateInstanceOrderByWithRelationInput | ContentTemplateInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentTemplateInstances.
     */
    cursor?: ContentTemplateInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTemplateInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTemplateInstances.
     */
    skip?: number
    distinct?: ContentTemplateInstanceScalarFieldEnum | ContentTemplateInstanceScalarFieldEnum[]
  }

  /**
   * ContentTemplateInstance create
   */
  export type ContentTemplateInstanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTemplateInstance
     */
    select?: ContentTemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTemplateInstance
     */
    omit?: ContentTemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTemplateInstanceInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentTemplateInstance.
     */
    data: XOR<ContentTemplateInstanceCreateInput, ContentTemplateInstanceUncheckedCreateInput>
  }

  /**
   * ContentTemplateInstance createMany
   */
  export type ContentTemplateInstanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentTemplateInstances.
     */
    data: ContentTemplateInstanceCreateManyInput | ContentTemplateInstanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentTemplateInstance createManyAndReturn
   */
  export type ContentTemplateInstanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTemplateInstance
     */
    select?: ContentTemplateInstanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTemplateInstance
     */
    omit?: ContentTemplateInstanceOmit<ExtArgs> | null
    /**
     * The data used to create many ContentTemplateInstances.
     */
    data: ContentTemplateInstanceCreateManyInput | ContentTemplateInstanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTemplateInstanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentTemplateInstance update
   */
  export type ContentTemplateInstanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTemplateInstance
     */
    select?: ContentTemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTemplateInstance
     */
    omit?: ContentTemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTemplateInstanceInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentTemplateInstance.
     */
    data: XOR<ContentTemplateInstanceUpdateInput, ContentTemplateInstanceUncheckedUpdateInput>
    /**
     * Choose, which ContentTemplateInstance to update.
     */
    where: ContentTemplateInstanceWhereUniqueInput
  }

  /**
   * ContentTemplateInstance updateMany
   */
  export type ContentTemplateInstanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentTemplateInstances.
     */
    data: XOR<ContentTemplateInstanceUpdateManyMutationInput, ContentTemplateInstanceUncheckedUpdateManyInput>
    /**
     * Filter which ContentTemplateInstances to update
     */
    where?: ContentTemplateInstanceWhereInput
    /**
     * Limit how many ContentTemplateInstances to update.
     */
    limit?: number
  }

  /**
   * ContentTemplateInstance updateManyAndReturn
   */
  export type ContentTemplateInstanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTemplateInstance
     */
    select?: ContentTemplateInstanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTemplateInstance
     */
    omit?: ContentTemplateInstanceOmit<ExtArgs> | null
    /**
     * The data used to update ContentTemplateInstances.
     */
    data: XOR<ContentTemplateInstanceUpdateManyMutationInput, ContentTemplateInstanceUncheckedUpdateManyInput>
    /**
     * Filter which ContentTemplateInstances to update
     */
    where?: ContentTemplateInstanceWhereInput
    /**
     * Limit how many ContentTemplateInstances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTemplateInstanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentTemplateInstance upsert
   */
  export type ContentTemplateInstanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTemplateInstance
     */
    select?: ContentTemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTemplateInstance
     */
    omit?: ContentTemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTemplateInstanceInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentTemplateInstance to update in case it exists.
     */
    where: ContentTemplateInstanceWhereUniqueInput
    /**
     * In case the ContentTemplateInstance found by the `where` argument doesn't exist, create a new ContentTemplateInstance with this data.
     */
    create: XOR<ContentTemplateInstanceCreateInput, ContentTemplateInstanceUncheckedCreateInput>
    /**
     * In case the ContentTemplateInstance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentTemplateInstanceUpdateInput, ContentTemplateInstanceUncheckedUpdateInput>
  }

  /**
   * ContentTemplateInstance delete
   */
  export type ContentTemplateInstanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTemplateInstance
     */
    select?: ContentTemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTemplateInstance
     */
    omit?: ContentTemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTemplateInstanceInclude<ExtArgs> | null
    /**
     * Filter which ContentTemplateInstance to delete.
     */
    where: ContentTemplateInstanceWhereUniqueInput
  }

  /**
   * ContentTemplateInstance deleteMany
   */
  export type ContentTemplateInstanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentTemplateInstances to delete
     */
    where?: ContentTemplateInstanceWhereInput
    /**
     * Limit how many ContentTemplateInstances to delete.
     */
    limit?: number
  }

  /**
   * ContentTemplateInstance without action
   */
  export type ContentTemplateInstanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTemplateInstance
     */
    select?: ContentTemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTemplateInstance
     */
    omit?: ContentTemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTemplateInstanceInclude<ExtArgs> | null
  }


  /**
   * Model Field
   */

  export type AggregateField = {
    _count: FieldCountAggregateOutputType | null
    _avg: FieldAvgAggregateOutputType | null
    _sum: FieldSumAggregateOutputType | null
    _min: FieldMinAggregateOutputType | null
    _max: FieldMaxAggregateOutputType | null
  }

  export type FieldAvgAggregateOutputType = {
    id: number | null
    template_id: number | null
    collection_id: number | null
  }

  export type FieldSumAggregateOutputType = {
    id: number | null
    template_id: number | null
    collection_id: number | null
  }

  export type FieldMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    required: boolean | null
    created_at: Date | null
    updated_at: Date | null
    template_id: number | null
    collection_id: number | null
  }

  export type FieldMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    required: boolean | null
    created_at: Date | null
    updated_at: Date | null
    template_id: number | null
    collection_id: number | null
  }

  export type FieldCountAggregateOutputType = {
    id: number
    name: number
    type: number
    required: number
    options: number
    created_at: number
    updated_at: number
    template_id: number
    collection_id: number
    _all: number
  }


  export type FieldAvgAggregateInputType = {
    id?: true
    template_id?: true
    collection_id?: true
  }

  export type FieldSumAggregateInputType = {
    id?: true
    template_id?: true
    collection_id?: true
  }

  export type FieldMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    required?: true
    created_at?: true
    updated_at?: true
    template_id?: true
    collection_id?: true
  }

  export type FieldMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    required?: true
    created_at?: true
    updated_at?: true
    template_id?: true
    collection_id?: true
  }

  export type FieldCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    required?: true
    options?: true
    created_at?: true
    updated_at?: true
    template_id?: true
    collection_id?: true
    _all?: true
  }

  export type FieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Field to aggregate.
     */
    where?: FieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fields to fetch.
     */
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fields
    **/
    _count?: true | FieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FieldMaxAggregateInputType
  }

  export type GetFieldAggregateType<T extends FieldAggregateArgs> = {
        [P in keyof T & keyof AggregateField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateField[P]>
      : GetScalarType<T[P], AggregateField[P]>
  }




  export type FieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldWhereInput
    orderBy?: FieldOrderByWithAggregationInput | FieldOrderByWithAggregationInput[]
    by: FieldScalarFieldEnum[] | FieldScalarFieldEnum
    having?: FieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FieldCountAggregateInputType | true
    _avg?: FieldAvgAggregateInputType
    _sum?: FieldSumAggregateInputType
    _min?: FieldMinAggregateInputType
    _max?: FieldMaxAggregateInputType
  }

  export type FieldGroupByOutputType = {
    id: number
    name: string
    type: string
    required: boolean
    options: string[]
    created_at: Date
    updated_at: Date
    template_id: number | null
    collection_id: number | null
    _count: FieldCountAggregateOutputType | null
    _avg: FieldAvgAggregateOutputType | null
    _sum: FieldSumAggregateOutputType | null
    _min: FieldMinAggregateOutputType | null
    _max: FieldMaxAggregateOutputType | null
  }

  type GetFieldGroupByPayload<T extends FieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FieldGroupByOutputType[P]>
            : GetScalarType<T[P], FieldGroupByOutputType[P]>
        }
      >
    >


  export type FieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    required?: boolean
    options?: boolean
    created_at?: boolean
    updated_at?: boolean
    template_id?: boolean
    collection_id?: boolean
    Collection?: boolean | Field$CollectionArgs<ExtArgs>
    Template?: boolean | Field$TemplateArgs<ExtArgs>
  }, ExtArgs["result"]["field"]>

  export type FieldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    required?: boolean
    options?: boolean
    created_at?: boolean
    updated_at?: boolean
    template_id?: boolean
    collection_id?: boolean
    Collection?: boolean | Field$CollectionArgs<ExtArgs>
    Template?: boolean | Field$TemplateArgs<ExtArgs>
  }, ExtArgs["result"]["field"]>

  export type FieldSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    required?: boolean
    options?: boolean
    created_at?: boolean
    updated_at?: boolean
    template_id?: boolean
    collection_id?: boolean
    Collection?: boolean | Field$CollectionArgs<ExtArgs>
    Template?: boolean | Field$TemplateArgs<ExtArgs>
  }, ExtArgs["result"]["field"]>

  export type FieldSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    required?: boolean
    options?: boolean
    created_at?: boolean
    updated_at?: boolean
    template_id?: boolean
    collection_id?: boolean
  }

  export type FieldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "required" | "options" | "created_at" | "updated_at" | "template_id" | "collection_id", ExtArgs["result"]["field"]>
  export type FieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Collection?: boolean | Field$CollectionArgs<ExtArgs>
    Template?: boolean | Field$TemplateArgs<ExtArgs>
  }
  export type FieldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Collection?: boolean | Field$CollectionArgs<ExtArgs>
    Template?: boolean | Field$TemplateArgs<ExtArgs>
  }
  export type FieldIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Collection?: boolean | Field$CollectionArgs<ExtArgs>
    Template?: boolean | Field$TemplateArgs<ExtArgs>
  }

  export type $FieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Field"
    objects: {
      Collection: Prisma.$CollectionPayload<ExtArgs> | null
      Template: Prisma.$TemplatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: string
      required: boolean
      options: string[]
      created_at: Date
      updated_at: Date
      template_id: number | null
      collection_id: number | null
    }, ExtArgs["result"]["field"]>
    composites: {}
  }

  type FieldGetPayload<S extends boolean | null | undefined | FieldDefaultArgs> = $Result.GetResult<Prisma.$FieldPayload, S>

  type FieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FieldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FieldCountAggregateInputType | true
    }

  export interface FieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'Field' } }
    /**
     * Find zero or one Field that matches the filter.
     * @param {FieldFindUniqueArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FieldFindUniqueArgs>(args: SelectSubset<T, FieldFindUniqueArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Field that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FieldFindUniqueOrThrowArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FieldFindUniqueOrThrowArgs>(args: SelectSubset<T, FieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Field that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldFindFirstArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FieldFindFirstArgs>(args?: SelectSubset<T, FieldFindFirstArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Field that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldFindFirstOrThrowArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FieldFindFirstOrThrowArgs>(args?: SelectSubset<T, FieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Fields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fields
     * const fields = await prisma.field.findMany()
     * 
     * // Get first 10 Fields
     * const fields = await prisma.field.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fieldWithIdOnly = await prisma.field.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FieldFindManyArgs>(args?: SelectSubset<T, FieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Field.
     * @param {FieldCreateArgs} args - Arguments to create a Field.
     * @example
     * // Create one Field
     * const Field = await prisma.field.create({
     *   data: {
     *     // ... data to create a Field
     *   }
     * })
     * 
     */
    create<T extends FieldCreateArgs>(args: SelectSubset<T, FieldCreateArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Fields.
     * @param {FieldCreateManyArgs} args - Arguments to create many Fields.
     * @example
     * // Create many Fields
     * const field = await prisma.field.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FieldCreateManyArgs>(args?: SelectSubset<T, FieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fields and returns the data saved in the database.
     * @param {FieldCreateManyAndReturnArgs} args - Arguments to create many Fields.
     * @example
     * // Create many Fields
     * const field = await prisma.field.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fields and only return the `id`
     * const fieldWithIdOnly = await prisma.field.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FieldCreateManyAndReturnArgs>(args?: SelectSubset<T, FieldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Field.
     * @param {FieldDeleteArgs} args - Arguments to delete one Field.
     * @example
     * // Delete one Field
     * const Field = await prisma.field.delete({
     *   where: {
     *     // ... filter to delete one Field
     *   }
     * })
     * 
     */
    delete<T extends FieldDeleteArgs>(args: SelectSubset<T, FieldDeleteArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Field.
     * @param {FieldUpdateArgs} args - Arguments to update one Field.
     * @example
     * // Update one Field
     * const field = await prisma.field.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FieldUpdateArgs>(args: SelectSubset<T, FieldUpdateArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Fields.
     * @param {FieldDeleteManyArgs} args - Arguments to filter Fields to delete.
     * @example
     * // Delete a few Fields
     * const { count } = await prisma.field.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FieldDeleteManyArgs>(args?: SelectSubset<T, FieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fields
     * const field = await prisma.field.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FieldUpdateManyArgs>(args: SelectSubset<T, FieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fields and returns the data updated in the database.
     * @param {FieldUpdateManyAndReturnArgs} args - Arguments to update many Fields.
     * @example
     * // Update many Fields
     * const field = await prisma.field.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fields and only return the `id`
     * const fieldWithIdOnly = await prisma.field.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FieldUpdateManyAndReturnArgs>(args: SelectSubset<T, FieldUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Field.
     * @param {FieldUpsertArgs} args - Arguments to update or create a Field.
     * @example
     * // Update or create a Field
     * const field = await prisma.field.upsert({
     *   create: {
     *     // ... data to create a Field
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Field we want to update
     *   }
     * })
     */
    upsert<T extends FieldUpsertArgs>(args: SelectSubset<T, FieldUpsertArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldCountArgs} args - Arguments to filter Fields to count.
     * @example
     * // Count the number of Fields
     * const count = await prisma.field.count({
     *   where: {
     *     // ... the filter for the Fields we want to count
     *   }
     * })
    **/
    count<T extends FieldCountArgs>(
      args?: Subset<T, FieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Field.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FieldAggregateArgs>(args: Subset<T, FieldAggregateArgs>): Prisma.PrismaPromise<GetFieldAggregateType<T>>

    /**
     * Group by Field.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FieldGroupByArgs['orderBy'] }
        : { orderBy?: FieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Field model
   */
  readonly fields: FieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Field.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Collection<T extends Field$CollectionArgs<ExtArgs> = {}>(args?: Subset<T, Field$CollectionArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Template<T extends Field$TemplateArgs<ExtArgs> = {}>(args?: Subset<T, Field$TemplateArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Field model
   */ 
  interface FieldFieldRefs {
    readonly id: FieldRef<"Field", 'Int'>
    readonly name: FieldRef<"Field", 'String'>
    readonly type: FieldRef<"Field", 'String'>
    readonly required: FieldRef<"Field", 'Boolean'>
    readonly options: FieldRef<"Field", 'String[]'>
    readonly created_at: FieldRef<"Field", 'DateTime'>
    readonly updated_at: FieldRef<"Field", 'DateTime'>
    readonly template_id: FieldRef<"Field", 'Int'>
    readonly collection_id: FieldRef<"Field", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Field findUnique
   */
  export type FieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Field to fetch.
     */
    where: FieldWhereUniqueInput
  }

  /**
   * Field findUniqueOrThrow
   */
  export type FieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Field to fetch.
     */
    where: FieldWhereUniqueInput
  }

  /**
   * Field findFirst
   */
  export type FieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Field to fetch.
     */
    where?: FieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fields to fetch.
     */
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fields.
     */
    cursor?: FieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fields.
     */
    distinct?: FieldScalarFieldEnum | FieldScalarFieldEnum[]
  }

  /**
   * Field findFirstOrThrow
   */
  export type FieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Field to fetch.
     */
    where?: FieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fields to fetch.
     */
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fields.
     */
    cursor?: FieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fields.
     */
    distinct?: FieldScalarFieldEnum | FieldScalarFieldEnum[]
  }

  /**
   * Field findMany
   */
  export type FieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Fields to fetch.
     */
    where?: FieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fields to fetch.
     */
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fields.
     */
    cursor?: FieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fields.
     */
    skip?: number
    distinct?: FieldScalarFieldEnum | FieldScalarFieldEnum[]
  }

  /**
   * Field create
   */
  export type FieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * The data needed to create a Field.
     */
    data: XOR<FieldCreateInput, FieldUncheckedCreateInput>
  }

  /**
   * Field createMany
   */
  export type FieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fields.
     */
    data: FieldCreateManyInput | FieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Field createManyAndReturn
   */
  export type FieldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * The data used to create many Fields.
     */
    data: FieldCreateManyInput | FieldCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Field update
   */
  export type FieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * The data needed to update a Field.
     */
    data: XOR<FieldUpdateInput, FieldUncheckedUpdateInput>
    /**
     * Choose, which Field to update.
     */
    where: FieldWhereUniqueInput
  }

  /**
   * Field updateMany
   */
  export type FieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fields.
     */
    data: XOR<FieldUpdateManyMutationInput, FieldUncheckedUpdateManyInput>
    /**
     * Filter which Fields to update
     */
    where?: FieldWhereInput
    /**
     * Limit how many Fields to update.
     */
    limit?: number
  }

  /**
   * Field updateManyAndReturn
   */
  export type FieldUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * The data used to update Fields.
     */
    data: XOR<FieldUpdateManyMutationInput, FieldUncheckedUpdateManyInput>
    /**
     * Filter which Fields to update
     */
    where?: FieldWhereInput
    /**
     * Limit how many Fields to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Field upsert
   */
  export type FieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * The filter to search for the Field to update in case it exists.
     */
    where: FieldWhereUniqueInput
    /**
     * In case the Field found by the `where` argument doesn't exist, create a new Field with this data.
     */
    create: XOR<FieldCreateInput, FieldUncheckedCreateInput>
    /**
     * In case the Field was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FieldUpdateInput, FieldUncheckedUpdateInput>
  }

  /**
   * Field delete
   */
  export type FieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter which Field to delete.
     */
    where: FieldWhereUniqueInput
  }

  /**
   * Field deleteMany
   */
  export type FieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fields to delete
     */
    where?: FieldWhereInput
    /**
     * Limit how many Fields to delete.
     */
    limit?: number
  }

  /**
   * Field.Collection
   */
  export type Field$CollectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    where?: CollectionWhereInput
  }

  /**
   * Field.Template
   */
  export type Field$TemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    where?: TemplateWhereInput
  }

  /**
   * Field without action
   */
  export type FieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
  }


  /**
   * Model ImageGenerationBilling
   */

  export type AggregateImageGenerationBilling = {
    _count: ImageGenerationBillingCountAggregateOutputType | null
    _avg: ImageGenerationBillingAvgAggregateOutputType | null
    _sum: ImageGenerationBillingSumAggregateOutputType | null
    _min: ImageGenerationBillingMinAggregateOutputType | null
    _max: ImageGenerationBillingMaxAggregateOutputType | null
  }

  export type ImageGenerationBillingAvgAggregateOutputType = {
    predict_time: number | null
    cost: number | null
    price: number | null
    organization_id: number | null
  }

  export type ImageGenerationBillingSumAggregateOutputType = {
    predict_time: number | null
    cost: number | null
    price: number | null
    organization_id: number | null
  }

  export type ImageGenerationBillingMinAggregateOutputType = {
    id: string | null
    completed_at: Date | null
    started_at: Date | null
    created_at: Date | null
    predict_time: number | null
    model: string | null
    status: string | null
    cost: number | null
    price: number | null
    organization_id: number | null
  }

  export type ImageGenerationBillingMaxAggregateOutputType = {
    id: string | null
    completed_at: Date | null
    started_at: Date | null
    created_at: Date | null
    predict_time: number | null
    model: string | null
    status: string | null
    cost: number | null
    price: number | null
    organization_id: number | null
  }

  export type ImageGenerationBillingCountAggregateOutputType = {
    id: number
    completed_at: number
    started_at: number
    created_at: number
    predict_time: number
    model: number
    status: number
    cost: number
    price: number
    organization_id: number
    _all: number
  }


  export type ImageGenerationBillingAvgAggregateInputType = {
    predict_time?: true
    cost?: true
    price?: true
    organization_id?: true
  }

  export type ImageGenerationBillingSumAggregateInputType = {
    predict_time?: true
    cost?: true
    price?: true
    organization_id?: true
  }

  export type ImageGenerationBillingMinAggregateInputType = {
    id?: true
    completed_at?: true
    started_at?: true
    created_at?: true
    predict_time?: true
    model?: true
    status?: true
    cost?: true
    price?: true
    organization_id?: true
  }

  export type ImageGenerationBillingMaxAggregateInputType = {
    id?: true
    completed_at?: true
    started_at?: true
    created_at?: true
    predict_time?: true
    model?: true
    status?: true
    cost?: true
    price?: true
    organization_id?: true
  }

  export type ImageGenerationBillingCountAggregateInputType = {
    id?: true
    completed_at?: true
    started_at?: true
    created_at?: true
    predict_time?: true
    model?: true
    status?: true
    cost?: true
    price?: true
    organization_id?: true
    _all?: true
  }

  export type ImageGenerationBillingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImageGenerationBilling to aggregate.
     */
    where?: ImageGenerationBillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageGenerationBillings to fetch.
     */
    orderBy?: ImageGenerationBillingOrderByWithRelationInput | ImageGenerationBillingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageGenerationBillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageGenerationBillings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageGenerationBillings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImageGenerationBillings
    **/
    _count?: true | ImageGenerationBillingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImageGenerationBillingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImageGenerationBillingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageGenerationBillingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageGenerationBillingMaxAggregateInputType
  }

  export type GetImageGenerationBillingAggregateType<T extends ImageGenerationBillingAggregateArgs> = {
        [P in keyof T & keyof AggregateImageGenerationBilling]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImageGenerationBilling[P]>
      : GetScalarType<T[P], AggregateImageGenerationBilling[P]>
  }




  export type ImageGenerationBillingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageGenerationBillingWhereInput
    orderBy?: ImageGenerationBillingOrderByWithAggregationInput | ImageGenerationBillingOrderByWithAggregationInput[]
    by: ImageGenerationBillingScalarFieldEnum[] | ImageGenerationBillingScalarFieldEnum
    having?: ImageGenerationBillingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageGenerationBillingCountAggregateInputType | true
    _avg?: ImageGenerationBillingAvgAggregateInputType
    _sum?: ImageGenerationBillingSumAggregateInputType
    _min?: ImageGenerationBillingMinAggregateInputType
    _max?: ImageGenerationBillingMaxAggregateInputType
  }

  export type ImageGenerationBillingGroupByOutputType = {
    id: string
    completed_at: Date
    started_at: Date
    created_at: Date
    predict_time: number
    model: string
    status: string
    cost: number
    price: number
    organization_id: number
    _count: ImageGenerationBillingCountAggregateOutputType | null
    _avg: ImageGenerationBillingAvgAggregateOutputType | null
    _sum: ImageGenerationBillingSumAggregateOutputType | null
    _min: ImageGenerationBillingMinAggregateOutputType | null
    _max: ImageGenerationBillingMaxAggregateOutputType | null
  }

  type GetImageGenerationBillingGroupByPayload<T extends ImageGenerationBillingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImageGenerationBillingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageGenerationBillingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageGenerationBillingGroupByOutputType[P]>
            : GetScalarType<T[P], ImageGenerationBillingGroupByOutputType[P]>
        }
      >
    >


  export type ImageGenerationBillingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    completed_at?: boolean
    started_at?: boolean
    created_at?: boolean
    predict_time?: boolean
    model?: boolean
    status?: boolean
    cost?: boolean
    price?: boolean
    organization_id?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["imageGenerationBilling"]>

  export type ImageGenerationBillingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    completed_at?: boolean
    started_at?: boolean
    created_at?: boolean
    predict_time?: boolean
    model?: boolean
    status?: boolean
    cost?: boolean
    price?: boolean
    organization_id?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["imageGenerationBilling"]>

  export type ImageGenerationBillingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    completed_at?: boolean
    started_at?: boolean
    created_at?: boolean
    predict_time?: boolean
    model?: boolean
    status?: boolean
    cost?: boolean
    price?: boolean
    organization_id?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["imageGenerationBilling"]>

  export type ImageGenerationBillingSelectScalar = {
    id?: boolean
    completed_at?: boolean
    started_at?: boolean
    created_at?: boolean
    predict_time?: boolean
    model?: boolean
    status?: boolean
    cost?: boolean
    price?: boolean
    organization_id?: boolean
  }

  export type ImageGenerationBillingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "completed_at" | "started_at" | "created_at" | "predict_time" | "model" | "status" | "cost" | "price" | "organization_id", ExtArgs["result"]["imageGenerationBilling"]>
  export type ImageGenerationBillingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type ImageGenerationBillingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type ImageGenerationBillingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $ImageGenerationBillingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImageGenerationBilling"
    objects: {
      Organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      completed_at: Date
      started_at: Date
      created_at: Date
      predict_time: number
      model: string
      status: string
      cost: number
      price: number
      organization_id: number
    }, ExtArgs["result"]["imageGenerationBilling"]>
    composites: {}
  }

  type ImageGenerationBillingGetPayload<S extends boolean | null | undefined | ImageGenerationBillingDefaultArgs> = $Result.GetResult<Prisma.$ImageGenerationBillingPayload, S>

  type ImageGenerationBillingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImageGenerationBillingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImageGenerationBillingCountAggregateInputType | true
    }

  export interface ImageGenerationBillingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'ImageGenerationBilling' } }
    /**
     * Find zero or one ImageGenerationBilling that matches the filter.
     * @param {ImageGenerationBillingFindUniqueArgs} args - Arguments to find a ImageGenerationBilling
     * @example
     * // Get one ImageGenerationBilling
     * const imageGenerationBilling = await prisma.imageGenerationBilling.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImageGenerationBillingFindUniqueArgs>(args: SelectSubset<T, ImageGenerationBillingFindUniqueArgs<ExtArgs>>): Prisma__ImageGenerationBillingClient<$Result.GetResult<Prisma.$ImageGenerationBillingPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ImageGenerationBilling that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImageGenerationBillingFindUniqueOrThrowArgs} args - Arguments to find a ImageGenerationBilling
     * @example
     * // Get one ImageGenerationBilling
     * const imageGenerationBilling = await prisma.imageGenerationBilling.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImageGenerationBillingFindUniqueOrThrowArgs>(args: SelectSubset<T, ImageGenerationBillingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImageGenerationBillingClient<$Result.GetResult<Prisma.$ImageGenerationBillingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ImageGenerationBilling that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGenerationBillingFindFirstArgs} args - Arguments to find a ImageGenerationBilling
     * @example
     * // Get one ImageGenerationBilling
     * const imageGenerationBilling = await prisma.imageGenerationBilling.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImageGenerationBillingFindFirstArgs>(args?: SelectSubset<T, ImageGenerationBillingFindFirstArgs<ExtArgs>>): Prisma__ImageGenerationBillingClient<$Result.GetResult<Prisma.$ImageGenerationBillingPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ImageGenerationBilling that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGenerationBillingFindFirstOrThrowArgs} args - Arguments to find a ImageGenerationBilling
     * @example
     * // Get one ImageGenerationBilling
     * const imageGenerationBilling = await prisma.imageGenerationBilling.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImageGenerationBillingFindFirstOrThrowArgs>(args?: SelectSubset<T, ImageGenerationBillingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImageGenerationBillingClient<$Result.GetResult<Prisma.$ImageGenerationBillingPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ImageGenerationBillings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGenerationBillingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImageGenerationBillings
     * const imageGenerationBillings = await prisma.imageGenerationBilling.findMany()
     * 
     * // Get first 10 ImageGenerationBillings
     * const imageGenerationBillings = await prisma.imageGenerationBilling.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageGenerationBillingWithIdOnly = await prisma.imageGenerationBilling.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImageGenerationBillingFindManyArgs>(args?: SelectSubset<T, ImageGenerationBillingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImageGenerationBillingPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ImageGenerationBilling.
     * @param {ImageGenerationBillingCreateArgs} args - Arguments to create a ImageGenerationBilling.
     * @example
     * // Create one ImageGenerationBilling
     * const ImageGenerationBilling = await prisma.imageGenerationBilling.create({
     *   data: {
     *     // ... data to create a ImageGenerationBilling
     *   }
     * })
     * 
     */
    create<T extends ImageGenerationBillingCreateArgs>(args: SelectSubset<T, ImageGenerationBillingCreateArgs<ExtArgs>>): Prisma__ImageGenerationBillingClient<$Result.GetResult<Prisma.$ImageGenerationBillingPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ImageGenerationBillings.
     * @param {ImageGenerationBillingCreateManyArgs} args - Arguments to create many ImageGenerationBillings.
     * @example
     * // Create many ImageGenerationBillings
     * const imageGenerationBilling = await prisma.imageGenerationBilling.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImageGenerationBillingCreateManyArgs>(args?: SelectSubset<T, ImageGenerationBillingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImageGenerationBillings and returns the data saved in the database.
     * @param {ImageGenerationBillingCreateManyAndReturnArgs} args - Arguments to create many ImageGenerationBillings.
     * @example
     * // Create many ImageGenerationBillings
     * const imageGenerationBilling = await prisma.imageGenerationBilling.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImageGenerationBillings and only return the `id`
     * const imageGenerationBillingWithIdOnly = await prisma.imageGenerationBilling.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImageGenerationBillingCreateManyAndReturnArgs>(args?: SelectSubset<T, ImageGenerationBillingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImageGenerationBillingPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ImageGenerationBilling.
     * @param {ImageGenerationBillingDeleteArgs} args - Arguments to delete one ImageGenerationBilling.
     * @example
     * // Delete one ImageGenerationBilling
     * const ImageGenerationBilling = await prisma.imageGenerationBilling.delete({
     *   where: {
     *     // ... filter to delete one ImageGenerationBilling
     *   }
     * })
     * 
     */
    delete<T extends ImageGenerationBillingDeleteArgs>(args: SelectSubset<T, ImageGenerationBillingDeleteArgs<ExtArgs>>): Prisma__ImageGenerationBillingClient<$Result.GetResult<Prisma.$ImageGenerationBillingPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ImageGenerationBilling.
     * @param {ImageGenerationBillingUpdateArgs} args - Arguments to update one ImageGenerationBilling.
     * @example
     * // Update one ImageGenerationBilling
     * const imageGenerationBilling = await prisma.imageGenerationBilling.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImageGenerationBillingUpdateArgs>(args: SelectSubset<T, ImageGenerationBillingUpdateArgs<ExtArgs>>): Prisma__ImageGenerationBillingClient<$Result.GetResult<Prisma.$ImageGenerationBillingPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ImageGenerationBillings.
     * @param {ImageGenerationBillingDeleteManyArgs} args - Arguments to filter ImageGenerationBillings to delete.
     * @example
     * // Delete a few ImageGenerationBillings
     * const { count } = await prisma.imageGenerationBilling.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImageGenerationBillingDeleteManyArgs>(args?: SelectSubset<T, ImageGenerationBillingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImageGenerationBillings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGenerationBillingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImageGenerationBillings
     * const imageGenerationBilling = await prisma.imageGenerationBilling.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImageGenerationBillingUpdateManyArgs>(args: SelectSubset<T, ImageGenerationBillingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImageGenerationBillings and returns the data updated in the database.
     * @param {ImageGenerationBillingUpdateManyAndReturnArgs} args - Arguments to update many ImageGenerationBillings.
     * @example
     * // Update many ImageGenerationBillings
     * const imageGenerationBilling = await prisma.imageGenerationBilling.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ImageGenerationBillings and only return the `id`
     * const imageGenerationBillingWithIdOnly = await prisma.imageGenerationBilling.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImageGenerationBillingUpdateManyAndReturnArgs>(args: SelectSubset<T, ImageGenerationBillingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImageGenerationBillingPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ImageGenerationBilling.
     * @param {ImageGenerationBillingUpsertArgs} args - Arguments to update or create a ImageGenerationBilling.
     * @example
     * // Update or create a ImageGenerationBilling
     * const imageGenerationBilling = await prisma.imageGenerationBilling.upsert({
     *   create: {
     *     // ... data to create a ImageGenerationBilling
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImageGenerationBilling we want to update
     *   }
     * })
     */
    upsert<T extends ImageGenerationBillingUpsertArgs>(args: SelectSubset<T, ImageGenerationBillingUpsertArgs<ExtArgs>>): Prisma__ImageGenerationBillingClient<$Result.GetResult<Prisma.$ImageGenerationBillingPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ImageGenerationBillings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGenerationBillingCountArgs} args - Arguments to filter ImageGenerationBillings to count.
     * @example
     * // Count the number of ImageGenerationBillings
     * const count = await prisma.imageGenerationBilling.count({
     *   where: {
     *     // ... the filter for the ImageGenerationBillings we want to count
     *   }
     * })
    **/
    count<T extends ImageGenerationBillingCountArgs>(
      args?: Subset<T, ImageGenerationBillingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageGenerationBillingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImageGenerationBilling.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGenerationBillingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageGenerationBillingAggregateArgs>(args: Subset<T, ImageGenerationBillingAggregateArgs>): Prisma.PrismaPromise<GetImageGenerationBillingAggregateType<T>>

    /**
     * Group by ImageGenerationBilling.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGenerationBillingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageGenerationBillingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageGenerationBillingGroupByArgs['orderBy'] }
        : { orderBy?: ImageGenerationBillingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageGenerationBillingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageGenerationBillingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImageGenerationBilling model
   */
  readonly fields: ImageGenerationBillingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImageGenerationBilling.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImageGenerationBillingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImageGenerationBilling model
   */ 
  interface ImageGenerationBillingFieldRefs {
    readonly id: FieldRef<"ImageGenerationBilling", 'String'>
    readonly completed_at: FieldRef<"ImageGenerationBilling", 'DateTime'>
    readonly started_at: FieldRef<"ImageGenerationBilling", 'DateTime'>
    readonly created_at: FieldRef<"ImageGenerationBilling", 'DateTime'>
    readonly predict_time: FieldRef<"ImageGenerationBilling", 'Float'>
    readonly model: FieldRef<"ImageGenerationBilling", 'String'>
    readonly status: FieldRef<"ImageGenerationBilling", 'String'>
    readonly cost: FieldRef<"ImageGenerationBilling", 'Float'>
    readonly price: FieldRef<"ImageGenerationBilling", 'Float'>
    readonly organization_id: FieldRef<"ImageGenerationBilling", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ImageGenerationBilling findUnique
   */
  export type ImageGenerationBillingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageGenerationBilling
     */
    select?: ImageGenerationBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageGenerationBilling
     */
    omit?: ImageGenerationBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageGenerationBillingInclude<ExtArgs> | null
    /**
     * Filter, which ImageGenerationBilling to fetch.
     */
    where: ImageGenerationBillingWhereUniqueInput
  }

  /**
   * ImageGenerationBilling findUniqueOrThrow
   */
  export type ImageGenerationBillingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageGenerationBilling
     */
    select?: ImageGenerationBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageGenerationBilling
     */
    omit?: ImageGenerationBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageGenerationBillingInclude<ExtArgs> | null
    /**
     * Filter, which ImageGenerationBilling to fetch.
     */
    where: ImageGenerationBillingWhereUniqueInput
  }

  /**
   * ImageGenerationBilling findFirst
   */
  export type ImageGenerationBillingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageGenerationBilling
     */
    select?: ImageGenerationBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageGenerationBilling
     */
    omit?: ImageGenerationBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageGenerationBillingInclude<ExtArgs> | null
    /**
     * Filter, which ImageGenerationBilling to fetch.
     */
    where?: ImageGenerationBillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageGenerationBillings to fetch.
     */
    orderBy?: ImageGenerationBillingOrderByWithRelationInput | ImageGenerationBillingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImageGenerationBillings.
     */
    cursor?: ImageGenerationBillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageGenerationBillings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageGenerationBillings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImageGenerationBillings.
     */
    distinct?: ImageGenerationBillingScalarFieldEnum | ImageGenerationBillingScalarFieldEnum[]
  }

  /**
   * ImageGenerationBilling findFirstOrThrow
   */
  export type ImageGenerationBillingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageGenerationBilling
     */
    select?: ImageGenerationBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageGenerationBilling
     */
    omit?: ImageGenerationBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageGenerationBillingInclude<ExtArgs> | null
    /**
     * Filter, which ImageGenerationBilling to fetch.
     */
    where?: ImageGenerationBillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageGenerationBillings to fetch.
     */
    orderBy?: ImageGenerationBillingOrderByWithRelationInput | ImageGenerationBillingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImageGenerationBillings.
     */
    cursor?: ImageGenerationBillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageGenerationBillings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageGenerationBillings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImageGenerationBillings.
     */
    distinct?: ImageGenerationBillingScalarFieldEnum | ImageGenerationBillingScalarFieldEnum[]
  }

  /**
   * ImageGenerationBilling findMany
   */
  export type ImageGenerationBillingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageGenerationBilling
     */
    select?: ImageGenerationBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageGenerationBilling
     */
    omit?: ImageGenerationBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageGenerationBillingInclude<ExtArgs> | null
    /**
     * Filter, which ImageGenerationBillings to fetch.
     */
    where?: ImageGenerationBillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageGenerationBillings to fetch.
     */
    orderBy?: ImageGenerationBillingOrderByWithRelationInput | ImageGenerationBillingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImageGenerationBillings.
     */
    cursor?: ImageGenerationBillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageGenerationBillings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageGenerationBillings.
     */
    skip?: number
    distinct?: ImageGenerationBillingScalarFieldEnum | ImageGenerationBillingScalarFieldEnum[]
  }

  /**
   * ImageGenerationBilling create
   */
  export type ImageGenerationBillingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageGenerationBilling
     */
    select?: ImageGenerationBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageGenerationBilling
     */
    omit?: ImageGenerationBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageGenerationBillingInclude<ExtArgs> | null
    /**
     * The data needed to create a ImageGenerationBilling.
     */
    data: XOR<ImageGenerationBillingCreateInput, ImageGenerationBillingUncheckedCreateInput>
  }

  /**
   * ImageGenerationBilling createMany
   */
  export type ImageGenerationBillingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImageGenerationBillings.
     */
    data: ImageGenerationBillingCreateManyInput | ImageGenerationBillingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImageGenerationBilling createManyAndReturn
   */
  export type ImageGenerationBillingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageGenerationBilling
     */
    select?: ImageGenerationBillingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImageGenerationBilling
     */
    omit?: ImageGenerationBillingOmit<ExtArgs> | null
    /**
     * The data used to create many ImageGenerationBillings.
     */
    data: ImageGenerationBillingCreateManyInput | ImageGenerationBillingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageGenerationBillingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImageGenerationBilling update
   */
  export type ImageGenerationBillingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageGenerationBilling
     */
    select?: ImageGenerationBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageGenerationBilling
     */
    omit?: ImageGenerationBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageGenerationBillingInclude<ExtArgs> | null
    /**
     * The data needed to update a ImageGenerationBilling.
     */
    data: XOR<ImageGenerationBillingUpdateInput, ImageGenerationBillingUncheckedUpdateInput>
    /**
     * Choose, which ImageGenerationBilling to update.
     */
    where: ImageGenerationBillingWhereUniqueInput
  }

  /**
   * ImageGenerationBilling updateMany
   */
  export type ImageGenerationBillingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImageGenerationBillings.
     */
    data: XOR<ImageGenerationBillingUpdateManyMutationInput, ImageGenerationBillingUncheckedUpdateManyInput>
    /**
     * Filter which ImageGenerationBillings to update
     */
    where?: ImageGenerationBillingWhereInput
    /**
     * Limit how many ImageGenerationBillings to update.
     */
    limit?: number
  }

  /**
   * ImageGenerationBilling updateManyAndReturn
   */
  export type ImageGenerationBillingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageGenerationBilling
     */
    select?: ImageGenerationBillingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImageGenerationBilling
     */
    omit?: ImageGenerationBillingOmit<ExtArgs> | null
    /**
     * The data used to update ImageGenerationBillings.
     */
    data: XOR<ImageGenerationBillingUpdateManyMutationInput, ImageGenerationBillingUncheckedUpdateManyInput>
    /**
     * Filter which ImageGenerationBillings to update
     */
    where?: ImageGenerationBillingWhereInput
    /**
     * Limit how many ImageGenerationBillings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageGenerationBillingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImageGenerationBilling upsert
   */
  export type ImageGenerationBillingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageGenerationBilling
     */
    select?: ImageGenerationBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageGenerationBilling
     */
    omit?: ImageGenerationBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageGenerationBillingInclude<ExtArgs> | null
    /**
     * The filter to search for the ImageGenerationBilling to update in case it exists.
     */
    where: ImageGenerationBillingWhereUniqueInput
    /**
     * In case the ImageGenerationBilling found by the `where` argument doesn't exist, create a new ImageGenerationBilling with this data.
     */
    create: XOR<ImageGenerationBillingCreateInput, ImageGenerationBillingUncheckedCreateInput>
    /**
     * In case the ImageGenerationBilling was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageGenerationBillingUpdateInput, ImageGenerationBillingUncheckedUpdateInput>
  }

  /**
   * ImageGenerationBilling delete
   */
  export type ImageGenerationBillingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageGenerationBilling
     */
    select?: ImageGenerationBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageGenerationBilling
     */
    omit?: ImageGenerationBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageGenerationBillingInclude<ExtArgs> | null
    /**
     * Filter which ImageGenerationBilling to delete.
     */
    where: ImageGenerationBillingWhereUniqueInput
  }

  /**
   * ImageGenerationBilling deleteMany
   */
  export type ImageGenerationBillingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImageGenerationBillings to delete
     */
    where?: ImageGenerationBillingWhereInput
    /**
     * Limit how many ImageGenerationBillings to delete.
     */
    limit?: number
  }

  /**
   * ImageGenerationBilling without action
   */
  export type ImageGenerationBillingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageGenerationBilling
     */
    select?: ImageGenerationBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageGenerationBilling
     */
    omit?: ImageGenerationBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageGenerationBillingInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    organization_id: number | null
    amount_paid: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    organization_id: number | null
    amount_paid: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    organization_id: number | null
    amount_paid: number | null
    currency: string | null
    paid_at: Date | null
    pdf: string | null
    url: string | null
    id: string | null
  }

  export type InvoiceMaxAggregateOutputType = {
    organization_id: number | null
    amount_paid: number | null
    currency: string | null
    paid_at: Date | null
    pdf: string | null
    url: string | null
    id: string | null
  }

  export type InvoiceCountAggregateOutputType = {
    organization_id: number
    amount_paid: number
    currency: number
    paid_at: number
    pdf: number
    url: number
    id: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    organization_id?: true
    amount_paid?: true
  }

  export type InvoiceSumAggregateInputType = {
    organization_id?: true
    amount_paid?: true
  }

  export type InvoiceMinAggregateInputType = {
    organization_id?: true
    amount_paid?: true
    currency?: true
    paid_at?: true
    pdf?: true
    url?: true
    id?: true
  }

  export type InvoiceMaxAggregateInputType = {
    organization_id?: true
    amount_paid?: true
    currency?: true
    paid_at?: true
    pdf?: true
    url?: true
    id?: true
  }

  export type InvoiceCountAggregateInputType = {
    organization_id?: true
    amount_paid?: true
    currency?: true
    paid_at?: true
    pdf?: true
    url?: true
    id?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    organization_id: number
    amount_paid: number
    currency: string
    paid_at: Date
    pdf: string
    url: string
    id: string
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    organization_id?: boolean
    amount_paid?: boolean
    currency?: boolean
    paid_at?: boolean
    pdf?: boolean
    url?: boolean
    id?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    organization_id?: boolean
    amount_paid?: boolean
    currency?: boolean
    paid_at?: boolean
    pdf?: boolean
    url?: boolean
    id?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    organization_id?: boolean
    amount_paid?: boolean
    currency?: boolean
    paid_at?: boolean
    pdf?: boolean
    url?: boolean
    id?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    organization_id?: boolean
    amount_paid?: boolean
    currency?: boolean
    paid_at?: boolean
    pdf?: boolean
    url?: boolean
    id?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"organization_id" | "amount_paid" | "currency" | "paid_at" | "pdf" | "url" | "id", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      Organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      organization_id: number
      amount_paid: number
      currency: string
      paid_at: Date
      pdf: string
      url: string
      id: string
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `organization_id`
     * const invoiceWithOrganization_idOnly = await prisma.invoice.findMany({ select: { organization_id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `organization_id`
     * const invoiceWithOrganization_idOnly = await prisma.invoice.createManyAndReturn({
     *   select: { organization_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `organization_id`
     * const invoiceWithOrganization_idOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { organization_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly organization_id: FieldRef<"Invoice", 'Int'>
    readonly amount_paid: FieldRef<"Invoice", 'Int'>
    readonly currency: FieldRef<"Invoice", 'String'>
    readonly paid_at: FieldRef<"Invoice", 'DateTime'>
    readonly pdf: FieldRef<"Invoice", 'String'>
    readonly url: FieldRef<"Invoice", 'String'>
    readonly id: FieldRef<"Invoice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model LinkPage
   */

  export type AggregateLinkPage = {
    _count: LinkPageCountAggregateOutputType | null
    _avg: LinkPageAvgAggregateOutputType | null
    _sum: LinkPageSumAggregateOutputType | null
    _min: LinkPageMinAggregateOutputType | null
    _max: LinkPageMaxAggregateOutputType | null
  }

  export type LinkPageAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
    media_id: number | null
  }

  export type LinkPageSumAggregateOutputType = {
    id: number | null
    organization_id: number | null
    media_id: number | null
  }

  export type LinkPageMinAggregateOutputType = {
    id: number | null
    organization_id: number | null
    created_at: Date | null
    updated_at: Date | null
    description: string | null
    media_id: number | null
    title: string | null
  }

  export type LinkPageMaxAggregateOutputType = {
    id: number | null
    organization_id: number | null
    created_at: Date | null
    updated_at: Date | null
    description: string | null
    media_id: number | null
    title: string | null
  }

  export type LinkPageCountAggregateOutputType = {
    id: number
    organization_id: number
    created_at: number
    updated_at: number
    description: number
    media_id: number
    title: number
    links: number
    _all: number
  }


  export type LinkPageAvgAggregateInputType = {
    id?: true
    organization_id?: true
    media_id?: true
  }

  export type LinkPageSumAggregateInputType = {
    id?: true
    organization_id?: true
    media_id?: true
  }

  export type LinkPageMinAggregateInputType = {
    id?: true
    organization_id?: true
    created_at?: true
    updated_at?: true
    description?: true
    media_id?: true
    title?: true
  }

  export type LinkPageMaxAggregateInputType = {
    id?: true
    organization_id?: true
    created_at?: true
    updated_at?: true
    description?: true
    media_id?: true
    title?: true
  }

  export type LinkPageCountAggregateInputType = {
    id?: true
    organization_id?: true
    created_at?: true
    updated_at?: true
    description?: true
    media_id?: true
    title?: true
    links?: true
    _all?: true
  }

  export type LinkPageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinkPage to aggregate.
     */
    where?: LinkPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkPages to fetch.
     */
    orderBy?: LinkPageOrderByWithRelationInput | LinkPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LinkPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LinkPages
    **/
    _count?: true | LinkPageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LinkPageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LinkPageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LinkPageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LinkPageMaxAggregateInputType
  }

  export type GetLinkPageAggregateType<T extends LinkPageAggregateArgs> = {
        [P in keyof T & keyof AggregateLinkPage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLinkPage[P]>
      : GetScalarType<T[P], AggregateLinkPage[P]>
  }




  export type LinkPageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkPageWhereInput
    orderBy?: LinkPageOrderByWithAggregationInput | LinkPageOrderByWithAggregationInput[]
    by: LinkPageScalarFieldEnum[] | LinkPageScalarFieldEnum
    having?: LinkPageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LinkPageCountAggregateInputType | true
    _avg?: LinkPageAvgAggregateInputType
    _sum?: LinkPageSumAggregateInputType
    _min?: LinkPageMinAggregateInputType
    _max?: LinkPageMaxAggregateInputType
  }

  export type LinkPageGroupByOutputType = {
    id: number
    organization_id: number
    created_at: Date
    updated_at: Date
    description: string | null
    media_id: number | null
    title: string | null
    links: JsonValue[]
    _count: LinkPageCountAggregateOutputType | null
    _avg: LinkPageAvgAggregateOutputType | null
    _sum: LinkPageSumAggregateOutputType | null
    _min: LinkPageMinAggregateOutputType | null
    _max: LinkPageMaxAggregateOutputType | null
  }

  type GetLinkPageGroupByPayload<T extends LinkPageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LinkPageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LinkPageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LinkPageGroupByOutputType[P]>
            : GetScalarType<T[P], LinkPageGroupByOutputType[P]>
        }
      >
    >


  export type LinkPageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    description?: boolean
    media_id?: boolean
    title?: boolean
    links?: boolean
    Media?: boolean | LinkPage$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkPage"]>

  export type LinkPageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    description?: boolean
    media_id?: boolean
    title?: boolean
    links?: boolean
    Media?: boolean | LinkPage$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkPage"]>

  export type LinkPageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    description?: boolean
    media_id?: boolean
    title?: boolean
    links?: boolean
    Media?: boolean | LinkPage$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkPage"]>

  export type LinkPageSelectScalar = {
    id?: boolean
    organization_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    description?: boolean
    media_id?: boolean
    title?: boolean
    links?: boolean
  }

  export type LinkPageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organization_id" | "created_at" | "updated_at" | "description" | "media_id" | "title" | "links", ExtArgs["result"]["linkPage"]>
  export type LinkPageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Media?: boolean | LinkPage$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type LinkPageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Media?: boolean | LinkPage$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type LinkPageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Media?: boolean | LinkPage$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $LinkPagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LinkPage"
    objects: {
      Media: Prisma.$MediaPayload<ExtArgs> | null
      Organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      organization_id: number
      created_at: Date
      updated_at: Date
      description: string | null
      media_id: number | null
      title: string | null
      links: Prisma.JsonValue[]
    }, ExtArgs["result"]["linkPage"]>
    composites: {}
  }

  type LinkPageGetPayload<S extends boolean | null | undefined | LinkPageDefaultArgs> = $Result.GetResult<Prisma.$LinkPagePayload, S>

  type LinkPageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LinkPageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LinkPageCountAggregateInputType | true
    }

  export interface LinkPageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'LinkPage' } }
    /**
     * Find zero or one LinkPage that matches the filter.
     * @param {LinkPageFindUniqueArgs} args - Arguments to find a LinkPage
     * @example
     * // Get one LinkPage
     * const linkPage = await prisma.linkPage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LinkPageFindUniqueArgs>(args: SelectSubset<T, LinkPageFindUniqueArgs<ExtArgs>>): Prisma__LinkPageClient<$Result.GetResult<Prisma.$LinkPagePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LinkPage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LinkPageFindUniqueOrThrowArgs} args - Arguments to find a LinkPage
     * @example
     * // Get one LinkPage
     * const linkPage = await prisma.linkPage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LinkPageFindUniqueOrThrowArgs>(args: SelectSubset<T, LinkPageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LinkPageClient<$Result.GetResult<Prisma.$LinkPagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LinkPage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkPageFindFirstArgs} args - Arguments to find a LinkPage
     * @example
     * // Get one LinkPage
     * const linkPage = await prisma.linkPage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LinkPageFindFirstArgs>(args?: SelectSubset<T, LinkPageFindFirstArgs<ExtArgs>>): Prisma__LinkPageClient<$Result.GetResult<Prisma.$LinkPagePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LinkPage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkPageFindFirstOrThrowArgs} args - Arguments to find a LinkPage
     * @example
     * // Get one LinkPage
     * const linkPage = await prisma.linkPage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LinkPageFindFirstOrThrowArgs>(args?: SelectSubset<T, LinkPageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LinkPageClient<$Result.GetResult<Prisma.$LinkPagePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LinkPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkPageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LinkPages
     * const linkPages = await prisma.linkPage.findMany()
     * 
     * // Get first 10 LinkPages
     * const linkPages = await prisma.linkPage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const linkPageWithIdOnly = await prisma.linkPage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LinkPageFindManyArgs>(args?: SelectSubset<T, LinkPageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkPagePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LinkPage.
     * @param {LinkPageCreateArgs} args - Arguments to create a LinkPage.
     * @example
     * // Create one LinkPage
     * const LinkPage = await prisma.linkPage.create({
     *   data: {
     *     // ... data to create a LinkPage
     *   }
     * })
     * 
     */
    create<T extends LinkPageCreateArgs>(args: SelectSubset<T, LinkPageCreateArgs<ExtArgs>>): Prisma__LinkPageClient<$Result.GetResult<Prisma.$LinkPagePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LinkPages.
     * @param {LinkPageCreateManyArgs} args - Arguments to create many LinkPages.
     * @example
     * // Create many LinkPages
     * const linkPage = await prisma.linkPage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LinkPageCreateManyArgs>(args?: SelectSubset<T, LinkPageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LinkPages and returns the data saved in the database.
     * @param {LinkPageCreateManyAndReturnArgs} args - Arguments to create many LinkPages.
     * @example
     * // Create many LinkPages
     * const linkPage = await prisma.linkPage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LinkPages and only return the `id`
     * const linkPageWithIdOnly = await prisma.linkPage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LinkPageCreateManyAndReturnArgs>(args?: SelectSubset<T, LinkPageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkPagePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LinkPage.
     * @param {LinkPageDeleteArgs} args - Arguments to delete one LinkPage.
     * @example
     * // Delete one LinkPage
     * const LinkPage = await prisma.linkPage.delete({
     *   where: {
     *     // ... filter to delete one LinkPage
     *   }
     * })
     * 
     */
    delete<T extends LinkPageDeleteArgs>(args: SelectSubset<T, LinkPageDeleteArgs<ExtArgs>>): Prisma__LinkPageClient<$Result.GetResult<Prisma.$LinkPagePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LinkPage.
     * @param {LinkPageUpdateArgs} args - Arguments to update one LinkPage.
     * @example
     * // Update one LinkPage
     * const linkPage = await prisma.linkPage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LinkPageUpdateArgs>(args: SelectSubset<T, LinkPageUpdateArgs<ExtArgs>>): Prisma__LinkPageClient<$Result.GetResult<Prisma.$LinkPagePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LinkPages.
     * @param {LinkPageDeleteManyArgs} args - Arguments to filter LinkPages to delete.
     * @example
     * // Delete a few LinkPages
     * const { count } = await prisma.linkPage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LinkPageDeleteManyArgs>(args?: SelectSubset<T, LinkPageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LinkPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkPageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LinkPages
     * const linkPage = await prisma.linkPage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LinkPageUpdateManyArgs>(args: SelectSubset<T, LinkPageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LinkPages and returns the data updated in the database.
     * @param {LinkPageUpdateManyAndReturnArgs} args - Arguments to update many LinkPages.
     * @example
     * // Update many LinkPages
     * const linkPage = await prisma.linkPage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LinkPages and only return the `id`
     * const linkPageWithIdOnly = await prisma.linkPage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LinkPageUpdateManyAndReturnArgs>(args: SelectSubset<T, LinkPageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkPagePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LinkPage.
     * @param {LinkPageUpsertArgs} args - Arguments to update or create a LinkPage.
     * @example
     * // Update or create a LinkPage
     * const linkPage = await prisma.linkPage.upsert({
     *   create: {
     *     // ... data to create a LinkPage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LinkPage we want to update
     *   }
     * })
     */
    upsert<T extends LinkPageUpsertArgs>(args: SelectSubset<T, LinkPageUpsertArgs<ExtArgs>>): Prisma__LinkPageClient<$Result.GetResult<Prisma.$LinkPagePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LinkPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkPageCountArgs} args - Arguments to filter LinkPages to count.
     * @example
     * // Count the number of LinkPages
     * const count = await prisma.linkPage.count({
     *   where: {
     *     // ... the filter for the LinkPages we want to count
     *   }
     * })
    **/
    count<T extends LinkPageCountArgs>(
      args?: Subset<T, LinkPageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LinkPageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LinkPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkPageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LinkPageAggregateArgs>(args: Subset<T, LinkPageAggregateArgs>): Prisma.PrismaPromise<GetLinkPageAggregateType<T>>

    /**
     * Group by LinkPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkPageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LinkPageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LinkPageGroupByArgs['orderBy'] }
        : { orderBy?: LinkPageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LinkPageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLinkPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LinkPage model
   */
  readonly fields: LinkPageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LinkPage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LinkPageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Media<T extends LinkPage$MediaArgs<ExtArgs> = {}>(args?: Subset<T, LinkPage$MediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LinkPage model
   */ 
  interface LinkPageFieldRefs {
    readonly id: FieldRef<"LinkPage", 'Int'>
    readonly organization_id: FieldRef<"LinkPage", 'Int'>
    readonly created_at: FieldRef<"LinkPage", 'DateTime'>
    readonly updated_at: FieldRef<"LinkPage", 'DateTime'>
    readonly description: FieldRef<"LinkPage", 'String'>
    readonly media_id: FieldRef<"LinkPage", 'Int'>
    readonly title: FieldRef<"LinkPage", 'String'>
    readonly links: FieldRef<"LinkPage", 'Json[]'>
  }
    

  // Custom InputTypes
  /**
   * LinkPage findUnique
   */
  export type LinkPageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkPage
     */
    select?: LinkPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkPage
     */
    omit?: LinkPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkPageInclude<ExtArgs> | null
    /**
     * Filter, which LinkPage to fetch.
     */
    where: LinkPageWhereUniqueInput
  }

  /**
   * LinkPage findUniqueOrThrow
   */
  export type LinkPageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkPage
     */
    select?: LinkPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkPage
     */
    omit?: LinkPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkPageInclude<ExtArgs> | null
    /**
     * Filter, which LinkPage to fetch.
     */
    where: LinkPageWhereUniqueInput
  }

  /**
   * LinkPage findFirst
   */
  export type LinkPageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkPage
     */
    select?: LinkPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkPage
     */
    omit?: LinkPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkPageInclude<ExtArgs> | null
    /**
     * Filter, which LinkPage to fetch.
     */
    where?: LinkPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkPages to fetch.
     */
    orderBy?: LinkPageOrderByWithRelationInput | LinkPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinkPages.
     */
    cursor?: LinkPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinkPages.
     */
    distinct?: LinkPageScalarFieldEnum | LinkPageScalarFieldEnum[]
  }

  /**
   * LinkPage findFirstOrThrow
   */
  export type LinkPageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkPage
     */
    select?: LinkPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkPage
     */
    omit?: LinkPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkPageInclude<ExtArgs> | null
    /**
     * Filter, which LinkPage to fetch.
     */
    where?: LinkPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkPages to fetch.
     */
    orderBy?: LinkPageOrderByWithRelationInput | LinkPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinkPages.
     */
    cursor?: LinkPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinkPages.
     */
    distinct?: LinkPageScalarFieldEnum | LinkPageScalarFieldEnum[]
  }

  /**
   * LinkPage findMany
   */
  export type LinkPageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkPage
     */
    select?: LinkPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkPage
     */
    omit?: LinkPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkPageInclude<ExtArgs> | null
    /**
     * Filter, which LinkPages to fetch.
     */
    where?: LinkPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkPages to fetch.
     */
    orderBy?: LinkPageOrderByWithRelationInput | LinkPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LinkPages.
     */
    cursor?: LinkPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkPages.
     */
    skip?: number
    distinct?: LinkPageScalarFieldEnum | LinkPageScalarFieldEnum[]
  }

  /**
   * LinkPage create
   */
  export type LinkPageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkPage
     */
    select?: LinkPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkPage
     */
    omit?: LinkPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkPageInclude<ExtArgs> | null
    /**
     * The data needed to create a LinkPage.
     */
    data: XOR<LinkPageCreateInput, LinkPageUncheckedCreateInput>
  }

  /**
   * LinkPage createMany
   */
  export type LinkPageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LinkPages.
     */
    data: LinkPageCreateManyInput | LinkPageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LinkPage createManyAndReturn
   */
  export type LinkPageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkPage
     */
    select?: LinkPageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LinkPage
     */
    omit?: LinkPageOmit<ExtArgs> | null
    /**
     * The data used to create many LinkPages.
     */
    data: LinkPageCreateManyInput | LinkPageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkPageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LinkPage update
   */
  export type LinkPageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkPage
     */
    select?: LinkPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkPage
     */
    omit?: LinkPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkPageInclude<ExtArgs> | null
    /**
     * The data needed to update a LinkPage.
     */
    data: XOR<LinkPageUpdateInput, LinkPageUncheckedUpdateInput>
    /**
     * Choose, which LinkPage to update.
     */
    where: LinkPageWhereUniqueInput
  }

  /**
   * LinkPage updateMany
   */
  export type LinkPageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LinkPages.
     */
    data: XOR<LinkPageUpdateManyMutationInput, LinkPageUncheckedUpdateManyInput>
    /**
     * Filter which LinkPages to update
     */
    where?: LinkPageWhereInput
    /**
     * Limit how many LinkPages to update.
     */
    limit?: number
  }

  /**
   * LinkPage updateManyAndReturn
   */
  export type LinkPageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkPage
     */
    select?: LinkPageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LinkPage
     */
    omit?: LinkPageOmit<ExtArgs> | null
    /**
     * The data used to update LinkPages.
     */
    data: XOR<LinkPageUpdateManyMutationInput, LinkPageUncheckedUpdateManyInput>
    /**
     * Filter which LinkPages to update
     */
    where?: LinkPageWhereInput
    /**
     * Limit how many LinkPages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkPageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LinkPage upsert
   */
  export type LinkPageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkPage
     */
    select?: LinkPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkPage
     */
    omit?: LinkPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkPageInclude<ExtArgs> | null
    /**
     * The filter to search for the LinkPage to update in case it exists.
     */
    where: LinkPageWhereUniqueInput
    /**
     * In case the LinkPage found by the `where` argument doesn't exist, create a new LinkPage with this data.
     */
    create: XOR<LinkPageCreateInput, LinkPageUncheckedCreateInput>
    /**
     * In case the LinkPage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LinkPageUpdateInput, LinkPageUncheckedUpdateInput>
  }

  /**
   * LinkPage delete
   */
  export type LinkPageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkPage
     */
    select?: LinkPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkPage
     */
    omit?: LinkPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkPageInclude<ExtArgs> | null
    /**
     * Filter which LinkPage to delete.
     */
    where: LinkPageWhereUniqueInput
  }

  /**
   * LinkPage deleteMany
   */
  export type LinkPageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinkPages to delete
     */
    where?: LinkPageWhereInput
    /**
     * Limit how many LinkPages to delete.
     */
    limit?: number
  }

  /**
   * LinkPage.Media
   */
  export type LinkPage$MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * LinkPage without action
   */
  export type LinkPageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkPage
     */
    select?: LinkPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkPage
     */
    omit?: LinkPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkPageInclude<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
  }

  export type MediaSumAggregateOutputType = {
    id: number | null
    organization_id: number | null
  }

  export type MediaMinAggregateOutputType = {
    id: number | null
    url: string | null
    alt_text: string | null
    name: string | null
    created_at: Date | null
    organization_id: number | null
    updated_at: Date | null
  }

  export type MediaMaxAggregateOutputType = {
    id: number | null
    url: string | null
    alt_text: string | null
    name: string | null
    created_at: Date | null
    organization_id: number | null
    updated_at: Date | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    url: number
    alt_text: number
    name: number
    created_at: number
    organization_id: number
    updated_at: number
    _all: number
  }


  export type MediaAvgAggregateInputType = {
    id?: true
    organization_id?: true
  }

  export type MediaSumAggregateInputType = {
    id?: true
    organization_id?: true
  }

  export type MediaMinAggregateInputType = {
    id?: true
    url?: true
    alt_text?: true
    name?: true
    created_at?: true
    organization_id?: true
    updated_at?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    url?: true
    alt_text?: true
    name?: true
    created_at?: true
    organization_id?: true
    updated_at?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    url?: true
    alt_text?: true
    name?: true
    created_at?: true
    organization_id?: true
    updated_at?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _avg?: MediaAvgAggregateInputType
    _sum?: MediaSumAggregateInputType
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: number
    url: string
    alt_text: string
    name: string
    created_at: Date
    organization_id: number
    updated_at: Date
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    alt_text?: boolean
    name?: boolean
    created_at?: boolean
    organization_id?: boolean
    updated_at?: boolean
    LinkPage?: boolean | Media$LinkPageArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Users?: boolean | Media$UsersArgs<ExtArgs>
    author?: boolean | Media$authorArgs<ExtArgs>
    org_details?: boolean | Media$org_detailsArgs<ExtArgs>
    struct?: boolean | Media$structArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    alt_text?: boolean
    name?: boolean
    created_at?: boolean
    organization_id?: boolean
    updated_at?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    alt_text?: boolean
    name?: boolean
    created_at?: boolean
    organization_id?: boolean
    updated_at?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectScalar = {
    id?: boolean
    url?: boolean
    alt_text?: boolean
    name?: boolean
    created_at?: boolean
    organization_id?: boolean
    updated_at?: boolean
  }

  export type MediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "alt_text" | "name" | "created_at" | "organization_id" | "updated_at", ExtArgs["result"]["media"]>
  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LinkPage?: boolean | Media$LinkPageArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Users?: boolean | Media$UsersArgs<ExtArgs>
    author?: boolean | Media$authorArgs<ExtArgs>
    org_details?: boolean | Media$org_detailsArgs<ExtArgs>
    struct?: boolean | Media$structArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type MediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      LinkPage: Prisma.$LinkPagePayload<ExtArgs>[]
      Organization: Prisma.$OrganizationPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>[]
      author: Prisma.$authorPayload<ExtArgs>[]
      org_details: Prisma.$org_detailsPayload<ExtArgs> | null
      struct: Prisma.$structPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      url: string
      alt_text: string
      name: string
      created_at: Date
      organization_id: number
      updated_at: Date
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Media and returns the data saved in the database.
     * @param {MediaCreateManyAndReturnArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media and returns the data updated in the database.
     * @param {MediaUpdateManyAndReturnArgs} args - Arguments to update many Media.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    LinkPage<T extends Media$LinkPageArgs<ExtArgs> = {}>(args?: Subset<T, Media$LinkPageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkPagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Users<T extends Media$UsersArgs<ExtArgs> = {}>(args?: Subset<T, Media$UsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    author<T extends Media$authorArgs<ExtArgs> = {}>(args?: Subset<T, Media$authorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    org_details<T extends Media$org_detailsArgs<ExtArgs> = {}>(args?: Subset<T, Media$org_detailsArgs<ExtArgs>>): Prisma__org_detailsClient<$Result.GetResult<Prisma.$org_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    struct<T extends Media$structArgs<ExtArgs> = {}>(args?: Subset<T, Media$structArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$structPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */ 
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'Int'>
    readonly url: FieldRef<"Media", 'String'>
    readonly alt_text: FieldRef<"Media", 'String'>
    readonly name: FieldRef<"Media", 'String'>
    readonly created_at: FieldRef<"Media", 'DateTime'>
    readonly organization_id: FieldRef<"Media", 'Int'>
    readonly updated_at: FieldRef<"Media", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media createManyAndReturn
   */
  export type MediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
  }

  /**
   * Media updateManyAndReturn
   */
  export type MediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to delete.
     */
    limit?: number
  }

  /**
   * Media.LinkPage
   */
  export type Media$LinkPageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkPage
     */
    select?: LinkPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkPage
     */
    omit?: LinkPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkPageInclude<ExtArgs> | null
    where?: LinkPageWhereInput
    orderBy?: LinkPageOrderByWithRelationInput | LinkPageOrderByWithRelationInput[]
    cursor?: LinkPageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LinkPageScalarFieldEnum | LinkPageScalarFieldEnum[]
  }

  /**
   * Media.Users
   */
  export type Media$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    cursor?: UsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Media.author
   */
  export type Media$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    where?: authorWhereInput
    orderBy?: authorOrderByWithRelationInput | authorOrderByWithRelationInput[]
    cursor?: authorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * Media.org_details
   */
  export type Media$org_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the org_details
     */
    select?: org_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the org_details
     */
    omit?: org_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: org_detailsInclude<ExtArgs> | null
    where?: org_detailsWhereInput
  }

  /**
   * Media.struct
   */
  export type Media$structArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct
     */
    select?: structSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct
     */
    omit?: structOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structInclude<ExtArgs> | null
    where?: structWhereInput
    orderBy?: structOrderByWithRelationInput | structOrderByWithRelationInput[]
    cursor?: structWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StructScalarFieldEnum | StructScalarFieldEnum[]
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model Messages
   */

  export type AggregateMessages = {
    _count: MessagesCountAggregateOutputType | null
    _avg: MessagesAvgAggregateOutputType | null
    _sum: MessagesSumAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  export type MessagesAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
  }

  export type MessagesSumAggregateOutputType = {
    id: number | null
    organization_id: number | null
  }

  export type MessagesMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    message: string | null
    first_name: string | null
    email: string | null
    phone_number: string | null
    last_name: string | null
    organization_id: number | null
    viewed: boolean | null
    archived: boolean | null
  }

  export type MessagesMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    message: string | null
    first_name: string | null
    email: string | null
    phone_number: string | null
    last_name: string | null
    organization_id: number | null
    viewed: boolean | null
    archived: boolean | null
  }

  export type MessagesCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    message: number
    first_name: number
    email: number
    phone_number: number
    last_name: number
    other_fields: number
    organization_id: number
    viewed: number
    archived: number
    _all: number
  }


  export type MessagesAvgAggregateInputType = {
    id?: true
    organization_id?: true
  }

  export type MessagesSumAggregateInputType = {
    id?: true
    organization_id?: true
  }

  export type MessagesMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    message?: true
    first_name?: true
    email?: true
    phone_number?: true
    last_name?: true
    organization_id?: true
    viewed?: true
    archived?: true
  }

  export type MessagesMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    message?: true
    first_name?: true
    email?: true
    phone_number?: true
    last_name?: true
    organization_id?: true
    viewed?: true
    archived?: true
  }

  export type MessagesCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    message?: true
    first_name?: true
    email?: true
    phone_number?: true
    last_name?: true
    other_fields?: true
    organization_id?: true
    viewed?: true
    archived?: true
    _all?: true
  }

  export type MessagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to aggregate.
     */
    where?: MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessagesMaxAggregateInputType
  }

  export type GetMessagesAggregateType<T extends MessagesAggregateArgs> = {
        [P in keyof T & keyof AggregateMessages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessages[P]>
      : GetScalarType<T[P], AggregateMessages[P]>
  }




  export type MessagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessagesWhereInput
    orderBy?: MessagesOrderByWithAggregationInput | MessagesOrderByWithAggregationInput[]
    by: MessagesScalarFieldEnum[] | MessagesScalarFieldEnum
    having?: MessagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessagesCountAggregateInputType | true
    _avg?: MessagesAvgAggregateInputType
    _sum?: MessagesSumAggregateInputType
    _min?: MessagesMinAggregateInputType
    _max?: MessagesMaxAggregateInputType
  }

  export type MessagesGroupByOutputType = {
    id: number
    created_at: Date
    updated_at: Date
    message: string
    first_name: string
    email: string
    phone_number: string | null
    last_name: string | null
    other_fields: JsonValue | null
    organization_id: number
    viewed: boolean
    archived: boolean
    _count: MessagesCountAggregateOutputType | null
    _avg: MessagesAvgAggregateOutputType | null
    _sum: MessagesSumAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  type GetMessagesGroupByPayload<T extends MessagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessagesGroupByOutputType[P]>
            : GetScalarType<T[P], MessagesGroupByOutputType[P]>
        }
      >
    >


  export type MessagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    message?: boolean
    first_name?: boolean
    email?: boolean
    phone_number?: boolean
    last_name?: boolean
    other_fields?: boolean
    organization_id?: boolean
    viewed?: boolean
    archived?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type MessagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    message?: boolean
    first_name?: boolean
    email?: boolean
    phone_number?: boolean
    last_name?: boolean
    other_fields?: boolean
    organization_id?: boolean
    viewed?: boolean
    archived?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type MessagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    message?: boolean
    first_name?: boolean
    email?: boolean
    phone_number?: boolean
    last_name?: boolean
    other_fields?: boolean
    organization_id?: boolean
    viewed?: boolean
    archived?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type MessagesSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    message?: boolean
    first_name?: boolean
    email?: boolean
    phone_number?: boolean
    last_name?: boolean
    other_fields?: boolean
    organization_id?: boolean
    viewed?: boolean
    archived?: boolean
  }

  export type MessagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "message" | "first_name" | "email" | "phone_number" | "last_name" | "other_fields" | "organization_id" | "viewed" | "archived", ExtArgs["result"]["messages"]>
  export type MessagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type MessagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type MessagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $MessagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Messages"
    objects: {
      Organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      created_at: Date
      updated_at: Date
      message: string
      first_name: string
      email: string
      phone_number: string | null
      last_name: string | null
      other_fields: Prisma.JsonValue | null
      organization_id: number
      viewed: boolean
      archived: boolean
    }, ExtArgs["result"]["messages"]>
    composites: {}
  }

  type MessagesGetPayload<S extends boolean | null | undefined | MessagesDefaultArgs> = $Result.GetResult<Prisma.$MessagesPayload, S>

  type MessagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessagesCountAggregateInputType | true
    }

  export interface MessagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'Messages' } }
    /**
     * Find zero or one Messages that matches the filter.
     * @param {MessagesFindUniqueArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessagesFindUniqueArgs>(args: SelectSubset<T, MessagesFindUniqueArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Messages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessagesFindUniqueOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessagesFindUniqueOrThrowArgs>(args: SelectSubset<T, MessagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesFindFirstArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessagesFindFirstArgs>(args?: SelectSubset<T, MessagesFindFirstArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesFindFirstOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessagesFindFirstOrThrowArgs>(args?: SelectSubset<T, MessagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.messages.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messagesWithIdOnly = await prisma.messages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessagesFindManyArgs>(args?: SelectSubset<T, MessagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Messages.
     * @param {MessagesCreateArgs} args - Arguments to create a Messages.
     * @example
     * // Create one Messages
     * const Messages = await prisma.messages.create({
     *   data: {
     *     // ... data to create a Messages
     *   }
     * })
     * 
     */
    create<T extends MessagesCreateArgs>(args: SelectSubset<T, MessagesCreateArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Messages.
     * @param {MessagesCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const messages = await prisma.messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessagesCreateManyArgs>(args?: SelectSubset<T, MessagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessagesCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const messages = await prisma.messages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messagesWithIdOnly = await prisma.messages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessagesCreateManyAndReturnArgs>(args?: SelectSubset<T, MessagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Messages.
     * @param {MessagesDeleteArgs} args - Arguments to delete one Messages.
     * @example
     * // Delete one Messages
     * const Messages = await prisma.messages.delete({
     *   where: {
     *     // ... filter to delete one Messages
     *   }
     * })
     * 
     */
    delete<T extends MessagesDeleteArgs>(args: SelectSubset<T, MessagesDeleteArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Messages.
     * @param {MessagesUpdateArgs} args - Arguments to update one Messages.
     * @example
     * // Update one Messages
     * const messages = await prisma.messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessagesUpdateArgs>(args: SelectSubset<T, MessagesUpdateArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessagesDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessagesDeleteManyArgs>(args?: SelectSubset<T, MessagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const messages = await prisma.messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessagesUpdateManyArgs>(args: SelectSubset<T, MessagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessagesUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const messages = await prisma.messages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messagesWithIdOnly = await prisma.messages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessagesUpdateManyAndReturnArgs>(args: SelectSubset<T, MessagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Messages.
     * @param {MessagesUpsertArgs} args - Arguments to update or create a Messages.
     * @example
     * // Update or create a Messages
     * const messages = await prisma.messages.upsert({
     *   create: {
     *     // ... data to create a Messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Messages we want to update
     *   }
     * })
     */
    upsert<T extends MessagesUpsertArgs>(args: SelectSubset<T, MessagesUpsertArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.messages.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessagesCountArgs>(
      args?: Subset<T, MessagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessagesAggregateArgs>(args: Subset<T, MessagesAggregateArgs>): Prisma.PrismaPromise<GetMessagesAggregateType<T>>

    /**
     * Group by Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessagesGroupByArgs['orderBy'] }
        : { orderBy?: MessagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Messages model
   */
  readonly fields: MessagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Messages model
   */ 
  interface MessagesFieldRefs {
    readonly id: FieldRef<"Messages", 'Int'>
    readonly created_at: FieldRef<"Messages", 'DateTime'>
    readonly updated_at: FieldRef<"Messages", 'DateTime'>
    readonly message: FieldRef<"Messages", 'String'>
    readonly first_name: FieldRef<"Messages", 'String'>
    readonly email: FieldRef<"Messages", 'String'>
    readonly phone_number: FieldRef<"Messages", 'String'>
    readonly last_name: FieldRef<"Messages", 'String'>
    readonly other_fields: FieldRef<"Messages", 'Json'>
    readonly organization_id: FieldRef<"Messages", 'Int'>
    readonly viewed: FieldRef<"Messages", 'Boolean'>
    readonly archived: FieldRef<"Messages", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Messages findUnique
   */
  export type MessagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where: MessagesWhereUniqueInput
  }

  /**
   * Messages findUniqueOrThrow
   */
  export type MessagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where: MessagesWhereUniqueInput
  }

  /**
   * Messages findFirst
   */
  export type MessagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Messages findFirstOrThrow
   */
  export type MessagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Messages findMany
   */
  export type MessagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Messages create
   */
  export type MessagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * The data needed to create a Messages.
     */
    data: XOR<MessagesCreateInput, MessagesUncheckedCreateInput>
  }

  /**
   * Messages createMany
   */
  export type MessagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessagesCreateManyInput | MessagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Messages createManyAndReturn
   */
  export type MessagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessagesCreateManyInput | MessagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Messages update
   */
  export type MessagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * The data needed to update a Messages.
     */
    data: XOR<MessagesUpdateInput, MessagesUncheckedUpdateInput>
    /**
     * Choose, which Messages to update.
     */
    where: MessagesWhereUniqueInput
  }

  /**
   * Messages updateMany
   */
  export type MessagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessagesUpdateManyMutationInput, MessagesUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessagesWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Messages updateManyAndReturn
   */
  export type MessagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessagesUpdateManyMutationInput, MessagesUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessagesWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Messages upsert
   */
  export type MessagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * The filter to search for the Messages to update in case it exists.
     */
    where: MessagesWhereUniqueInput
    /**
     * In case the Messages found by the `where` argument doesn't exist, create a new Messages with this data.
     */
    create: XOR<MessagesCreateInput, MessagesUncheckedCreateInput>
    /**
     * In case the Messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessagesUpdateInput, MessagesUncheckedUpdateInput>
  }

  /**
   * Messages delete
   */
  export type MessagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter which Messages to delete.
     */
    where: MessagesWhereUniqueInput
  }

  /**
   * Messages deleteMany
   */
  export type MessagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessagesWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Messages without action
   */
  export type MessagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationAvgAggregateOutputType = {
    id: number | null
  }

  export type OrganizationSumAggregateOutputType = {
    id: number | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: number | null
    company_name: string | null
    address: string | null
    country: string | null
    phone: string | null
    email: string | null
    company_description: string | null
    domain: string | null
    logo: string | null
    token: string | null
    stripe_customer_id: string | null
    stripe_price_id: string | null
    stripe_is_subscribed: boolean | null
    ai_subscription_id: string | null
    notify_by_email: boolean | null
    notify_by_sms: boolean | null
    slack_webhook_url: string | null
    city: string | null
    postal_code: string | null
    state: string | null
    street_address: string | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: number | null
    company_name: string | null
    address: string | null
    country: string | null
    phone: string | null
    email: string | null
    company_description: string | null
    domain: string | null
    logo: string | null
    token: string | null
    stripe_customer_id: string | null
    stripe_price_id: string | null
    stripe_is_subscribed: boolean | null
    ai_subscription_id: string | null
    notify_by_email: boolean | null
    notify_by_sms: boolean | null
    slack_webhook_url: string | null
    city: string | null
    postal_code: string | null
    state: string | null
    street_address: string | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    company_name: number
    address: number
    country: number
    phone: number
    email: number
    company_description: number
    domain: number
    logo: number
    token: number
    stripe_customer_id: number
    stripe_price_id: number
    stripe_is_subscribed: number
    ai_subscription_id: number
    notify_by_email: number
    notify_by_sms: number
    slack_webhook_url: number
    city: number
    postal_code: number
    state: number
    street_address: number
    _all: number
  }


  export type OrganizationAvgAggregateInputType = {
    id?: true
  }

  export type OrganizationSumAggregateInputType = {
    id?: true
  }

  export type OrganizationMinAggregateInputType = {
    id?: true
    company_name?: true
    address?: true
    country?: true
    phone?: true
    email?: true
    company_description?: true
    domain?: true
    logo?: true
    token?: true
    stripe_customer_id?: true
    stripe_price_id?: true
    stripe_is_subscribed?: true
    ai_subscription_id?: true
    notify_by_email?: true
    notify_by_sms?: true
    slack_webhook_url?: true
    city?: true
    postal_code?: true
    state?: true
    street_address?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    company_name?: true
    address?: true
    country?: true
    phone?: true
    email?: true
    company_description?: true
    domain?: true
    logo?: true
    token?: true
    stripe_customer_id?: true
    stripe_price_id?: true
    stripe_is_subscribed?: true
    ai_subscription_id?: true
    notify_by_email?: true
    notify_by_sms?: true
    slack_webhook_url?: true
    city?: true
    postal_code?: true
    state?: true
    street_address?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    company_name?: true
    address?: true
    country?: true
    phone?: true
    email?: true
    company_description?: true
    domain?: true
    logo?: true
    token?: true
    stripe_customer_id?: true
    stripe_price_id?: true
    stripe_is_subscribed?: true
    ai_subscription_id?: true
    notify_by_email?: true
    notify_by_sms?: true
    slack_webhook_url?: true
    city?: true
    postal_code?: true
    state?: true
    street_address?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _avg?: OrganizationAvgAggregateInputType
    _sum?: OrganizationSumAggregateInputType
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: number
    company_name: string
    address: string | null
    country: string | null
    phone: string
    email: string
    company_description: string
    domain: string | null
    logo: string | null
    token: string
    stripe_customer_id: string | null
    stripe_price_id: string
    stripe_is_subscribed: boolean
    ai_subscription_id: string | null
    notify_by_email: boolean
    notify_by_sms: boolean
    slack_webhook_url: string | null
    city: string | null
    postal_code: string | null
    state: string | null
    street_address: string | null
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_name?: boolean
    address?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    company_description?: boolean
    domain?: boolean
    logo?: boolean
    token?: boolean
    stripe_customer_id?: boolean
    stripe_price_id?: boolean
    stripe_is_subscribed?: boolean
    ai_subscription_id?: boolean
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: boolean
    city?: boolean
    postal_code?: boolean
    state?: boolean
    street_address?: boolean
    Category?: boolean | Organization$CategoryArgs<ExtArgs>
    Collection?: boolean | Organization$CollectionArgs<ExtArgs>
    Comment?: boolean | Organization$CommentArgs<ExtArgs>
    CompletionUsage?: boolean | Organization$CompletionUsageArgs<ExtArgs>
    Content?: boolean | Organization$ContentArgs<ExtArgs>
    ImageGenerationBilling?: boolean | Organization$ImageGenerationBillingArgs<ExtArgs>
    Invoice?: boolean | Organization$InvoiceArgs<ExtArgs>
    LinkPage?: boolean | Organization$LinkPageArgs<ExtArgs>
    Media?: boolean | Organization$MediaArgs<ExtArgs>
    Messages?: boolean | Organization$MessagesArgs<ExtArgs>
    Page?: boolean | Organization$PageArgs<ExtArgs>
    Subscription?: boolean | Organization$SubscriptionArgs<ExtArgs>
    Thread?: boolean | Organization$ThreadArgs<ExtArgs>
    Usage?: boolean | Organization$UsageArgs<ExtArgs>
    UserOrganization?: boolean | Organization$UserOrganizationArgs<ExtArgs>
    Users?: boolean | Organization$UsersArgs<ExtArgs>
    author?: boolean | Organization$authorArgs<ExtArgs>
    form_field?: boolean | Organization$form_fieldArgs<ExtArgs>
    org_details?: boolean | Organization$org_detailsArgs<ExtArgs>
    struct?: boolean | Organization$structArgs<ExtArgs>
    struct_set?: boolean | Organization$struct_setArgs<ExtArgs>
    struct_set_instance?: boolean | Organization$struct_set_instanceArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_name?: boolean
    address?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    company_description?: boolean
    domain?: boolean
    logo?: boolean
    token?: boolean
    stripe_customer_id?: boolean
    stripe_price_id?: boolean
    stripe_is_subscribed?: boolean
    ai_subscription_id?: boolean
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: boolean
    city?: boolean
    postal_code?: boolean
    state?: boolean
    street_address?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_name?: boolean
    address?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    company_description?: boolean
    domain?: boolean
    logo?: boolean
    token?: boolean
    stripe_customer_id?: boolean
    stripe_price_id?: boolean
    stripe_is_subscribed?: boolean
    ai_subscription_id?: boolean
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: boolean
    city?: boolean
    postal_code?: boolean
    state?: boolean
    street_address?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    company_name?: boolean
    address?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    company_description?: boolean
    domain?: boolean
    logo?: boolean
    token?: boolean
    stripe_customer_id?: boolean
    stripe_price_id?: boolean
    stripe_is_subscribed?: boolean
    ai_subscription_id?: boolean
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: boolean
    city?: boolean
    postal_code?: boolean
    state?: boolean
    street_address?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_name" | "address" | "country" | "phone" | "email" | "company_description" | "domain" | "logo" | "token" | "stripe_customer_id" | "stripe_price_id" | "stripe_is_subscribed" | "ai_subscription_id" | "notify_by_email" | "notify_by_sms" | "slack_webhook_url" | "city" | "postal_code" | "state" | "street_address", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Category?: boolean | Organization$CategoryArgs<ExtArgs>
    Collection?: boolean | Organization$CollectionArgs<ExtArgs>
    Comment?: boolean | Organization$CommentArgs<ExtArgs>
    CompletionUsage?: boolean | Organization$CompletionUsageArgs<ExtArgs>
    Content?: boolean | Organization$ContentArgs<ExtArgs>
    ImageGenerationBilling?: boolean | Organization$ImageGenerationBillingArgs<ExtArgs>
    Invoice?: boolean | Organization$InvoiceArgs<ExtArgs>
    LinkPage?: boolean | Organization$LinkPageArgs<ExtArgs>
    Media?: boolean | Organization$MediaArgs<ExtArgs>
    Messages?: boolean | Organization$MessagesArgs<ExtArgs>
    Page?: boolean | Organization$PageArgs<ExtArgs>
    Subscription?: boolean | Organization$SubscriptionArgs<ExtArgs>
    Thread?: boolean | Organization$ThreadArgs<ExtArgs>
    Usage?: boolean | Organization$UsageArgs<ExtArgs>
    UserOrganization?: boolean | Organization$UserOrganizationArgs<ExtArgs>
    Users?: boolean | Organization$UsersArgs<ExtArgs>
    author?: boolean | Organization$authorArgs<ExtArgs>
    form_field?: boolean | Organization$form_fieldArgs<ExtArgs>
    org_details?: boolean | Organization$org_detailsArgs<ExtArgs>
    struct?: boolean | Organization$structArgs<ExtArgs>
    struct_set?: boolean | Organization$struct_setArgs<ExtArgs>
    struct_set_instance?: boolean | Organization$struct_set_instanceArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      Category: Prisma.$CategoryPayload<ExtArgs>[]
      Collection: Prisma.$CollectionPayload<ExtArgs>[]
      Comment: Prisma.$CommentPayload<ExtArgs>[]
      CompletionUsage: Prisma.$CompletionUsagePayload<ExtArgs>[]
      Content: Prisma.$ContentPayload<ExtArgs>[]
      ImageGenerationBilling: Prisma.$ImageGenerationBillingPayload<ExtArgs>[]
      Invoice: Prisma.$InvoicePayload<ExtArgs>[]
      LinkPage: Prisma.$LinkPagePayload<ExtArgs>[]
      Media: Prisma.$MediaPayload<ExtArgs>[]
      Messages: Prisma.$MessagesPayload<ExtArgs>[]
      Page: Prisma.$PagePayload<ExtArgs>[]
      Subscription: Prisma.$SubscriptionPayload<ExtArgs>[]
      Thread: Prisma.$ThreadPayload<ExtArgs>[]
      Usage: Prisma.$UsagePayload<ExtArgs>[]
      UserOrganization: Prisma.$UserOrganizationPayload<ExtArgs>[]
      Users: Prisma.$UsersPayload<ExtArgs>[]
      author: Prisma.$authorPayload<ExtArgs>[]
      form_field: Prisma.$form_fieldPayload<ExtArgs>[]
      org_details: Prisma.$org_detailsPayload<ExtArgs> | null
      struct: Prisma.$structPayload<ExtArgs>[]
      struct_set: Prisma.$struct_setPayload<ExtArgs>[]
      struct_set_instance: Prisma.$struct_set_instancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      company_name: string
      address: string | null
      country: string | null
      phone: string
      email: string
      company_description: string
      domain: string | null
      logo: string | null
      token: string
      stripe_customer_id: string | null
      stripe_price_id: string
      stripe_is_subscribed: boolean
      ai_subscription_id: string | null
      notify_by_email: boolean
      notify_by_sms: boolean
      slack_webhook_url: string | null
      city: string | null
      postal_code: string | null
      state: string | null
      street_address: string | null
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Category<T extends Organization$CategoryArgs<ExtArgs> = {}>(args?: Subset<T, Organization$CategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Collection<T extends Organization$CollectionArgs<ExtArgs> = {}>(args?: Subset<T, Organization$CollectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Comment<T extends Organization$CommentArgs<ExtArgs> = {}>(args?: Subset<T, Organization$CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    CompletionUsage<T extends Organization$CompletionUsageArgs<ExtArgs> = {}>(args?: Subset<T, Organization$CompletionUsageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompletionUsagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Content<T extends Organization$ContentArgs<ExtArgs> = {}>(args?: Subset<T, Organization$ContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ImageGenerationBilling<T extends Organization$ImageGenerationBillingArgs<ExtArgs> = {}>(args?: Subset<T, Organization$ImageGenerationBillingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImageGenerationBillingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Invoice<T extends Organization$InvoiceArgs<ExtArgs> = {}>(args?: Subset<T, Organization$InvoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    LinkPage<T extends Organization$LinkPageArgs<ExtArgs> = {}>(args?: Subset<T, Organization$LinkPageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkPagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Media<T extends Organization$MediaArgs<ExtArgs> = {}>(args?: Subset<T, Organization$MediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Messages<T extends Organization$MessagesArgs<ExtArgs> = {}>(args?: Subset<T, Organization$MessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Page<T extends Organization$PageArgs<ExtArgs> = {}>(args?: Subset<T, Organization$PageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Subscription<T extends Organization$SubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Organization$SubscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Thread<T extends Organization$ThreadArgs<ExtArgs> = {}>(args?: Subset<T, Organization$ThreadArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Usage<T extends Organization$UsageArgs<ExtArgs> = {}>(args?: Subset<T, Organization$UsageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    UserOrganization<T extends Organization$UserOrganizationArgs<ExtArgs> = {}>(args?: Subset<T, Organization$UserOrganizationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Users<T extends Organization$UsersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$UsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    author<T extends Organization$authorArgs<ExtArgs> = {}>(args?: Subset<T, Organization$authorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    form_field<T extends Organization$form_fieldArgs<ExtArgs> = {}>(args?: Subset<T, Organization$form_fieldArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$form_fieldPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    org_details<T extends Organization$org_detailsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$org_detailsArgs<ExtArgs>>): Prisma__org_detailsClient<$Result.GetResult<Prisma.$org_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    struct<T extends Organization$structArgs<ExtArgs> = {}>(args?: Subset<T, Organization$structArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$structPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    struct_set<T extends Organization$struct_setArgs<ExtArgs> = {}>(args?: Subset<T, Organization$struct_setArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$struct_setPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    struct_set_instance<T extends Organization$struct_set_instanceArgs<ExtArgs> = {}>(args?: Subset<T, Organization$struct_set_instanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$struct_set_instancePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */ 
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'Int'>
    readonly company_name: FieldRef<"Organization", 'String'>
    readonly address: FieldRef<"Organization", 'String'>
    readonly country: FieldRef<"Organization", 'String'>
    readonly phone: FieldRef<"Organization", 'String'>
    readonly email: FieldRef<"Organization", 'String'>
    readonly company_description: FieldRef<"Organization", 'String'>
    readonly domain: FieldRef<"Organization", 'String'>
    readonly logo: FieldRef<"Organization", 'String'>
    readonly token: FieldRef<"Organization", 'String'>
    readonly stripe_customer_id: FieldRef<"Organization", 'String'>
    readonly stripe_price_id: FieldRef<"Organization", 'String'>
    readonly stripe_is_subscribed: FieldRef<"Organization", 'Boolean'>
    readonly ai_subscription_id: FieldRef<"Organization", 'String'>
    readonly notify_by_email: FieldRef<"Organization", 'Boolean'>
    readonly notify_by_sms: FieldRef<"Organization", 'Boolean'>
    readonly slack_webhook_url: FieldRef<"Organization", 'String'>
    readonly city: FieldRef<"Organization", 'String'>
    readonly postal_code: FieldRef<"Organization", 'String'>
    readonly state: FieldRef<"Organization", 'String'>
    readonly street_address: FieldRef<"Organization", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization.Category
   */
  export type Organization$CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Organization.Collection
   */
  export type Organization$CollectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    where?: CollectionWhereInput
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    cursor?: CollectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * Organization.Comment
   */
  export type Organization$CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Organization.CompletionUsage
   */
  export type Organization$CompletionUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionUsage
     */
    select?: CompletionUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionUsage
     */
    omit?: CompletionUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletionUsageInclude<ExtArgs> | null
    where?: CompletionUsageWhereInput
    orderBy?: CompletionUsageOrderByWithRelationInput | CompletionUsageOrderByWithRelationInput[]
    cursor?: CompletionUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompletionUsageScalarFieldEnum | CompletionUsageScalarFieldEnum[]
  }

  /**
   * Organization.Content
   */
  export type Organization$ContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    where?: ContentWhereInput
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    cursor?: ContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Organization.ImageGenerationBilling
   */
  export type Organization$ImageGenerationBillingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageGenerationBilling
     */
    select?: ImageGenerationBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageGenerationBilling
     */
    omit?: ImageGenerationBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageGenerationBillingInclude<ExtArgs> | null
    where?: ImageGenerationBillingWhereInput
    orderBy?: ImageGenerationBillingOrderByWithRelationInput | ImageGenerationBillingOrderByWithRelationInput[]
    cursor?: ImageGenerationBillingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageGenerationBillingScalarFieldEnum | ImageGenerationBillingScalarFieldEnum[]
  }

  /**
   * Organization.Invoice
   */
  export type Organization$InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Organization.LinkPage
   */
  export type Organization$LinkPageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkPage
     */
    select?: LinkPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkPage
     */
    omit?: LinkPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkPageInclude<ExtArgs> | null
    where?: LinkPageWhereInput
    orderBy?: LinkPageOrderByWithRelationInput | LinkPageOrderByWithRelationInput[]
    cursor?: LinkPageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LinkPageScalarFieldEnum | LinkPageScalarFieldEnum[]
  }

  /**
   * Organization.Media
   */
  export type Organization$MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Organization.Messages
   */
  export type Organization$MessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    where?: MessagesWhereInput
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    cursor?: MessagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Organization.Page
   */
  export type Organization$PageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    where?: PageWhereInput
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    cursor?: PageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Organization.Subscription
   */
  export type Organization$SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Organization.Thread
   */
  export type Organization$ThreadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thread
     */
    omit?: ThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    where?: ThreadWhereInput
    orderBy?: ThreadOrderByWithRelationInput | ThreadOrderByWithRelationInput[]
    cursor?: ThreadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ThreadScalarFieldEnum | ThreadScalarFieldEnum[]
  }

  /**
   * Organization.Usage
   */
  export type Organization$UsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usage
     */
    omit?: UsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
    where?: UsageWhereInput
    orderBy?: UsageOrderByWithRelationInput | UsageOrderByWithRelationInput[]
    cursor?: UsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageScalarFieldEnum | UsageScalarFieldEnum[]
  }

  /**
   * Organization.UserOrganization
   */
  export type Organization$UserOrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOrganization
     */
    omit?: UserOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    where?: UserOrganizationWhereInput
    orderBy?: UserOrganizationOrderByWithRelationInput | UserOrganizationOrderByWithRelationInput[]
    cursor?: UserOrganizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserOrganizationScalarFieldEnum | UserOrganizationScalarFieldEnum[]
  }

  /**
   * Organization.Users
   */
  export type Organization$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    cursor?: UsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Organization.author
   */
  export type Organization$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    where?: authorWhereInput
    orderBy?: authorOrderByWithRelationInput | authorOrderByWithRelationInput[]
    cursor?: authorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * Organization.form_field
   */
  export type Organization$form_fieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_field
     */
    select?: form_fieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form_field
     */
    omit?: form_fieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: form_fieldInclude<ExtArgs> | null
    where?: form_fieldWhereInput
    orderBy?: form_fieldOrderByWithRelationInput | form_fieldOrderByWithRelationInput[]
    cursor?: form_fieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Form_fieldScalarFieldEnum | Form_fieldScalarFieldEnum[]
  }

  /**
   * Organization.org_details
   */
  export type Organization$org_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the org_details
     */
    select?: org_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the org_details
     */
    omit?: org_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: org_detailsInclude<ExtArgs> | null
    where?: org_detailsWhereInput
  }

  /**
   * Organization.struct
   */
  export type Organization$structArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct
     */
    select?: structSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct
     */
    omit?: structOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structInclude<ExtArgs> | null
    where?: structWhereInput
    orderBy?: structOrderByWithRelationInput | structOrderByWithRelationInput[]
    cursor?: structWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StructScalarFieldEnum | StructScalarFieldEnum[]
  }

  /**
   * Organization.struct_set
   */
  export type Organization$struct_setArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set
     */
    select?: struct_setSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set
     */
    omit?: struct_setOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_setInclude<ExtArgs> | null
    where?: struct_setWhereInput
    orderBy?: struct_setOrderByWithRelationInput | struct_setOrderByWithRelationInput[]
    cursor?: struct_setWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Struct_setScalarFieldEnum | Struct_setScalarFieldEnum[]
  }

  /**
   * Organization.struct_set_instance
   */
  export type Organization$struct_set_instanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set_instance
     */
    select?: struct_set_instanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set_instance
     */
    omit?: struct_set_instanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_set_instanceInclude<ExtArgs> | null
    where?: struct_set_instanceWhereInput
    orderBy?: struct_set_instanceOrderByWithRelationInput | struct_set_instanceOrderByWithRelationInput[]
    cursor?: struct_set_instanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Struct_set_instanceScalarFieldEnum | Struct_set_instanceScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model Page
   */

  export type AggregatePage = {
    _count: PageCountAggregateOutputType | null
    _avg: PageAvgAggregateOutputType | null
    _sum: PageSumAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  export type PageAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
  }

  export type PageSumAggregateOutputType = {
    id: number | null
    organization_id: number | null
  }

  export type PageMinAggregateOutputType = {
    id: number | null
    title: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
    published: boolean | null
    archive: boolean | null
    organization_id: number | null
  }

  export type PageMaxAggregateOutputType = {
    id: number | null
    title: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
    published: boolean | null
    archive: boolean | null
    organization_id: number | null
  }

  export type PageCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    created_at: number
    updated_at: number
    published: number
    archive: number
    data: number
    organization_id: number
    _all: number
  }


  export type PageAvgAggregateInputType = {
    id?: true
    organization_id?: true
  }

  export type PageSumAggregateInputType = {
    id?: true
    organization_id?: true
  }

  export type PageMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    created_at?: true
    updated_at?: true
    published?: true
    archive?: true
    organization_id?: true
  }

  export type PageMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    created_at?: true
    updated_at?: true
    published?: true
    archive?: true
    organization_id?: true
  }

  export type PageCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    created_at?: true
    updated_at?: true
    published?: true
    archive?: true
    data?: true
    organization_id?: true
    _all?: true
  }

  export type PageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Page to aggregate.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pages
    **/
    _count?: true | PageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PageMaxAggregateInputType
  }

  export type GetPageAggregateType<T extends PageAggregateArgs> = {
        [P in keyof T & keyof AggregatePage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePage[P]>
      : GetScalarType<T[P], AggregatePage[P]>
  }




  export type PageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
    orderBy?: PageOrderByWithAggregationInput | PageOrderByWithAggregationInput[]
    by: PageScalarFieldEnum[] | PageScalarFieldEnum
    having?: PageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageCountAggregateInputType | true
    _avg?: PageAvgAggregateInputType
    _sum?: PageSumAggregateInputType
    _min?: PageMinAggregateInputType
    _max?: PageMaxAggregateInputType
  }

  export type PageGroupByOutputType = {
    id: number
    title: string
    slug: string
    created_at: Date
    updated_at: Date
    published: boolean
    archive: boolean
    data: JsonValue | null
    organization_id: number
    _count: PageCountAggregateOutputType | null
    _avg: PageAvgAggregateOutputType | null
    _sum: PageSumAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  type GetPageGroupByPayload<T extends PageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageGroupByOutputType[P]>
            : GetScalarType<T[P], PageGroupByOutputType[P]>
        }
      >
    >


  export type PageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    created_at?: boolean
    updated_at?: boolean
    published?: boolean
    archive?: boolean
    data?: boolean
    organization_id?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["page"]>

  export type PageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    created_at?: boolean
    updated_at?: boolean
    published?: boolean
    archive?: boolean
    data?: boolean
    organization_id?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["page"]>

  export type PageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    created_at?: boolean
    updated_at?: boolean
    published?: boolean
    archive?: boolean
    data?: boolean
    organization_id?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["page"]>

  export type PageSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    created_at?: boolean
    updated_at?: boolean
    published?: boolean
    archive?: boolean
    data?: boolean
    organization_id?: boolean
  }

  export type PageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "created_at" | "updated_at" | "published" | "archive" | "data" | "organization_id", ExtArgs["result"]["page"]>
  export type PageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type PageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type PageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $PagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Page"
    objects: {
      Organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      slug: string
      created_at: Date
      updated_at: Date
      published: boolean
      archive: boolean
      data: Prisma.JsonValue | null
      organization_id: number
    }, ExtArgs["result"]["page"]>
    composites: {}
  }

  type PageGetPayload<S extends boolean | null | undefined | PageDefaultArgs> = $Result.GetResult<Prisma.$PagePayload, S>

  type PageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PageCountAggregateInputType | true
    }

  export interface PageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'Page' } }
    /**
     * Find zero or one Page that matches the filter.
     * @param {PageFindUniqueArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageFindUniqueArgs>(args: SelectSubset<T, PageFindUniqueArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Page that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PageFindUniqueOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageFindUniqueOrThrowArgs>(args: SelectSubset<T, PageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Page that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageFindFirstArgs>(args?: SelectSubset<T, PageFindFirstArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Page that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageFindFirstOrThrowArgs>(args?: SelectSubset<T, PageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pages
     * const pages = await prisma.page.findMany()
     * 
     * // Get first 10 Pages
     * const pages = await prisma.page.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pageWithIdOnly = await prisma.page.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PageFindManyArgs>(args?: SelectSubset<T, PageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Page.
     * @param {PageCreateArgs} args - Arguments to create a Page.
     * @example
     * // Create one Page
     * const Page = await prisma.page.create({
     *   data: {
     *     // ... data to create a Page
     *   }
     * })
     * 
     */
    create<T extends PageCreateArgs>(args: SelectSubset<T, PageCreateArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Pages.
     * @param {PageCreateManyArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const page = await prisma.page.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PageCreateManyArgs>(args?: SelectSubset<T, PageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pages and returns the data saved in the database.
     * @param {PageCreateManyAndReturnArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const page = await prisma.page.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pages and only return the `id`
     * const pageWithIdOnly = await prisma.page.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PageCreateManyAndReturnArgs>(args?: SelectSubset<T, PageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Page.
     * @param {PageDeleteArgs} args - Arguments to delete one Page.
     * @example
     * // Delete one Page
     * const Page = await prisma.page.delete({
     *   where: {
     *     // ... filter to delete one Page
     *   }
     * })
     * 
     */
    delete<T extends PageDeleteArgs>(args: SelectSubset<T, PageDeleteArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Page.
     * @param {PageUpdateArgs} args - Arguments to update one Page.
     * @example
     * // Update one Page
     * const page = await prisma.page.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PageUpdateArgs>(args: SelectSubset<T, PageUpdateArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Pages.
     * @param {PageDeleteManyArgs} args - Arguments to filter Pages to delete.
     * @example
     * // Delete a few Pages
     * const { count } = await prisma.page.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PageDeleteManyArgs>(args?: SelectSubset<T, PageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pages
     * const page = await prisma.page.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PageUpdateManyArgs>(args: SelectSubset<T, PageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages and returns the data updated in the database.
     * @param {PageUpdateManyAndReturnArgs} args - Arguments to update many Pages.
     * @example
     * // Update many Pages
     * const page = await prisma.page.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pages and only return the `id`
     * const pageWithIdOnly = await prisma.page.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PageUpdateManyAndReturnArgs>(args: SelectSubset<T, PageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Page.
     * @param {PageUpsertArgs} args - Arguments to update or create a Page.
     * @example
     * // Update or create a Page
     * const page = await prisma.page.upsert({
     *   create: {
     *     // ... data to create a Page
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Page we want to update
     *   }
     * })
     */
    upsert<T extends PageUpsertArgs>(args: SelectSubset<T, PageUpsertArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageCountArgs} args - Arguments to filter Pages to count.
     * @example
     * // Count the number of Pages
     * const count = await prisma.page.count({
     *   where: {
     *     // ... the filter for the Pages we want to count
     *   }
     * })
    **/
    count<T extends PageCountArgs>(
      args?: Subset<T, PageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PageAggregateArgs>(args: Subset<T, PageAggregateArgs>): Prisma.PrismaPromise<GetPageAggregateType<T>>

    /**
     * Group by Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageGroupByArgs['orderBy'] }
        : { orderBy?: PageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Page model
   */
  readonly fields: PageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Page.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Page model
   */ 
  interface PageFieldRefs {
    readonly id: FieldRef<"Page", 'Int'>
    readonly title: FieldRef<"Page", 'String'>
    readonly slug: FieldRef<"Page", 'String'>
    readonly created_at: FieldRef<"Page", 'DateTime'>
    readonly updated_at: FieldRef<"Page", 'DateTime'>
    readonly published: FieldRef<"Page", 'Boolean'>
    readonly archive: FieldRef<"Page", 'Boolean'>
    readonly data: FieldRef<"Page", 'Json'>
    readonly organization_id: FieldRef<"Page", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Page findUnique
   */
  export type PageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findUniqueOrThrow
   */
  export type PageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findFirst
   */
  export type PageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findFirstOrThrow
   */
  export type PageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findMany
   */
  export type PageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Pages to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page create
   */
  export type PageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The data needed to create a Page.
     */
    data: XOR<PageCreateInput, PageUncheckedCreateInput>
  }

  /**
   * Page createMany
   */
  export type PageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Page createManyAndReturn
   */
  export type PageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Page update
   */
  export type PageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The data needed to update a Page.
     */
    data: XOR<PageUpdateInput, PageUncheckedUpdateInput>
    /**
     * Choose, which Page to update.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page updateMany
   */
  export type PageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pages.
     */
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyInput>
    /**
     * Filter which Pages to update
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to update.
     */
    limit?: number
  }

  /**
   * Page updateManyAndReturn
   */
  export type PageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The data used to update Pages.
     */
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyInput>
    /**
     * Filter which Pages to update
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Page upsert
   */
  export type PageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The filter to search for the Page to update in case it exists.
     */
    where: PageWhereUniqueInput
    /**
     * In case the Page found by the `where` argument doesn't exist, create a new Page with this data.
     */
    create: XOR<PageCreateInput, PageUncheckedCreateInput>
    /**
     * In case the Page was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageUpdateInput, PageUncheckedUpdateInput>
  }

  /**
   * Page delete
   */
  export type PageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter which Page to delete.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page deleteMany
   */
  export type PageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pages to delete
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to delete.
     */
    limit?: number
  }

  /**
   * Page without action
   */
  export type PageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
  }


  /**
   * Model Run
   */

  export type AggregateRun = {
    _count: RunCountAggregateOutputType | null
    _min: RunMinAggregateOutputType | null
    _max: RunMaxAggregateOutputType | null
  }

  export type RunMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    assistant_id: string | null
    thread_id: string | null
    status: string | null
    started_at: Date | null
    expires_at: Date | null
    cancelled_at: Date | null
    failed_at: Date | null
    completed_at: Date | null
    last_error: string | null
    model: string | null
    instructions: string | null
  }

  export type RunMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    assistant_id: string | null
    thread_id: string | null
    status: string | null
    started_at: Date | null
    expires_at: Date | null
    cancelled_at: Date | null
    failed_at: Date | null
    completed_at: Date | null
    last_error: string | null
    model: string | null
    instructions: string | null
  }

  export type RunCountAggregateOutputType = {
    id: number
    created_at: number
    assistant_id: number
    thread_id: number
    status: number
    started_at: number
    expires_at: number
    cancelled_at: number
    failed_at: number
    completed_at: number
    last_error: number
    model: number
    instructions: number
    _all: number
  }


  export type RunMinAggregateInputType = {
    id?: true
    created_at?: true
    assistant_id?: true
    thread_id?: true
    status?: true
    started_at?: true
    expires_at?: true
    cancelled_at?: true
    failed_at?: true
    completed_at?: true
    last_error?: true
    model?: true
    instructions?: true
  }

  export type RunMaxAggregateInputType = {
    id?: true
    created_at?: true
    assistant_id?: true
    thread_id?: true
    status?: true
    started_at?: true
    expires_at?: true
    cancelled_at?: true
    failed_at?: true
    completed_at?: true
    last_error?: true
    model?: true
    instructions?: true
  }

  export type RunCountAggregateInputType = {
    id?: true
    created_at?: true
    assistant_id?: true
    thread_id?: true
    status?: true
    started_at?: true
    expires_at?: true
    cancelled_at?: true
    failed_at?: true
    completed_at?: true
    last_error?: true
    model?: true
    instructions?: true
    _all?: true
  }

  export type RunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Run to aggregate.
     */
    where?: RunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Runs to fetch.
     */
    orderBy?: RunOrderByWithRelationInput | RunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Runs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Runs
    **/
    _count?: true | RunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RunMaxAggregateInputType
  }

  export type GetRunAggregateType<T extends RunAggregateArgs> = {
        [P in keyof T & keyof AggregateRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRun[P]>
      : GetScalarType<T[P], AggregateRun[P]>
  }




  export type RunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RunWhereInput
    orderBy?: RunOrderByWithAggregationInput | RunOrderByWithAggregationInput[]
    by: RunScalarFieldEnum[] | RunScalarFieldEnum
    having?: RunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RunCountAggregateInputType | true
    _min?: RunMinAggregateInputType
    _max?: RunMaxAggregateInputType
  }

  export type RunGroupByOutputType = {
    id: string
    created_at: Date
    assistant_id: string
    thread_id: string
    status: string
    started_at: Date
    expires_at: Date | null
    cancelled_at: Date | null
    failed_at: Date | null
    completed_at: Date | null
    last_error: string | null
    model: string
    instructions: string | null
    _count: RunCountAggregateOutputType | null
    _min: RunMinAggregateOutputType | null
    _max: RunMaxAggregateOutputType | null
  }

  type GetRunGroupByPayload<T extends RunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RunGroupByOutputType[P]>
            : GetScalarType<T[P], RunGroupByOutputType[P]>
        }
      >
    >


  export type RunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    assistant_id?: boolean
    thread_id?: boolean
    status?: boolean
    started_at?: boolean
    expires_at?: boolean
    cancelled_at?: boolean
    failed_at?: boolean
    completed_at?: boolean
    last_error?: boolean
    model?: boolean
    instructions?: boolean
    Thread?: boolean | ThreadDefaultArgs<ExtArgs>
    ThreadMessage?: boolean | Run$ThreadMessageArgs<ExtArgs>
    Usage?: boolean | Run$UsageArgs<ExtArgs>
    _count?: boolean | RunCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["run"]>

  export type RunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    assistant_id?: boolean
    thread_id?: boolean
    status?: boolean
    started_at?: boolean
    expires_at?: boolean
    cancelled_at?: boolean
    failed_at?: boolean
    completed_at?: boolean
    last_error?: boolean
    model?: boolean
    instructions?: boolean
    Thread?: boolean | ThreadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["run"]>

  export type RunSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    assistant_id?: boolean
    thread_id?: boolean
    status?: boolean
    started_at?: boolean
    expires_at?: boolean
    cancelled_at?: boolean
    failed_at?: boolean
    completed_at?: boolean
    last_error?: boolean
    model?: boolean
    instructions?: boolean
    Thread?: boolean | ThreadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["run"]>

  export type RunSelectScalar = {
    id?: boolean
    created_at?: boolean
    assistant_id?: boolean
    thread_id?: boolean
    status?: boolean
    started_at?: boolean
    expires_at?: boolean
    cancelled_at?: boolean
    failed_at?: boolean
    completed_at?: boolean
    last_error?: boolean
    model?: boolean
    instructions?: boolean
  }

  export type RunOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "assistant_id" | "thread_id" | "status" | "started_at" | "expires_at" | "cancelled_at" | "failed_at" | "completed_at" | "last_error" | "model" | "instructions", ExtArgs["result"]["run"]>
  export type RunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Thread?: boolean | ThreadDefaultArgs<ExtArgs>
    ThreadMessage?: boolean | Run$ThreadMessageArgs<ExtArgs>
    Usage?: boolean | Run$UsageArgs<ExtArgs>
    _count?: boolean | RunCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Thread?: boolean | ThreadDefaultArgs<ExtArgs>
  }
  export type RunIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Thread?: boolean | ThreadDefaultArgs<ExtArgs>
  }

  export type $RunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Run"
    objects: {
      Thread: Prisma.$ThreadPayload<ExtArgs>
      ThreadMessage: Prisma.$ThreadMessagePayload<ExtArgs>[]
      Usage: Prisma.$UsagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      assistant_id: string
      thread_id: string
      status: string
      started_at: Date
      expires_at: Date | null
      cancelled_at: Date | null
      failed_at: Date | null
      completed_at: Date | null
      last_error: string | null
      model: string
      instructions: string | null
    }, ExtArgs["result"]["run"]>
    composites: {}
  }

  type RunGetPayload<S extends boolean | null | undefined | RunDefaultArgs> = $Result.GetResult<Prisma.$RunPayload, S>

  type RunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RunCountAggregateInputType | true
    }

  export interface RunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'Run' } }
    /**
     * Find zero or one Run that matches the filter.
     * @param {RunFindUniqueArgs} args - Arguments to find a Run
     * @example
     * // Get one Run
     * const run = await prisma.run.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RunFindUniqueArgs>(args: SelectSubset<T, RunFindUniqueArgs<ExtArgs>>): Prisma__RunClient<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Run that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RunFindUniqueOrThrowArgs} args - Arguments to find a Run
     * @example
     * // Get one Run
     * const run = await prisma.run.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RunFindUniqueOrThrowArgs>(args: SelectSubset<T, RunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RunClient<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Run that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunFindFirstArgs} args - Arguments to find a Run
     * @example
     * // Get one Run
     * const run = await prisma.run.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RunFindFirstArgs>(args?: SelectSubset<T, RunFindFirstArgs<ExtArgs>>): Prisma__RunClient<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Run that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunFindFirstOrThrowArgs} args - Arguments to find a Run
     * @example
     * // Get one Run
     * const run = await prisma.run.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RunFindFirstOrThrowArgs>(args?: SelectSubset<T, RunFindFirstOrThrowArgs<ExtArgs>>): Prisma__RunClient<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Runs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Runs
     * const runs = await prisma.run.findMany()
     * 
     * // Get first 10 Runs
     * const runs = await prisma.run.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const runWithIdOnly = await prisma.run.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RunFindManyArgs>(args?: SelectSubset<T, RunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Run.
     * @param {RunCreateArgs} args - Arguments to create a Run.
     * @example
     * // Create one Run
     * const Run = await prisma.run.create({
     *   data: {
     *     // ... data to create a Run
     *   }
     * })
     * 
     */
    create<T extends RunCreateArgs>(args: SelectSubset<T, RunCreateArgs<ExtArgs>>): Prisma__RunClient<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Runs.
     * @param {RunCreateManyArgs} args - Arguments to create many Runs.
     * @example
     * // Create many Runs
     * const run = await prisma.run.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RunCreateManyArgs>(args?: SelectSubset<T, RunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Runs and returns the data saved in the database.
     * @param {RunCreateManyAndReturnArgs} args - Arguments to create many Runs.
     * @example
     * // Create many Runs
     * const run = await prisma.run.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Runs and only return the `id`
     * const runWithIdOnly = await prisma.run.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RunCreateManyAndReturnArgs>(args?: SelectSubset<T, RunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Run.
     * @param {RunDeleteArgs} args - Arguments to delete one Run.
     * @example
     * // Delete one Run
     * const Run = await prisma.run.delete({
     *   where: {
     *     // ... filter to delete one Run
     *   }
     * })
     * 
     */
    delete<T extends RunDeleteArgs>(args: SelectSubset<T, RunDeleteArgs<ExtArgs>>): Prisma__RunClient<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Run.
     * @param {RunUpdateArgs} args - Arguments to update one Run.
     * @example
     * // Update one Run
     * const run = await prisma.run.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RunUpdateArgs>(args: SelectSubset<T, RunUpdateArgs<ExtArgs>>): Prisma__RunClient<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Runs.
     * @param {RunDeleteManyArgs} args - Arguments to filter Runs to delete.
     * @example
     * // Delete a few Runs
     * const { count } = await prisma.run.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RunDeleteManyArgs>(args?: SelectSubset<T, RunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Runs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Runs
     * const run = await prisma.run.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RunUpdateManyArgs>(args: SelectSubset<T, RunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Runs and returns the data updated in the database.
     * @param {RunUpdateManyAndReturnArgs} args - Arguments to update many Runs.
     * @example
     * // Update many Runs
     * const run = await prisma.run.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Runs and only return the `id`
     * const runWithIdOnly = await prisma.run.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RunUpdateManyAndReturnArgs>(args: SelectSubset<T, RunUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Run.
     * @param {RunUpsertArgs} args - Arguments to update or create a Run.
     * @example
     * // Update or create a Run
     * const run = await prisma.run.upsert({
     *   create: {
     *     // ... data to create a Run
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Run we want to update
     *   }
     * })
     */
    upsert<T extends RunUpsertArgs>(args: SelectSubset<T, RunUpsertArgs<ExtArgs>>): Prisma__RunClient<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Runs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunCountArgs} args - Arguments to filter Runs to count.
     * @example
     * // Count the number of Runs
     * const count = await prisma.run.count({
     *   where: {
     *     // ... the filter for the Runs we want to count
     *   }
     * })
    **/
    count<T extends RunCountArgs>(
      args?: Subset<T, RunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Run.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RunAggregateArgs>(args: Subset<T, RunAggregateArgs>): Prisma.PrismaPromise<GetRunAggregateType<T>>

    /**
     * Group by Run.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RunGroupByArgs['orderBy'] }
        : { orderBy?: RunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Run model
   */
  readonly fields: RunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Run.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Thread<T extends ThreadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ThreadDefaultArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    ThreadMessage<T extends Run$ThreadMessageArgs<ExtArgs> = {}>(args?: Subset<T, Run$ThreadMessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadMessagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Usage<T extends Run$UsageArgs<ExtArgs> = {}>(args?: Subset<T, Run$UsageArgs<ExtArgs>>): Prisma__UsageClient<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Run model
   */ 
  interface RunFieldRefs {
    readonly id: FieldRef<"Run", 'String'>
    readonly created_at: FieldRef<"Run", 'DateTime'>
    readonly assistant_id: FieldRef<"Run", 'String'>
    readonly thread_id: FieldRef<"Run", 'String'>
    readonly status: FieldRef<"Run", 'String'>
    readonly started_at: FieldRef<"Run", 'DateTime'>
    readonly expires_at: FieldRef<"Run", 'DateTime'>
    readonly cancelled_at: FieldRef<"Run", 'DateTime'>
    readonly failed_at: FieldRef<"Run", 'DateTime'>
    readonly completed_at: FieldRef<"Run", 'DateTime'>
    readonly last_error: FieldRef<"Run", 'String'>
    readonly model: FieldRef<"Run", 'String'>
    readonly instructions: FieldRef<"Run", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Run findUnique
   */
  export type RunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
    /**
     * Filter, which Run to fetch.
     */
    where: RunWhereUniqueInput
  }

  /**
   * Run findUniqueOrThrow
   */
  export type RunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
    /**
     * Filter, which Run to fetch.
     */
    where: RunWhereUniqueInput
  }

  /**
   * Run findFirst
   */
  export type RunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
    /**
     * Filter, which Run to fetch.
     */
    where?: RunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Runs to fetch.
     */
    orderBy?: RunOrderByWithRelationInput | RunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Runs.
     */
    cursor?: RunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Runs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Runs.
     */
    distinct?: RunScalarFieldEnum | RunScalarFieldEnum[]
  }

  /**
   * Run findFirstOrThrow
   */
  export type RunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
    /**
     * Filter, which Run to fetch.
     */
    where?: RunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Runs to fetch.
     */
    orderBy?: RunOrderByWithRelationInput | RunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Runs.
     */
    cursor?: RunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Runs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Runs.
     */
    distinct?: RunScalarFieldEnum | RunScalarFieldEnum[]
  }

  /**
   * Run findMany
   */
  export type RunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
    /**
     * Filter, which Runs to fetch.
     */
    where?: RunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Runs to fetch.
     */
    orderBy?: RunOrderByWithRelationInput | RunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Runs.
     */
    cursor?: RunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Runs.
     */
    skip?: number
    distinct?: RunScalarFieldEnum | RunScalarFieldEnum[]
  }

  /**
   * Run create
   */
  export type RunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
    /**
     * The data needed to create a Run.
     */
    data: XOR<RunCreateInput, RunUncheckedCreateInput>
  }

  /**
   * Run createMany
   */
  export type RunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Runs.
     */
    data: RunCreateManyInput | RunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Run createManyAndReturn
   */
  export type RunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * The data used to create many Runs.
     */
    data: RunCreateManyInput | RunCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Run update
   */
  export type RunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
    /**
     * The data needed to update a Run.
     */
    data: XOR<RunUpdateInput, RunUncheckedUpdateInput>
    /**
     * Choose, which Run to update.
     */
    where: RunWhereUniqueInput
  }

  /**
   * Run updateMany
   */
  export type RunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Runs.
     */
    data: XOR<RunUpdateManyMutationInput, RunUncheckedUpdateManyInput>
    /**
     * Filter which Runs to update
     */
    where?: RunWhereInput
    /**
     * Limit how many Runs to update.
     */
    limit?: number
  }

  /**
   * Run updateManyAndReturn
   */
  export type RunUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * The data used to update Runs.
     */
    data: XOR<RunUpdateManyMutationInput, RunUncheckedUpdateManyInput>
    /**
     * Filter which Runs to update
     */
    where?: RunWhereInput
    /**
     * Limit how many Runs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Run upsert
   */
  export type RunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
    /**
     * The filter to search for the Run to update in case it exists.
     */
    where: RunWhereUniqueInput
    /**
     * In case the Run found by the `where` argument doesn't exist, create a new Run with this data.
     */
    create: XOR<RunCreateInput, RunUncheckedCreateInput>
    /**
     * In case the Run was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RunUpdateInput, RunUncheckedUpdateInput>
  }

  /**
   * Run delete
   */
  export type RunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
    /**
     * Filter which Run to delete.
     */
    where: RunWhereUniqueInput
  }

  /**
   * Run deleteMany
   */
  export type RunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Runs to delete
     */
    where?: RunWhereInput
    /**
     * Limit how many Runs to delete.
     */
    limit?: number
  }

  /**
   * Run.ThreadMessage
   */
  export type Run$ThreadMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadMessage
     */
    select?: ThreadMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadMessage
     */
    omit?: ThreadMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadMessageInclude<ExtArgs> | null
    where?: ThreadMessageWhereInput
    orderBy?: ThreadMessageOrderByWithRelationInput | ThreadMessageOrderByWithRelationInput[]
    cursor?: ThreadMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ThreadMessageScalarFieldEnum | ThreadMessageScalarFieldEnum[]
  }

  /**
   * Run.Usage
   */
  export type Run$UsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usage
     */
    omit?: UsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
    where?: UsageWhereInput
  }

  /**
   * Run without action
   */
  export type RunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    id: number | null
    organization_id: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: number | null
    organization_id: number | null
    stripe_subscription_id: string | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: number | null
    organization_id: number | null
    stripe_subscription_id: string | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    organization_id: number
    stripe_subscription_id: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    id?: true
    organization_id?: true
  }

  export type SubscriptionSumAggregateInputType = {
    id?: true
    organization_id?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    organization_id?: true
    stripe_subscription_id?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    organization_id?: true
    stripe_subscription_id?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    organization_id?: true
    stripe_subscription_id?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: number
    organization_id: number
    stripe_subscription_id: string
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    stripe_subscription_id?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    stripe_subscription_id?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    stripe_subscription_id?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    organization_id?: boolean
    stripe_subscription_id?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organization_id" | "stripe_subscription_id", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      Organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      organization_id: number
      stripe_subscription_id: string
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'Int'>
    readonly organization_id: FieldRef<"Subscription", 'Int'>
    readonly stripe_subscription_id: FieldRef<"Subscription", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Template
   */

  export type AggregateTemplate = {
    _count: TemplateCountAggregateOutputType | null
    _avg: TemplateAvgAggregateOutputType | null
    _sum: TemplateSumAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  export type TemplateAvgAggregateOutputType = {
    id: number | null
    collection_id: number | null
  }

  export type TemplateSumAggregateOutputType = {
    id: number | null
    collection_id: number | null
  }

  export type TemplateMinAggregateOutputType = {
    id: number | null
    name: string | null
    collection_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TemplateMaxAggregateOutputType = {
    id: number | null
    name: string | null
    collection_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TemplateCountAggregateOutputType = {
    id: number
    name: number
    collection_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TemplateAvgAggregateInputType = {
    id?: true
    collection_id?: true
  }

  export type TemplateSumAggregateInputType = {
    id?: true
    collection_id?: true
  }

  export type TemplateMinAggregateInputType = {
    id?: true
    name?: true
    collection_id?: true
    created_at?: true
    updated_at?: true
  }

  export type TemplateMaxAggregateInputType = {
    id?: true
    name?: true
    collection_id?: true
    created_at?: true
    updated_at?: true
  }

  export type TemplateCountAggregateInputType = {
    id?: true
    name?: true
    collection_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Template to aggregate.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Templates
    **/
    _count?: true | TemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateMaxAggregateInputType
  }

  export type GetTemplateAggregateType<T extends TemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplate[P]>
      : GetScalarType<T[P], AggregateTemplate[P]>
  }




  export type TemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateWhereInput
    orderBy?: TemplateOrderByWithAggregationInput | TemplateOrderByWithAggregationInput[]
    by: TemplateScalarFieldEnum[] | TemplateScalarFieldEnum
    having?: TemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateCountAggregateInputType | true
    _avg?: TemplateAvgAggregateInputType
    _sum?: TemplateSumAggregateInputType
    _min?: TemplateMinAggregateInputType
    _max?: TemplateMaxAggregateInputType
  }

  export type TemplateGroupByOutputType = {
    id: number
    name: string
    collection_id: number
    created_at: Date
    updated_at: Date
    _count: TemplateCountAggregateOutputType | null
    _avg: TemplateAvgAggregateOutputType | null
    _sum: TemplateSumAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  type GetTemplateGroupByPayload<T extends TemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateGroupByOutputType[P]>
        }
      >
    >


  export type TemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    collection_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    Field?: boolean | Template$FieldArgs<ExtArgs>
    Collection?: boolean | CollectionDefaultArgs<ExtArgs>
    TemplateInstance?: boolean | Template$TemplateInstanceArgs<ExtArgs>
    _count?: boolean | TemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["template"]>

  export type TemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    collection_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    Collection?: boolean | CollectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["template"]>

  export type TemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    collection_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    Collection?: boolean | CollectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["template"]>

  export type TemplateSelectScalar = {
    id?: boolean
    name?: boolean
    collection_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "collection_id" | "created_at" | "updated_at", ExtArgs["result"]["template"]>
  export type TemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Field?: boolean | Template$FieldArgs<ExtArgs>
    Collection?: boolean | CollectionDefaultArgs<ExtArgs>
    TemplateInstance?: boolean | Template$TemplateInstanceArgs<ExtArgs>
    _count?: boolean | TemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Collection?: boolean | CollectionDefaultArgs<ExtArgs>
  }
  export type TemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Collection?: boolean | CollectionDefaultArgs<ExtArgs>
  }

  export type $TemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Template"
    objects: {
      Field: Prisma.$FieldPayload<ExtArgs>[]
      Collection: Prisma.$CollectionPayload<ExtArgs>
      TemplateInstance: Prisma.$TemplateInstancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      collection_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["template"]>
    composites: {}
  }

  type TemplateGetPayload<S extends boolean | null | undefined | TemplateDefaultArgs> = $Result.GetResult<Prisma.$TemplatePayload, S>

  type TemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TemplateCountAggregateInputType | true
    }

  export interface TemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'Template' } }
    /**
     * Find zero or one Template that matches the filter.
     * @param {TemplateFindUniqueArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateFindUniqueArgs>(args: SelectSubset<T, TemplateFindUniqueArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Template that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TemplateFindUniqueOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Template that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateFindFirstArgs>(args?: SelectSubset<T, TemplateFindFirstArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Template that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Templates
     * const templates = await prisma.template.findMany()
     * 
     * // Get first 10 Templates
     * const templates = await prisma.template.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateWithIdOnly = await prisma.template.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateFindManyArgs>(args?: SelectSubset<T, TemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Template.
     * @param {TemplateCreateArgs} args - Arguments to create a Template.
     * @example
     * // Create one Template
     * const Template = await prisma.template.create({
     *   data: {
     *     // ... data to create a Template
     *   }
     * })
     * 
     */
    create<T extends TemplateCreateArgs>(args: SelectSubset<T, TemplateCreateArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Templates.
     * @param {TemplateCreateManyArgs} args - Arguments to create many Templates.
     * @example
     * // Create many Templates
     * const template = await prisma.template.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateCreateManyArgs>(args?: SelectSubset<T, TemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Templates and returns the data saved in the database.
     * @param {TemplateCreateManyAndReturnArgs} args - Arguments to create many Templates.
     * @example
     * // Create many Templates
     * const template = await prisma.template.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Templates and only return the `id`
     * const templateWithIdOnly = await prisma.template.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Template.
     * @param {TemplateDeleteArgs} args - Arguments to delete one Template.
     * @example
     * // Delete one Template
     * const Template = await prisma.template.delete({
     *   where: {
     *     // ... filter to delete one Template
     *   }
     * })
     * 
     */
    delete<T extends TemplateDeleteArgs>(args: SelectSubset<T, TemplateDeleteArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Template.
     * @param {TemplateUpdateArgs} args - Arguments to update one Template.
     * @example
     * // Update one Template
     * const template = await prisma.template.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateUpdateArgs>(args: SelectSubset<T, TemplateUpdateArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Templates.
     * @param {TemplateDeleteManyArgs} args - Arguments to filter Templates to delete.
     * @example
     * // Delete a few Templates
     * const { count } = await prisma.template.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateDeleteManyArgs>(args?: SelectSubset<T, TemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Templates
     * const template = await prisma.template.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateUpdateManyArgs>(args: SelectSubset<T, TemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Templates and returns the data updated in the database.
     * @param {TemplateUpdateManyAndReturnArgs} args - Arguments to update many Templates.
     * @example
     * // Update many Templates
     * const template = await prisma.template.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Templates and only return the `id`
     * const templateWithIdOnly = await prisma.template.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, TemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Template.
     * @param {TemplateUpsertArgs} args - Arguments to update or create a Template.
     * @example
     * // Update or create a Template
     * const template = await prisma.template.upsert({
     *   create: {
     *     // ... data to create a Template
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Template we want to update
     *   }
     * })
     */
    upsert<T extends TemplateUpsertArgs>(args: SelectSubset<T, TemplateUpsertArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateCountArgs} args - Arguments to filter Templates to count.
     * @example
     * // Count the number of Templates
     * const count = await prisma.template.count({
     *   where: {
     *     // ... the filter for the Templates we want to count
     *   }
     * })
    **/
    count<T extends TemplateCountArgs>(
      args?: Subset<T, TemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateAggregateArgs>(args: Subset<T, TemplateAggregateArgs>): Prisma.PrismaPromise<GetTemplateAggregateType<T>>

    /**
     * Group by Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateGroupByArgs['orderBy'] }
        : { orderBy?: TemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Template model
   */
  readonly fields: TemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Template.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Field<T extends Template$FieldArgs<ExtArgs> = {}>(args?: Subset<T, Template$FieldArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Collection<T extends CollectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionDefaultArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TemplateInstance<T extends Template$TemplateInstanceArgs<ExtArgs> = {}>(args?: Subset<T, Template$TemplateInstanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateInstancePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Template model
   */ 
  interface TemplateFieldRefs {
    readonly id: FieldRef<"Template", 'Int'>
    readonly name: FieldRef<"Template", 'String'>
    readonly collection_id: FieldRef<"Template", 'Int'>
    readonly created_at: FieldRef<"Template", 'DateTime'>
    readonly updated_at: FieldRef<"Template", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Template findUnique
   */
  export type TemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template findUniqueOrThrow
   */
  export type TemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template findFirst
   */
  export type TemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template findFirstOrThrow
   */
  export type TemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template findMany
   */
  export type TemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Templates to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template create
   */
  export type TemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a Template.
     */
    data: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
  }

  /**
   * Template createMany
   */
  export type TemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Templates.
     */
    data: TemplateCreateManyInput | TemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Template createManyAndReturn
   */
  export type TemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * The data used to create many Templates.
     */
    data: TemplateCreateManyInput | TemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Template update
   */
  export type TemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a Template.
     */
    data: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
    /**
     * Choose, which Template to update.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template updateMany
   */
  export type TemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Templates.
     */
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyInput>
    /**
     * Filter which Templates to update
     */
    where?: TemplateWhereInput
    /**
     * Limit how many Templates to update.
     */
    limit?: number
  }

  /**
   * Template updateManyAndReturn
   */
  export type TemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * The data used to update Templates.
     */
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyInput>
    /**
     * Filter which Templates to update
     */
    where?: TemplateWhereInput
    /**
     * Limit how many Templates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Template upsert
   */
  export type TemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the Template to update in case it exists.
     */
    where: TemplateWhereUniqueInput
    /**
     * In case the Template found by the `where` argument doesn't exist, create a new Template with this data.
     */
    create: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
    /**
     * In case the Template was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
  }

  /**
   * Template delete
   */
  export type TemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter which Template to delete.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template deleteMany
   */
  export type TemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Templates to delete
     */
    where?: TemplateWhereInput
    /**
     * Limit how many Templates to delete.
     */
    limit?: number
  }

  /**
   * Template.Field
   */
  export type Template$FieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    where?: FieldWhereInput
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    cursor?: FieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldScalarFieldEnum | FieldScalarFieldEnum[]
  }

  /**
   * Template.TemplateInstance
   */
  export type Template$TemplateInstanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateInstance
     */
    select?: TemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateInstance
     */
    omit?: TemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInstanceInclude<ExtArgs> | null
    where?: TemplateInstanceWhereInput
    orderBy?: TemplateInstanceOrderByWithRelationInput | TemplateInstanceOrderByWithRelationInput[]
    cursor?: TemplateInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateInstanceScalarFieldEnum | TemplateInstanceScalarFieldEnum[]
  }

  /**
   * Template without action
   */
  export type TemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
  }


  /**
   * Model TemplateInstance
   */

  export type AggregateTemplateInstance = {
    _count: TemplateInstanceCountAggregateOutputType | null
    _avg: TemplateInstanceAvgAggregateOutputType | null
    _sum: TemplateInstanceSumAggregateOutputType | null
    _min: TemplateInstanceMinAggregateOutputType | null
    _max: TemplateInstanceMaxAggregateOutputType | null
  }

  export type TemplateInstanceAvgAggregateOutputType = {
    id: number | null
    templateId: number | null
  }

  export type TemplateInstanceSumAggregateOutputType = {
    id: number | null
    templateId: number | null
  }

  export type TemplateInstanceMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    title: string | null
    templateId: number | null
  }

  export type TemplateInstanceMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    title: string | null
    templateId: number | null
  }

  export type TemplateInstanceCountAggregateOutputType = {
    id: number
    values: number
    created_at: number
    updated_at: number
    title: number
    templateId: number
    _all: number
  }


  export type TemplateInstanceAvgAggregateInputType = {
    id?: true
    templateId?: true
  }

  export type TemplateInstanceSumAggregateInputType = {
    id?: true
    templateId?: true
  }

  export type TemplateInstanceMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    title?: true
    templateId?: true
  }

  export type TemplateInstanceMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    title?: true
    templateId?: true
  }

  export type TemplateInstanceCountAggregateInputType = {
    id?: true
    values?: true
    created_at?: true
    updated_at?: true
    title?: true
    templateId?: true
    _all?: true
  }

  export type TemplateInstanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateInstance to aggregate.
     */
    where?: TemplateInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateInstances to fetch.
     */
    orderBy?: TemplateInstanceOrderByWithRelationInput | TemplateInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateInstances
    **/
    _count?: true | TemplateInstanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateInstanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateInstanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateInstanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateInstanceMaxAggregateInputType
  }

  export type GetTemplateInstanceAggregateType<T extends TemplateInstanceAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateInstance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateInstance[P]>
      : GetScalarType<T[P], AggregateTemplateInstance[P]>
  }




  export type TemplateInstanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateInstanceWhereInput
    orderBy?: TemplateInstanceOrderByWithAggregationInput | TemplateInstanceOrderByWithAggregationInput[]
    by: TemplateInstanceScalarFieldEnum[] | TemplateInstanceScalarFieldEnum
    having?: TemplateInstanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateInstanceCountAggregateInputType | true
    _avg?: TemplateInstanceAvgAggregateInputType
    _sum?: TemplateInstanceSumAggregateInputType
    _min?: TemplateInstanceMinAggregateInputType
    _max?: TemplateInstanceMaxAggregateInputType
  }

  export type TemplateInstanceGroupByOutputType = {
    id: number
    values: JsonValue
    created_at: Date
    updated_at: Date
    title: string
    templateId: number
    _count: TemplateInstanceCountAggregateOutputType | null
    _avg: TemplateInstanceAvgAggregateOutputType | null
    _sum: TemplateInstanceSumAggregateOutputType | null
    _min: TemplateInstanceMinAggregateOutputType | null
    _max: TemplateInstanceMaxAggregateOutputType | null
  }

  type GetTemplateInstanceGroupByPayload<T extends TemplateInstanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateInstanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateInstanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateInstanceGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateInstanceGroupByOutputType[P]>
        }
      >
    >


  export type TemplateInstanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    values?: boolean
    created_at?: boolean
    updated_at?: boolean
    title?: boolean
    templateId?: boolean
    ContentTemplateInstance?: boolean | TemplateInstance$ContentTemplateInstanceArgs<ExtArgs>
    Template?: boolean | TemplateDefaultArgs<ExtArgs>
    _count?: boolean | TemplateInstanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateInstance"]>

  export type TemplateInstanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    values?: boolean
    created_at?: boolean
    updated_at?: boolean
    title?: boolean
    templateId?: boolean
    Template?: boolean | TemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateInstance"]>

  export type TemplateInstanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    values?: boolean
    created_at?: boolean
    updated_at?: boolean
    title?: boolean
    templateId?: boolean
    Template?: boolean | TemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateInstance"]>

  export type TemplateInstanceSelectScalar = {
    id?: boolean
    values?: boolean
    created_at?: boolean
    updated_at?: boolean
    title?: boolean
    templateId?: boolean
  }

  export type TemplateInstanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "values" | "created_at" | "updated_at" | "title" | "templateId", ExtArgs["result"]["templateInstance"]>
  export type TemplateInstanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ContentTemplateInstance?: boolean | TemplateInstance$ContentTemplateInstanceArgs<ExtArgs>
    Template?: boolean | TemplateDefaultArgs<ExtArgs>
    _count?: boolean | TemplateInstanceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TemplateInstanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Template?: boolean | TemplateDefaultArgs<ExtArgs>
  }
  export type TemplateInstanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Template?: boolean | TemplateDefaultArgs<ExtArgs>
  }

  export type $TemplateInstancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemplateInstance"
    objects: {
      ContentTemplateInstance: Prisma.$ContentTemplateInstancePayload<ExtArgs>[]
      Template: Prisma.$TemplatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      values: Prisma.JsonValue
      created_at: Date
      updated_at: Date
      title: string
      templateId: number
    }, ExtArgs["result"]["templateInstance"]>
    composites: {}
  }

  type TemplateInstanceGetPayload<S extends boolean | null | undefined | TemplateInstanceDefaultArgs> = $Result.GetResult<Prisma.$TemplateInstancePayload, S>

  type TemplateInstanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TemplateInstanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TemplateInstanceCountAggregateInputType | true
    }

  export interface TemplateInstanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'TemplateInstance' } }
    /**
     * Find zero or one TemplateInstance that matches the filter.
     * @param {TemplateInstanceFindUniqueArgs} args - Arguments to find a TemplateInstance
     * @example
     * // Get one TemplateInstance
     * const templateInstance = await prisma.templateInstance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateInstanceFindUniqueArgs>(args: SelectSubset<T, TemplateInstanceFindUniqueArgs<ExtArgs>>): Prisma__TemplateInstanceClient<$Result.GetResult<Prisma.$TemplateInstancePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TemplateInstance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TemplateInstanceFindUniqueOrThrowArgs} args - Arguments to find a TemplateInstance
     * @example
     * // Get one TemplateInstance
     * const templateInstance = await prisma.templateInstance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateInstanceFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateInstanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateInstanceClient<$Result.GetResult<Prisma.$TemplateInstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TemplateInstance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateInstanceFindFirstArgs} args - Arguments to find a TemplateInstance
     * @example
     * // Get one TemplateInstance
     * const templateInstance = await prisma.templateInstance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateInstanceFindFirstArgs>(args?: SelectSubset<T, TemplateInstanceFindFirstArgs<ExtArgs>>): Prisma__TemplateInstanceClient<$Result.GetResult<Prisma.$TemplateInstancePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TemplateInstance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateInstanceFindFirstOrThrowArgs} args - Arguments to find a TemplateInstance
     * @example
     * // Get one TemplateInstance
     * const templateInstance = await prisma.templateInstance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateInstanceFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateInstanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateInstanceClient<$Result.GetResult<Prisma.$TemplateInstancePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TemplateInstances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateInstanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateInstances
     * const templateInstances = await prisma.templateInstance.findMany()
     * 
     * // Get first 10 TemplateInstances
     * const templateInstances = await prisma.templateInstance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateInstanceWithIdOnly = await prisma.templateInstance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateInstanceFindManyArgs>(args?: SelectSubset<T, TemplateInstanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateInstancePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TemplateInstance.
     * @param {TemplateInstanceCreateArgs} args - Arguments to create a TemplateInstance.
     * @example
     * // Create one TemplateInstance
     * const TemplateInstance = await prisma.templateInstance.create({
     *   data: {
     *     // ... data to create a TemplateInstance
     *   }
     * })
     * 
     */
    create<T extends TemplateInstanceCreateArgs>(args: SelectSubset<T, TemplateInstanceCreateArgs<ExtArgs>>): Prisma__TemplateInstanceClient<$Result.GetResult<Prisma.$TemplateInstancePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TemplateInstances.
     * @param {TemplateInstanceCreateManyArgs} args - Arguments to create many TemplateInstances.
     * @example
     * // Create many TemplateInstances
     * const templateInstance = await prisma.templateInstance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateInstanceCreateManyArgs>(args?: SelectSubset<T, TemplateInstanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TemplateInstances and returns the data saved in the database.
     * @param {TemplateInstanceCreateManyAndReturnArgs} args - Arguments to create many TemplateInstances.
     * @example
     * // Create many TemplateInstances
     * const templateInstance = await prisma.templateInstance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TemplateInstances and only return the `id`
     * const templateInstanceWithIdOnly = await prisma.templateInstance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplateInstanceCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplateInstanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateInstancePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a TemplateInstance.
     * @param {TemplateInstanceDeleteArgs} args - Arguments to delete one TemplateInstance.
     * @example
     * // Delete one TemplateInstance
     * const TemplateInstance = await prisma.templateInstance.delete({
     *   where: {
     *     // ... filter to delete one TemplateInstance
     *   }
     * })
     * 
     */
    delete<T extends TemplateInstanceDeleteArgs>(args: SelectSubset<T, TemplateInstanceDeleteArgs<ExtArgs>>): Prisma__TemplateInstanceClient<$Result.GetResult<Prisma.$TemplateInstancePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TemplateInstance.
     * @param {TemplateInstanceUpdateArgs} args - Arguments to update one TemplateInstance.
     * @example
     * // Update one TemplateInstance
     * const templateInstance = await prisma.templateInstance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateInstanceUpdateArgs>(args: SelectSubset<T, TemplateInstanceUpdateArgs<ExtArgs>>): Prisma__TemplateInstanceClient<$Result.GetResult<Prisma.$TemplateInstancePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TemplateInstances.
     * @param {TemplateInstanceDeleteManyArgs} args - Arguments to filter TemplateInstances to delete.
     * @example
     * // Delete a few TemplateInstances
     * const { count } = await prisma.templateInstance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateInstanceDeleteManyArgs>(args?: SelectSubset<T, TemplateInstanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateInstanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateInstances
     * const templateInstance = await prisma.templateInstance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateInstanceUpdateManyArgs>(args: SelectSubset<T, TemplateInstanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateInstances and returns the data updated in the database.
     * @param {TemplateInstanceUpdateManyAndReturnArgs} args - Arguments to update many TemplateInstances.
     * @example
     * // Update many TemplateInstances
     * const templateInstance = await prisma.templateInstance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TemplateInstances and only return the `id`
     * const templateInstanceWithIdOnly = await prisma.templateInstance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TemplateInstanceUpdateManyAndReturnArgs>(args: SelectSubset<T, TemplateInstanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateInstancePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one TemplateInstance.
     * @param {TemplateInstanceUpsertArgs} args - Arguments to update or create a TemplateInstance.
     * @example
     * // Update or create a TemplateInstance
     * const templateInstance = await prisma.templateInstance.upsert({
     *   create: {
     *     // ... data to create a TemplateInstance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateInstance we want to update
     *   }
     * })
     */
    upsert<T extends TemplateInstanceUpsertArgs>(args: SelectSubset<T, TemplateInstanceUpsertArgs<ExtArgs>>): Prisma__TemplateInstanceClient<$Result.GetResult<Prisma.$TemplateInstancePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TemplateInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateInstanceCountArgs} args - Arguments to filter TemplateInstances to count.
     * @example
     * // Count the number of TemplateInstances
     * const count = await prisma.templateInstance.count({
     *   where: {
     *     // ... the filter for the TemplateInstances we want to count
     *   }
     * })
    **/
    count<T extends TemplateInstanceCountArgs>(
      args?: Subset<T, TemplateInstanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateInstanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateInstanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateInstanceAggregateArgs>(args: Subset<T, TemplateInstanceAggregateArgs>): Prisma.PrismaPromise<GetTemplateInstanceAggregateType<T>>

    /**
     * Group by TemplateInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateInstanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateInstanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateInstanceGroupByArgs['orderBy'] }
        : { orderBy?: TemplateInstanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateInstanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateInstanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplateInstance model
   */
  readonly fields: TemplateInstanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateInstance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateInstanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ContentTemplateInstance<T extends TemplateInstance$ContentTemplateInstanceArgs<ExtArgs> = {}>(args?: Subset<T, TemplateInstance$ContentTemplateInstanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTemplateInstancePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Template<T extends TemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TemplateDefaultArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TemplateInstance model
   */ 
  interface TemplateInstanceFieldRefs {
    readonly id: FieldRef<"TemplateInstance", 'Int'>
    readonly values: FieldRef<"TemplateInstance", 'Json'>
    readonly created_at: FieldRef<"TemplateInstance", 'DateTime'>
    readonly updated_at: FieldRef<"TemplateInstance", 'DateTime'>
    readonly title: FieldRef<"TemplateInstance", 'String'>
    readonly templateId: FieldRef<"TemplateInstance", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TemplateInstance findUnique
   */
  export type TemplateInstanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateInstance
     */
    select?: TemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateInstance
     */
    omit?: TemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInstanceInclude<ExtArgs> | null
    /**
     * Filter, which TemplateInstance to fetch.
     */
    where: TemplateInstanceWhereUniqueInput
  }

  /**
   * TemplateInstance findUniqueOrThrow
   */
  export type TemplateInstanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateInstance
     */
    select?: TemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateInstance
     */
    omit?: TemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInstanceInclude<ExtArgs> | null
    /**
     * Filter, which TemplateInstance to fetch.
     */
    where: TemplateInstanceWhereUniqueInput
  }

  /**
   * TemplateInstance findFirst
   */
  export type TemplateInstanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateInstance
     */
    select?: TemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateInstance
     */
    omit?: TemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInstanceInclude<ExtArgs> | null
    /**
     * Filter, which TemplateInstance to fetch.
     */
    where?: TemplateInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateInstances to fetch.
     */
    orderBy?: TemplateInstanceOrderByWithRelationInput | TemplateInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateInstances.
     */
    cursor?: TemplateInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateInstances.
     */
    distinct?: TemplateInstanceScalarFieldEnum | TemplateInstanceScalarFieldEnum[]
  }

  /**
   * TemplateInstance findFirstOrThrow
   */
  export type TemplateInstanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateInstance
     */
    select?: TemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateInstance
     */
    omit?: TemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInstanceInclude<ExtArgs> | null
    /**
     * Filter, which TemplateInstance to fetch.
     */
    where?: TemplateInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateInstances to fetch.
     */
    orderBy?: TemplateInstanceOrderByWithRelationInput | TemplateInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateInstances.
     */
    cursor?: TemplateInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateInstances.
     */
    distinct?: TemplateInstanceScalarFieldEnum | TemplateInstanceScalarFieldEnum[]
  }

  /**
   * TemplateInstance findMany
   */
  export type TemplateInstanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateInstance
     */
    select?: TemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateInstance
     */
    omit?: TemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInstanceInclude<ExtArgs> | null
    /**
     * Filter, which TemplateInstances to fetch.
     */
    where?: TemplateInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateInstances to fetch.
     */
    orderBy?: TemplateInstanceOrderByWithRelationInput | TemplateInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateInstances.
     */
    cursor?: TemplateInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateInstances.
     */
    skip?: number
    distinct?: TemplateInstanceScalarFieldEnum | TemplateInstanceScalarFieldEnum[]
  }

  /**
   * TemplateInstance create
   */
  export type TemplateInstanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateInstance
     */
    select?: TemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateInstance
     */
    omit?: TemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInstanceInclude<ExtArgs> | null
    /**
     * The data needed to create a TemplateInstance.
     */
    data: XOR<TemplateInstanceCreateInput, TemplateInstanceUncheckedCreateInput>
  }

  /**
   * TemplateInstance createMany
   */
  export type TemplateInstanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TemplateInstances.
     */
    data: TemplateInstanceCreateManyInput | TemplateInstanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateInstance createManyAndReturn
   */
  export type TemplateInstanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateInstance
     */
    select?: TemplateInstanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateInstance
     */
    omit?: TemplateInstanceOmit<ExtArgs> | null
    /**
     * The data used to create many TemplateInstances.
     */
    data: TemplateInstanceCreateManyInput | TemplateInstanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInstanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TemplateInstance update
   */
  export type TemplateInstanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateInstance
     */
    select?: TemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateInstance
     */
    omit?: TemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInstanceInclude<ExtArgs> | null
    /**
     * The data needed to update a TemplateInstance.
     */
    data: XOR<TemplateInstanceUpdateInput, TemplateInstanceUncheckedUpdateInput>
    /**
     * Choose, which TemplateInstance to update.
     */
    where: TemplateInstanceWhereUniqueInput
  }

  /**
   * TemplateInstance updateMany
   */
  export type TemplateInstanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplateInstances.
     */
    data: XOR<TemplateInstanceUpdateManyMutationInput, TemplateInstanceUncheckedUpdateManyInput>
    /**
     * Filter which TemplateInstances to update
     */
    where?: TemplateInstanceWhereInput
    /**
     * Limit how many TemplateInstances to update.
     */
    limit?: number
  }

  /**
   * TemplateInstance updateManyAndReturn
   */
  export type TemplateInstanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateInstance
     */
    select?: TemplateInstanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateInstance
     */
    omit?: TemplateInstanceOmit<ExtArgs> | null
    /**
     * The data used to update TemplateInstances.
     */
    data: XOR<TemplateInstanceUpdateManyMutationInput, TemplateInstanceUncheckedUpdateManyInput>
    /**
     * Filter which TemplateInstances to update
     */
    where?: TemplateInstanceWhereInput
    /**
     * Limit how many TemplateInstances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInstanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TemplateInstance upsert
   */
  export type TemplateInstanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateInstance
     */
    select?: TemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateInstance
     */
    omit?: TemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInstanceInclude<ExtArgs> | null
    /**
     * The filter to search for the TemplateInstance to update in case it exists.
     */
    where: TemplateInstanceWhereUniqueInput
    /**
     * In case the TemplateInstance found by the `where` argument doesn't exist, create a new TemplateInstance with this data.
     */
    create: XOR<TemplateInstanceCreateInput, TemplateInstanceUncheckedCreateInput>
    /**
     * In case the TemplateInstance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateInstanceUpdateInput, TemplateInstanceUncheckedUpdateInput>
  }

  /**
   * TemplateInstance delete
   */
  export type TemplateInstanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateInstance
     */
    select?: TemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateInstance
     */
    omit?: TemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInstanceInclude<ExtArgs> | null
    /**
     * Filter which TemplateInstance to delete.
     */
    where: TemplateInstanceWhereUniqueInput
  }

  /**
   * TemplateInstance deleteMany
   */
  export type TemplateInstanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateInstances to delete
     */
    where?: TemplateInstanceWhereInput
    /**
     * Limit how many TemplateInstances to delete.
     */
    limit?: number
  }

  /**
   * TemplateInstance.ContentTemplateInstance
   */
  export type TemplateInstance$ContentTemplateInstanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTemplateInstance
     */
    select?: ContentTemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentTemplateInstance
     */
    omit?: ContentTemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTemplateInstanceInclude<ExtArgs> | null
    where?: ContentTemplateInstanceWhereInput
    orderBy?: ContentTemplateInstanceOrderByWithRelationInput | ContentTemplateInstanceOrderByWithRelationInput[]
    cursor?: ContentTemplateInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentTemplateInstanceScalarFieldEnum | ContentTemplateInstanceScalarFieldEnum[]
  }

  /**
   * TemplateInstance without action
   */
  export type TemplateInstanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateInstance
     */
    select?: TemplateInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateInstance
     */
    omit?: TemplateInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInstanceInclude<ExtArgs> | null
  }


  /**
   * Model Thread
   */

  export type AggregateThread = {
    _count: ThreadCountAggregateOutputType | null
    _avg: ThreadAvgAggregateOutputType | null
    _sum: ThreadSumAggregateOutputType | null
    _min: ThreadMinAggregateOutputType | null
    _max: ThreadMaxAggregateOutputType | null
  }

  export type ThreadAvgAggregateOutputType = {
    organization_id: number | null
  }

  export type ThreadSumAggregateOutputType = {
    organization_id: number | null
  }

  export type ThreadMinAggregateOutputType = {
    thread_id: string | null
    title: string | null
    created_at: Date | null
    updated_at: Date | null
    organization_id: number | null
    should_hide_thread: boolean | null
  }

  export type ThreadMaxAggregateOutputType = {
    thread_id: string | null
    title: string | null
    created_at: Date | null
    updated_at: Date | null
    organization_id: number | null
    should_hide_thread: boolean | null
  }

  export type ThreadCountAggregateOutputType = {
    thread_id: number
    title: number
    created_at: number
    updated_at: number
    organization_id: number
    should_hide_thread: number
    _all: number
  }


  export type ThreadAvgAggregateInputType = {
    organization_id?: true
  }

  export type ThreadSumAggregateInputType = {
    organization_id?: true
  }

  export type ThreadMinAggregateInputType = {
    thread_id?: true
    title?: true
    created_at?: true
    updated_at?: true
    organization_id?: true
    should_hide_thread?: true
  }

  export type ThreadMaxAggregateInputType = {
    thread_id?: true
    title?: true
    created_at?: true
    updated_at?: true
    organization_id?: true
    should_hide_thread?: true
  }

  export type ThreadCountAggregateInputType = {
    thread_id?: true
    title?: true
    created_at?: true
    updated_at?: true
    organization_id?: true
    should_hide_thread?: true
    _all?: true
  }

  export type ThreadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Thread to aggregate.
     */
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     */
    orderBy?: ThreadOrderByWithRelationInput | ThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Threads
    **/
    _count?: true | ThreadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ThreadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ThreadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThreadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThreadMaxAggregateInputType
  }

  export type GetThreadAggregateType<T extends ThreadAggregateArgs> = {
        [P in keyof T & keyof AggregateThread]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThread[P]>
      : GetScalarType<T[P], AggregateThread[P]>
  }




  export type ThreadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThreadWhereInput
    orderBy?: ThreadOrderByWithAggregationInput | ThreadOrderByWithAggregationInput[]
    by: ThreadScalarFieldEnum[] | ThreadScalarFieldEnum
    having?: ThreadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThreadCountAggregateInputType | true
    _avg?: ThreadAvgAggregateInputType
    _sum?: ThreadSumAggregateInputType
    _min?: ThreadMinAggregateInputType
    _max?: ThreadMaxAggregateInputType
  }

  export type ThreadGroupByOutputType = {
    thread_id: string
    title: string
    created_at: Date
    updated_at: Date
    organization_id: number
    should_hide_thread: boolean
    _count: ThreadCountAggregateOutputType | null
    _avg: ThreadAvgAggregateOutputType | null
    _sum: ThreadSumAggregateOutputType | null
    _min: ThreadMinAggregateOutputType | null
    _max: ThreadMaxAggregateOutputType | null
  }

  type GetThreadGroupByPayload<T extends ThreadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThreadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThreadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadGroupByOutputType[P]>
        }
      >
    >


  export type ThreadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    thread_id?: boolean
    title?: boolean
    created_at?: boolean
    updated_at?: boolean
    organization_id?: boolean
    should_hide_thread?: boolean
    Run?: boolean | Thread$RunArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    ThreadMessage?: boolean | Thread$ThreadMessageArgs<ExtArgs>
    _count?: boolean | ThreadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["thread"]>

  export type ThreadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    thread_id?: boolean
    title?: boolean
    created_at?: boolean
    updated_at?: boolean
    organization_id?: boolean
    should_hide_thread?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["thread"]>

  export type ThreadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    thread_id?: boolean
    title?: boolean
    created_at?: boolean
    updated_at?: boolean
    organization_id?: boolean
    should_hide_thread?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["thread"]>

  export type ThreadSelectScalar = {
    thread_id?: boolean
    title?: boolean
    created_at?: boolean
    updated_at?: boolean
    organization_id?: boolean
    should_hide_thread?: boolean
  }

  export type ThreadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"thread_id" | "title" | "created_at" | "updated_at" | "organization_id" | "should_hide_thread", ExtArgs["result"]["thread"]>
  export type ThreadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Run?: boolean | Thread$RunArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    ThreadMessage?: boolean | Thread$ThreadMessageArgs<ExtArgs>
    _count?: boolean | ThreadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ThreadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type ThreadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $ThreadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Thread"
    objects: {
      Run: Prisma.$RunPayload<ExtArgs>[]
      Organization: Prisma.$OrganizationPayload<ExtArgs>
      ThreadMessage: Prisma.$ThreadMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      thread_id: string
      title: string
      created_at: Date
      updated_at: Date
      organization_id: number
      should_hide_thread: boolean
    }, ExtArgs["result"]["thread"]>
    composites: {}
  }

  type ThreadGetPayload<S extends boolean | null | undefined | ThreadDefaultArgs> = $Result.GetResult<Prisma.$ThreadPayload, S>

  type ThreadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ThreadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ThreadCountAggregateInputType | true
    }

  export interface ThreadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'Thread' } }
    /**
     * Find zero or one Thread that matches the filter.
     * @param {ThreadFindUniqueArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreadFindUniqueArgs>(args: SelectSubset<T, ThreadFindUniqueArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Thread that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThreadFindUniqueOrThrowArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreadFindUniqueOrThrowArgs>(args: SelectSubset<T, ThreadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Thread that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadFindFirstArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreadFindFirstArgs>(args?: SelectSubset<T, ThreadFindFirstArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Thread that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadFindFirstOrThrowArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreadFindFirstOrThrowArgs>(args?: SelectSubset<T, ThreadFindFirstOrThrowArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Threads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Threads
     * const threads = await prisma.thread.findMany()
     * 
     * // Get first 10 Threads
     * const threads = await prisma.thread.findMany({ take: 10 })
     * 
     * // Only select the `thread_id`
     * const threadWithThread_idOnly = await prisma.thread.findMany({ select: { thread_id: true } })
     * 
     */
    findMany<T extends ThreadFindManyArgs>(args?: SelectSubset<T, ThreadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Thread.
     * @param {ThreadCreateArgs} args - Arguments to create a Thread.
     * @example
     * // Create one Thread
     * const Thread = await prisma.thread.create({
     *   data: {
     *     // ... data to create a Thread
     *   }
     * })
     * 
     */
    create<T extends ThreadCreateArgs>(args: SelectSubset<T, ThreadCreateArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Threads.
     * @param {ThreadCreateManyArgs} args - Arguments to create many Threads.
     * @example
     * // Create many Threads
     * const thread = await prisma.thread.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ThreadCreateManyArgs>(args?: SelectSubset<T, ThreadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Threads and returns the data saved in the database.
     * @param {ThreadCreateManyAndReturnArgs} args - Arguments to create many Threads.
     * @example
     * // Create many Threads
     * const thread = await prisma.thread.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Threads and only return the `thread_id`
     * const threadWithThread_idOnly = await prisma.thread.createManyAndReturn({
     *   select: { thread_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ThreadCreateManyAndReturnArgs>(args?: SelectSubset<T, ThreadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Thread.
     * @param {ThreadDeleteArgs} args - Arguments to delete one Thread.
     * @example
     * // Delete one Thread
     * const Thread = await prisma.thread.delete({
     *   where: {
     *     // ... filter to delete one Thread
     *   }
     * })
     * 
     */
    delete<T extends ThreadDeleteArgs>(args: SelectSubset<T, ThreadDeleteArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Thread.
     * @param {ThreadUpdateArgs} args - Arguments to update one Thread.
     * @example
     * // Update one Thread
     * const thread = await prisma.thread.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ThreadUpdateArgs>(args: SelectSubset<T, ThreadUpdateArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Threads.
     * @param {ThreadDeleteManyArgs} args - Arguments to filter Threads to delete.
     * @example
     * // Delete a few Threads
     * const { count } = await prisma.thread.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ThreadDeleteManyArgs>(args?: SelectSubset<T, ThreadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Threads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Threads
     * const thread = await prisma.thread.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ThreadUpdateManyArgs>(args: SelectSubset<T, ThreadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Threads and returns the data updated in the database.
     * @param {ThreadUpdateManyAndReturnArgs} args - Arguments to update many Threads.
     * @example
     * // Update many Threads
     * const thread = await prisma.thread.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Threads and only return the `thread_id`
     * const threadWithThread_idOnly = await prisma.thread.updateManyAndReturn({
     *   select: { thread_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ThreadUpdateManyAndReturnArgs>(args: SelectSubset<T, ThreadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Thread.
     * @param {ThreadUpsertArgs} args - Arguments to update or create a Thread.
     * @example
     * // Update or create a Thread
     * const thread = await prisma.thread.upsert({
     *   create: {
     *     // ... data to create a Thread
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Thread we want to update
     *   }
     * })
     */
    upsert<T extends ThreadUpsertArgs>(args: SelectSubset<T, ThreadUpsertArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Threads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadCountArgs} args - Arguments to filter Threads to count.
     * @example
     * // Count the number of Threads
     * const count = await prisma.thread.count({
     *   where: {
     *     // ... the filter for the Threads we want to count
     *   }
     * })
    **/
    count<T extends ThreadCountArgs>(
      args?: Subset<T, ThreadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Thread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThreadAggregateArgs>(args: Subset<T, ThreadAggregateArgs>): Prisma.PrismaPromise<GetThreadAggregateType<T>>

    /**
     * Group by Thread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThreadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadGroupByArgs['orderBy'] }
        : { orderBy?: ThreadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThreadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThreadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Thread model
   */
  readonly fields: ThreadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Thread.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Run<T extends Thread$RunArgs<ExtArgs> = {}>(args?: Subset<T, Thread$RunArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    ThreadMessage<T extends Thread$ThreadMessageArgs<ExtArgs> = {}>(args?: Subset<T, Thread$ThreadMessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadMessagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Thread model
   */ 
  interface ThreadFieldRefs {
    readonly thread_id: FieldRef<"Thread", 'String'>
    readonly title: FieldRef<"Thread", 'String'>
    readonly created_at: FieldRef<"Thread", 'DateTime'>
    readonly updated_at: FieldRef<"Thread", 'DateTime'>
    readonly organization_id: FieldRef<"Thread", 'Int'>
    readonly should_hide_thread: FieldRef<"Thread", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Thread findUnique
   */
  export type ThreadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thread
     */
    omit?: ThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter, which Thread to fetch.
     */
    where: ThreadWhereUniqueInput
  }

  /**
   * Thread findUniqueOrThrow
   */
  export type ThreadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thread
     */
    omit?: ThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter, which Thread to fetch.
     */
    where: ThreadWhereUniqueInput
  }

  /**
   * Thread findFirst
   */
  export type ThreadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thread
     */
    omit?: ThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter, which Thread to fetch.
     */
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     */
    orderBy?: ThreadOrderByWithRelationInput | ThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Threads.
     */
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Threads.
     */
    distinct?: ThreadScalarFieldEnum | ThreadScalarFieldEnum[]
  }

  /**
   * Thread findFirstOrThrow
   */
  export type ThreadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thread
     */
    omit?: ThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter, which Thread to fetch.
     */
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     */
    orderBy?: ThreadOrderByWithRelationInput | ThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Threads.
     */
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Threads.
     */
    distinct?: ThreadScalarFieldEnum | ThreadScalarFieldEnum[]
  }

  /**
   * Thread findMany
   */
  export type ThreadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thread
     */
    omit?: ThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter, which Threads to fetch.
     */
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     */
    orderBy?: ThreadOrderByWithRelationInput | ThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Threads.
     */
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     */
    skip?: number
    distinct?: ThreadScalarFieldEnum | ThreadScalarFieldEnum[]
  }

  /**
   * Thread create
   */
  export type ThreadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thread
     */
    omit?: ThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * The data needed to create a Thread.
     */
    data: XOR<ThreadCreateInput, ThreadUncheckedCreateInput>
  }

  /**
   * Thread createMany
   */
  export type ThreadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Threads.
     */
    data: ThreadCreateManyInput | ThreadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Thread createManyAndReturn
   */
  export type ThreadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Thread
     */
    omit?: ThreadOmit<ExtArgs> | null
    /**
     * The data used to create many Threads.
     */
    data: ThreadCreateManyInput | ThreadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Thread update
   */
  export type ThreadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thread
     */
    omit?: ThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * The data needed to update a Thread.
     */
    data: XOR<ThreadUpdateInput, ThreadUncheckedUpdateInput>
    /**
     * Choose, which Thread to update.
     */
    where: ThreadWhereUniqueInput
  }

  /**
   * Thread updateMany
   */
  export type ThreadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Threads.
     */
    data: XOR<ThreadUpdateManyMutationInput, ThreadUncheckedUpdateManyInput>
    /**
     * Filter which Threads to update
     */
    where?: ThreadWhereInput
    /**
     * Limit how many Threads to update.
     */
    limit?: number
  }

  /**
   * Thread updateManyAndReturn
   */
  export type ThreadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Thread
     */
    omit?: ThreadOmit<ExtArgs> | null
    /**
     * The data used to update Threads.
     */
    data: XOR<ThreadUpdateManyMutationInput, ThreadUncheckedUpdateManyInput>
    /**
     * Filter which Threads to update
     */
    where?: ThreadWhereInput
    /**
     * Limit how many Threads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Thread upsert
   */
  export type ThreadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thread
     */
    omit?: ThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * The filter to search for the Thread to update in case it exists.
     */
    where: ThreadWhereUniqueInput
    /**
     * In case the Thread found by the `where` argument doesn't exist, create a new Thread with this data.
     */
    create: XOR<ThreadCreateInput, ThreadUncheckedCreateInput>
    /**
     * In case the Thread was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreadUpdateInput, ThreadUncheckedUpdateInput>
  }

  /**
   * Thread delete
   */
  export type ThreadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thread
     */
    omit?: ThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter which Thread to delete.
     */
    where: ThreadWhereUniqueInput
  }

  /**
   * Thread deleteMany
   */
  export type ThreadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Threads to delete
     */
    where?: ThreadWhereInput
    /**
     * Limit how many Threads to delete.
     */
    limit?: number
  }

  /**
   * Thread.Run
   */
  export type Thread$RunArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
    where?: RunWhereInput
    orderBy?: RunOrderByWithRelationInput | RunOrderByWithRelationInput[]
    cursor?: RunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RunScalarFieldEnum | RunScalarFieldEnum[]
  }

  /**
   * Thread.ThreadMessage
   */
  export type Thread$ThreadMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadMessage
     */
    select?: ThreadMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadMessage
     */
    omit?: ThreadMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadMessageInclude<ExtArgs> | null
    where?: ThreadMessageWhereInput
    orderBy?: ThreadMessageOrderByWithRelationInput | ThreadMessageOrderByWithRelationInput[]
    cursor?: ThreadMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ThreadMessageScalarFieldEnum | ThreadMessageScalarFieldEnum[]
  }

  /**
   * Thread without action
   */
  export type ThreadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thread
     */
    omit?: ThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
  }


  /**
   * Model ThreadMessage
   */

  export type AggregateThreadMessage = {
    _count: ThreadMessageCountAggregateOutputType | null
    _min: ThreadMessageMinAggregateOutputType | null
    _max: ThreadMessageMaxAggregateOutputType | null
  }

  export type ThreadMessageMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    thread_id: string | null
    role: string | null
    content: string | null
    assistant_id: string | null
    run_id: string | null
  }

  export type ThreadMessageMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    thread_id: string | null
    role: string | null
    content: string | null
    assistant_id: string | null
    run_id: string | null
  }

  export type ThreadMessageCountAggregateOutputType = {
    id: number
    created_at: number
    thread_id: number
    role: number
    content: number
    assistant_id: number
    run_id: number
    _all: number
  }


  export type ThreadMessageMinAggregateInputType = {
    id?: true
    created_at?: true
    thread_id?: true
    role?: true
    content?: true
    assistant_id?: true
    run_id?: true
  }

  export type ThreadMessageMaxAggregateInputType = {
    id?: true
    created_at?: true
    thread_id?: true
    role?: true
    content?: true
    assistant_id?: true
    run_id?: true
  }

  export type ThreadMessageCountAggregateInputType = {
    id?: true
    created_at?: true
    thread_id?: true
    role?: true
    content?: true
    assistant_id?: true
    run_id?: true
    _all?: true
  }

  export type ThreadMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThreadMessage to aggregate.
     */
    where?: ThreadMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadMessages to fetch.
     */
    orderBy?: ThreadMessageOrderByWithRelationInput | ThreadMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThreadMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ThreadMessages
    **/
    _count?: true | ThreadMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThreadMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThreadMessageMaxAggregateInputType
  }

  export type GetThreadMessageAggregateType<T extends ThreadMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateThreadMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreadMessage[P]>
      : GetScalarType<T[P], AggregateThreadMessage[P]>
  }




  export type ThreadMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThreadMessageWhereInput
    orderBy?: ThreadMessageOrderByWithAggregationInput | ThreadMessageOrderByWithAggregationInput[]
    by: ThreadMessageScalarFieldEnum[] | ThreadMessageScalarFieldEnum
    having?: ThreadMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThreadMessageCountAggregateInputType | true
    _min?: ThreadMessageMinAggregateInputType
    _max?: ThreadMessageMaxAggregateInputType
  }

  export type ThreadMessageGroupByOutputType = {
    id: string
    created_at: Date
    thread_id: string
    role: string
    content: string
    assistant_id: string | null
    run_id: string | null
    _count: ThreadMessageCountAggregateOutputType | null
    _min: ThreadMessageMinAggregateOutputType | null
    _max: ThreadMessageMaxAggregateOutputType | null
  }

  type GetThreadMessageGroupByPayload<T extends ThreadMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThreadMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThreadMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadMessageGroupByOutputType[P]>
        }
      >
    >


  export type ThreadMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    thread_id?: boolean
    role?: boolean
    content?: boolean
    assistant_id?: boolean
    run_id?: boolean
    Run?: boolean | ThreadMessage$RunArgs<ExtArgs>
    Thread?: boolean | ThreadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["threadMessage"]>

  export type ThreadMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    thread_id?: boolean
    role?: boolean
    content?: boolean
    assistant_id?: boolean
    run_id?: boolean
    Run?: boolean | ThreadMessage$RunArgs<ExtArgs>
    Thread?: boolean | ThreadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["threadMessage"]>

  export type ThreadMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    thread_id?: boolean
    role?: boolean
    content?: boolean
    assistant_id?: boolean
    run_id?: boolean
    Run?: boolean | ThreadMessage$RunArgs<ExtArgs>
    Thread?: boolean | ThreadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["threadMessage"]>

  export type ThreadMessageSelectScalar = {
    id?: boolean
    created_at?: boolean
    thread_id?: boolean
    role?: boolean
    content?: boolean
    assistant_id?: boolean
    run_id?: boolean
  }

  export type ThreadMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "thread_id" | "role" | "content" | "assistant_id" | "run_id", ExtArgs["result"]["threadMessage"]>
  export type ThreadMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Run?: boolean | ThreadMessage$RunArgs<ExtArgs>
    Thread?: boolean | ThreadDefaultArgs<ExtArgs>
  }
  export type ThreadMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Run?: boolean | ThreadMessage$RunArgs<ExtArgs>
    Thread?: boolean | ThreadDefaultArgs<ExtArgs>
  }
  export type ThreadMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Run?: boolean | ThreadMessage$RunArgs<ExtArgs>
    Thread?: boolean | ThreadDefaultArgs<ExtArgs>
  }

  export type $ThreadMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ThreadMessage"
    objects: {
      Run: Prisma.$RunPayload<ExtArgs> | null
      Thread: Prisma.$ThreadPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      thread_id: string
      role: string
      content: string
      assistant_id: string | null
      run_id: string | null
    }, ExtArgs["result"]["threadMessage"]>
    composites: {}
  }

  type ThreadMessageGetPayload<S extends boolean | null | undefined | ThreadMessageDefaultArgs> = $Result.GetResult<Prisma.$ThreadMessagePayload, S>

  type ThreadMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ThreadMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ThreadMessageCountAggregateInputType | true
    }

  export interface ThreadMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'ThreadMessage' } }
    /**
     * Find zero or one ThreadMessage that matches the filter.
     * @param {ThreadMessageFindUniqueArgs} args - Arguments to find a ThreadMessage
     * @example
     * // Get one ThreadMessage
     * const threadMessage = await prisma.threadMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreadMessageFindUniqueArgs>(args: SelectSubset<T, ThreadMessageFindUniqueArgs<ExtArgs>>): Prisma__ThreadMessageClient<$Result.GetResult<Prisma.$ThreadMessagePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ThreadMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThreadMessageFindUniqueOrThrowArgs} args - Arguments to find a ThreadMessage
     * @example
     * // Get one ThreadMessage
     * const threadMessage = await prisma.threadMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreadMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ThreadMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ThreadMessageClient<$Result.GetResult<Prisma.$ThreadMessagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ThreadMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadMessageFindFirstArgs} args - Arguments to find a ThreadMessage
     * @example
     * // Get one ThreadMessage
     * const threadMessage = await prisma.threadMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreadMessageFindFirstArgs>(args?: SelectSubset<T, ThreadMessageFindFirstArgs<ExtArgs>>): Prisma__ThreadMessageClient<$Result.GetResult<Prisma.$ThreadMessagePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ThreadMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadMessageFindFirstOrThrowArgs} args - Arguments to find a ThreadMessage
     * @example
     * // Get one ThreadMessage
     * const threadMessage = await prisma.threadMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreadMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ThreadMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ThreadMessageClient<$Result.GetResult<Prisma.$ThreadMessagePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ThreadMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThreadMessages
     * const threadMessages = await prisma.threadMessage.findMany()
     * 
     * // Get first 10 ThreadMessages
     * const threadMessages = await prisma.threadMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const threadMessageWithIdOnly = await prisma.threadMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ThreadMessageFindManyArgs>(args?: SelectSubset<T, ThreadMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadMessagePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ThreadMessage.
     * @param {ThreadMessageCreateArgs} args - Arguments to create a ThreadMessage.
     * @example
     * // Create one ThreadMessage
     * const ThreadMessage = await prisma.threadMessage.create({
     *   data: {
     *     // ... data to create a ThreadMessage
     *   }
     * })
     * 
     */
    create<T extends ThreadMessageCreateArgs>(args: SelectSubset<T, ThreadMessageCreateArgs<ExtArgs>>): Prisma__ThreadMessageClient<$Result.GetResult<Prisma.$ThreadMessagePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ThreadMessages.
     * @param {ThreadMessageCreateManyArgs} args - Arguments to create many ThreadMessages.
     * @example
     * // Create many ThreadMessages
     * const threadMessage = await prisma.threadMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ThreadMessageCreateManyArgs>(args?: SelectSubset<T, ThreadMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ThreadMessages and returns the data saved in the database.
     * @param {ThreadMessageCreateManyAndReturnArgs} args - Arguments to create many ThreadMessages.
     * @example
     * // Create many ThreadMessages
     * const threadMessage = await prisma.threadMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ThreadMessages and only return the `id`
     * const threadMessageWithIdOnly = await prisma.threadMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ThreadMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ThreadMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadMessagePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ThreadMessage.
     * @param {ThreadMessageDeleteArgs} args - Arguments to delete one ThreadMessage.
     * @example
     * // Delete one ThreadMessage
     * const ThreadMessage = await prisma.threadMessage.delete({
     *   where: {
     *     // ... filter to delete one ThreadMessage
     *   }
     * })
     * 
     */
    delete<T extends ThreadMessageDeleteArgs>(args: SelectSubset<T, ThreadMessageDeleteArgs<ExtArgs>>): Prisma__ThreadMessageClient<$Result.GetResult<Prisma.$ThreadMessagePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ThreadMessage.
     * @param {ThreadMessageUpdateArgs} args - Arguments to update one ThreadMessage.
     * @example
     * // Update one ThreadMessage
     * const threadMessage = await prisma.threadMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ThreadMessageUpdateArgs>(args: SelectSubset<T, ThreadMessageUpdateArgs<ExtArgs>>): Prisma__ThreadMessageClient<$Result.GetResult<Prisma.$ThreadMessagePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ThreadMessages.
     * @param {ThreadMessageDeleteManyArgs} args - Arguments to filter ThreadMessages to delete.
     * @example
     * // Delete a few ThreadMessages
     * const { count } = await prisma.threadMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ThreadMessageDeleteManyArgs>(args?: SelectSubset<T, ThreadMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThreadMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThreadMessages
     * const threadMessage = await prisma.threadMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ThreadMessageUpdateManyArgs>(args: SelectSubset<T, ThreadMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThreadMessages and returns the data updated in the database.
     * @param {ThreadMessageUpdateManyAndReturnArgs} args - Arguments to update many ThreadMessages.
     * @example
     * // Update many ThreadMessages
     * const threadMessage = await prisma.threadMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ThreadMessages and only return the `id`
     * const threadMessageWithIdOnly = await prisma.threadMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ThreadMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ThreadMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadMessagePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ThreadMessage.
     * @param {ThreadMessageUpsertArgs} args - Arguments to update or create a ThreadMessage.
     * @example
     * // Update or create a ThreadMessage
     * const threadMessage = await prisma.threadMessage.upsert({
     *   create: {
     *     // ... data to create a ThreadMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThreadMessage we want to update
     *   }
     * })
     */
    upsert<T extends ThreadMessageUpsertArgs>(args: SelectSubset<T, ThreadMessageUpsertArgs<ExtArgs>>): Prisma__ThreadMessageClient<$Result.GetResult<Prisma.$ThreadMessagePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ThreadMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadMessageCountArgs} args - Arguments to filter ThreadMessages to count.
     * @example
     * // Count the number of ThreadMessages
     * const count = await prisma.threadMessage.count({
     *   where: {
     *     // ... the filter for the ThreadMessages we want to count
     *   }
     * })
    **/
    count<T extends ThreadMessageCountArgs>(
      args?: Subset<T, ThreadMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ThreadMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThreadMessageAggregateArgs>(args: Subset<T, ThreadMessageAggregateArgs>): Prisma.PrismaPromise<GetThreadMessageAggregateType<T>>

    /**
     * Group by ThreadMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThreadMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadMessageGroupByArgs['orderBy'] }
        : { orderBy?: ThreadMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThreadMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThreadMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ThreadMessage model
   */
  readonly fields: ThreadMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThreadMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreadMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Run<T extends ThreadMessage$RunArgs<ExtArgs> = {}>(args?: Subset<T, ThreadMessage$RunArgs<ExtArgs>>): Prisma__RunClient<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Thread<T extends ThreadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ThreadDefaultArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ThreadMessage model
   */ 
  interface ThreadMessageFieldRefs {
    readonly id: FieldRef<"ThreadMessage", 'String'>
    readonly created_at: FieldRef<"ThreadMessage", 'DateTime'>
    readonly thread_id: FieldRef<"ThreadMessage", 'String'>
    readonly role: FieldRef<"ThreadMessage", 'String'>
    readonly content: FieldRef<"ThreadMessage", 'String'>
    readonly assistant_id: FieldRef<"ThreadMessage", 'String'>
    readonly run_id: FieldRef<"ThreadMessage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ThreadMessage findUnique
   */
  export type ThreadMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadMessage
     */
    select?: ThreadMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadMessage
     */
    omit?: ThreadMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadMessageInclude<ExtArgs> | null
    /**
     * Filter, which ThreadMessage to fetch.
     */
    where: ThreadMessageWhereUniqueInput
  }

  /**
   * ThreadMessage findUniqueOrThrow
   */
  export type ThreadMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadMessage
     */
    select?: ThreadMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadMessage
     */
    omit?: ThreadMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadMessageInclude<ExtArgs> | null
    /**
     * Filter, which ThreadMessage to fetch.
     */
    where: ThreadMessageWhereUniqueInput
  }

  /**
   * ThreadMessage findFirst
   */
  export type ThreadMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadMessage
     */
    select?: ThreadMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadMessage
     */
    omit?: ThreadMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadMessageInclude<ExtArgs> | null
    /**
     * Filter, which ThreadMessage to fetch.
     */
    where?: ThreadMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadMessages to fetch.
     */
    orderBy?: ThreadMessageOrderByWithRelationInput | ThreadMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThreadMessages.
     */
    cursor?: ThreadMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThreadMessages.
     */
    distinct?: ThreadMessageScalarFieldEnum | ThreadMessageScalarFieldEnum[]
  }

  /**
   * ThreadMessage findFirstOrThrow
   */
  export type ThreadMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadMessage
     */
    select?: ThreadMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadMessage
     */
    omit?: ThreadMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadMessageInclude<ExtArgs> | null
    /**
     * Filter, which ThreadMessage to fetch.
     */
    where?: ThreadMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadMessages to fetch.
     */
    orderBy?: ThreadMessageOrderByWithRelationInput | ThreadMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThreadMessages.
     */
    cursor?: ThreadMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThreadMessages.
     */
    distinct?: ThreadMessageScalarFieldEnum | ThreadMessageScalarFieldEnum[]
  }

  /**
   * ThreadMessage findMany
   */
  export type ThreadMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadMessage
     */
    select?: ThreadMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadMessage
     */
    omit?: ThreadMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadMessageInclude<ExtArgs> | null
    /**
     * Filter, which ThreadMessages to fetch.
     */
    where?: ThreadMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadMessages to fetch.
     */
    orderBy?: ThreadMessageOrderByWithRelationInput | ThreadMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ThreadMessages.
     */
    cursor?: ThreadMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadMessages.
     */
    skip?: number
    distinct?: ThreadMessageScalarFieldEnum | ThreadMessageScalarFieldEnum[]
  }

  /**
   * ThreadMessage create
   */
  export type ThreadMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadMessage
     */
    select?: ThreadMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadMessage
     */
    omit?: ThreadMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ThreadMessage.
     */
    data: XOR<ThreadMessageCreateInput, ThreadMessageUncheckedCreateInput>
  }

  /**
   * ThreadMessage createMany
   */
  export type ThreadMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ThreadMessages.
     */
    data: ThreadMessageCreateManyInput | ThreadMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ThreadMessage createManyAndReturn
   */
  export type ThreadMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadMessage
     */
    select?: ThreadMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadMessage
     */
    omit?: ThreadMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ThreadMessages.
     */
    data: ThreadMessageCreateManyInput | ThreadMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ThreadMessage update
   */
  export type ThreadMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadMessage
     */
    select?: ThreadMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadMessage
     */
    omit?: ThreadMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ThreadMessage.
     */
    data: XOR<ThreadMessageUpdateInput, ThreadMessageUncheckedUpdateInput>
    /**
     * Choose, which ThreadMessage to update.
     */
    where: ThreadMessageWhereUniqueInput
  }

  /**
   * ThreadMessage updateMany
   */
  export type ThreadMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ThreadMessages.
     */
    data: XOR<ThreadMessageUpdateManyMutationInput, ThreadMessageUncheckedUpdateManyInput>
    /**
     * Filter which ThreadMessages to update
     */
    where?: ThreadMessageWhereInput
    /**
     * Limit how many ThreadMessages to update.
     */
    limit?: number
  }

  /**
   * ThreadMessage updateManyAndReturn
   */
  export type ThreadMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadMessage
     */
    select?: ThreadMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadMessage
     */
    omit?: ThreadMessageOmit<ExtArgs> | null
    /**
     * The data used to update ThreadMessages.
     */
    data: XOR<ThreadMessageUpdateManyMutationInput, ThreadMessageUncheckedUpdateManyInput>
    /**
     * Filter which ThreadMessages to update
     */
    where?: ThreadMessageWhereInput
    /**
     * Limit how many ThreadMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ThreadMessage upsert
   */
  export type ThreadMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadMessage
     */
    select?: ThreadMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadMessage
     */
    omit?: ThreadMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ThreadMessage to update in case it exists.
     */
    where: ThreadMessageWhereUniqueInput
    /**
     * In case the ThreadMessage found by the `where` argument doesn't exist, create a new ThreadMessage with this data.
     */
    create: XOR<ThreadMessageCreateInput, ThreadMessageUncheckedCreateInput>
    /**
     * In case the ThreadMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreadMessageUpdateInput, ThreadMessageUncheckedUpdateInput>
  }

  /**
   * ThreadMessage delete
   */
  export type ThreadMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadMessage
     */
    select?: ThreadMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadMessage
     */
    omit?: ThreadMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadMessageInclude<ExtArgs> | null
    /**
     * Filter which ThreadMessage to delete.
     */
    where: ThreadMessageWhereUniqueInput
  }

  /**
   * ThreadMessage deleteMany
   */
  export type ThreadMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThreadMessages to delete
     */
    where?: ThreadMessageWhereInput
    /**
     * Limit how many ThreadMessages to delete.
     */
    limit?: number
  }

  /**
   * ThreadMessage.Run
   */
  export type ThreadMessage$RunArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Run
     */
    select?: RunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Run
     */
    omit?: RunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RunInclude<ExtArgs> | null
    where?: RunWhereInput
  }

  /**
   * ThreadMessage without action
   */
  export type ThreadMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadMessage
     */
    select?: ThreadMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadMessage
     */
    omit?: ThreadMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadMessageInclude<ExtArgs> | null
  }


  /**
   * Model Usage
   */

  export type AggregateUsage = {
    _count: UsageCountAggregateOutputType | null
    _avg: UsageAvgAggregateOutputType | null
    _sum: UsageSumAggregateOutputType | null
    _min: UsageMinAggregateOutputType | null
    _max: UsageMaxAggregateOutputType | null
  }

  export type UsageAvgAggregateOutputType = {
    prompt_tokens: number | null
    completion_tokens: number | null
    total_tokens: number | null
    organization_id: number | null
  }

  export type UsageSumAggregateOutputType = {
    prompt_tokens: number | null
    completion_tokens: number | null
    total_tokens: number | null
    organization_id: number | null
  }

  export type UsageMinAggregateOutputType = {
    run_id: string | null
    prompt_tokens: number | null
    completion_tokens: number | null
    total_tokens: number | null
    organization_id: number | null
    created_at: Date | null
  }

  export type UsageMaxAggregateOutputType = {
    run_id: string | null
    prompt_tokens: number | null
    completion_tokens: number | null
    total_tokens: number | null
    organization_id: number | null
    created_at: Date | null
  }

  export type UsageCountAggregateOutputType = {
    run_id: number
    prompt_tokens: number
    completion_tokens: number
    total_tokens: number
    organization_id: number
    created_at: number
    _all: number
  }


  export type UsageAvgAggregateInputType = {
    prompt_tokens?: true
    completion_tokens?: true
    total_tokens?: true
    organization_id?: true
  }

  export type UsageSumAggregateInputType = {
    prompt_tokens?: true
    completion_tokens?: true
    total_tokens?: true
    organization_id?: true
  }

  export type UsageMinAggregateInputType = {
    run_id?: true
    prompt_tokens?: true
    completion_tokens?: true
    total_tokens?: true
    organization_id?: true
    created_at?: true
  }

  export type UsageMaxAggregateInputType = {
    run_id?: true
    prompt_tokens?: true
    completion_tokens?: true
    total_tokens?: true
    organization_id?: true
    created_at?: true
  }

  export type UsageCountAggregateInputType = {
    run_id?: true
    prompt_tokens?: true
    completion_tokens?: true
    total_tokens?: true
    organization_id?: true
    created_at?: true
    _all?: true
  }

  export type UsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usage to aggregate.
     */
    where?: UsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usages to fetch.
     */
    orderBy?: UsageOrderByWithRelationInput | UsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usages
    **/
    _count?: true | UsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageMaxAggregateInputType
  }

  export type GetUsageAggregateType<T extends UsageAggregateArgs> = {
        [P in keyof T & keyof AggregateUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsage[P]>
      : GetScalarType<T[P], AggregateUsage[P]>
  }




  export type UsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageWhereInput
    orderBy?: UsageOrderByWithAggregationInput | UsageOrderByWithAggregationInput[]
    by: UsageScalarFieldEnum[] | UsageScalarFieldEnum
    having?: UsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageCountAggregateInputType | true
    _avg?: UsageAvgAggregateInputType
    _sum?: UsageSumAggregateInputType
    _min?: UsageMinAggregateInputType
    _max?: UsageMaxAggregateInputType
  }

  export type UsageGroupByOutputType = {
    run_id: string
    prompt_tokens: number
    completion_tokens: number
    total_tokens: number
    organization_id: number | null
    created_at: Date
    _count: UsageCountAggregateOutputType | null
    _avg: UsageAvgAggregateOutputType | null
    _sum: UsageSumAggregateOutputType | null
    _min: UsageMinAggregateOutputType | null
    _max: UsageMaxAggregateOutputType | null
  }

  type GetUsageGroupByPayload<T extends UsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageGroupByOutputType[P]>
            : GetScalarType<T[P], UsageGroupByOutputType[P]>
        }
      >
    >


  export type UsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    run_id?: boolean
    prompt_tokens?: boolean
    completion_tokens?: boolean
    total_tokens?: boolean
    organization_id?: boolean
    created_at?: boolean
    Organization?: boolean | Usage$OrganizationArgs<ExtArgs>
    Run?: boolean | RunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usage"]>

  export type UsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    run_id?: boolean
    prompt_tokens?: boolean
    completion_tokens?: boolean
    total_tokens?: boolean
    organization_id?: boolean
    created_at?: boolean
    Organization?: boolean | Usage$OrganizationArgs<ExtArgs>
    Run?: boolean | RunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usage"]>

  export type UsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    run_id?: boolean
    prompt_tokens?: boolean
    completion_tokens?: boolean
    total_tokens?: boolean
    organization_id?: boolean
    created_at?: boolean
    Organization?: boolean | Usage$OrganizationArgs<ExtArgs>
    Run?: boolean | RunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usage"]>

  export type UsageSelectScalar = {
    run_id?: boolean
    prompt_tokens?: boolean
    completion_tokens?: boolean
    total_tokens?: boolean
    organization_id?: boolean
    created_at?: boolean
  }

  export type UsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"run_id" | "prompt_tokens" | "completion_tokens" | "total_tokens" | "organization_id" | "created_at", ExtArgs["result"]["usage"]>
  export type UsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | Usage$OrganizationArgs<ExtArgs>
    Run?: boolean | RunDefaultArgs<ExtArgs>
  }
  export type UsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | Usage$OrganizationArgs<ExtArgs>
    Run?: boolean | RunDefaultArgs<ExtArgs>
  }
  export type UsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | Usage$OrganizationArgs<ExtArgs>
    Run?: boolean | RunDefaultArgs<ExtArgs>
  }

  export type $UsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usage"
    objects: {
      Organization: Prisma.$OrganizationPayload<ExtArgs> | null
      Run: Prisma.$RunPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      run_id: string
      prompt_tokens: number
      completion_tokens: number
      total_tokens: number
      organization_id: number | null
      created_at: Date
    }, ExtArgs["result"]["usage"]>
    composites: {}
  }

  type UsageGetPayload<S extends boolean | null | undefined | UsageDefaultArgs> = $Result.GetResult<Prisma.$UsagePayload, S>

  type UsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsageCountAggregateInputType | true
    }

  export interface UsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'Usage' } }
    /**
     * Find zero or one Usage that matches the filter.
     * @param {UsageFindUniqueArgs} args - Arguments to find a Usage
     * @example
     * // Get one Usage
     * const usage = await prisma.usage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageFindUniqueArgs>(args: SelectSubset<T, UsageFindUniqueArgs<ExtArgs>>): Prisma__UsageClient<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Usage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsageFindUniqueOrThrowArgs} args - Arguments to find a Usage
     * @example
     * // Get one Usage
     * const usage = await prisma.usage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageClient<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Usage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageFindFirstArgs} args - Arguments to find a Usage
     * @example
     * // Get one Usage
     * const usage = await prisma.usage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageFindFirstArgs>(args?: SelectSubset<T, UsageFindFirstArgs<ExtArgs>>): Prisma__UsageClient<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Usage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageFindFirstOrThrowArgs} args - Arguments to find a Usage
     * @example
     * // Get one Usage
     * const usage = await prisma.usage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageClient<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Usages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usages
     * const usages = await prisma.usage.findMany()
     * 
     * // Get first 10 Usages
     * const usages = await prisma.usage.findMany({ take: 10 })
     * 
     * // Only select the `run_id`
     * const usageWithRun_idOnly = await prisma.usage.findMany({ select: { run_id: true } })
     * 
     */
    findMany<T extends UsageFindManyArgs>(args?: SelectSubset<T, UsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Usage.
     * @param {UsageCreateArgs} args - Arguments to create a Usage.
     * @example
     * // Create one Usage
     * const Usage = await prisma.usage.create({
     *   data: {
     *     // ... data to create a Usage
     *   }
     * })
     * 
     */
    create<T extends UsageCreateArgs>(args: SelectSubset<T, UsageCreateArgs<ExtArgs>>): Prisma__UsageClient<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Usages.
     * @param {UsageCreateManyArgs} args - Arguments to create many Usages.
     * @example
     * // Create many Usages
     * const usage = await prisma.usage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageCreateManyArgs>(args?: SelectSubset<T, UsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usages and returns the data saved in the database.
     * @param {UsageCreateManyAndReturnArgs} args - Arguments to create many Usages.
     * @example
     * // Create many Usages
     * const usage = await prisma.usage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usages and only return the `run_id`
     * const usageWithRun_idOnly = await prisma.usage.createManyAndReturn({
     *   select: { run_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Usage.
     * @param {UsageDeleteArgs} args - Arguments to delete one Usage.
     * @example
     * // Delete one Usage
     * const Usage = await prisma.usage.delete({
     *   where: {
     *     // ... filter to delete one Usage
     *   }
     * })
     * 
     */
    delete<T extends UsageDeleteArgs>(args: SelectSubset<T, UsageDeleteArgs<ExtArgs>>): Prisma__UsageClient<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Usage.
     * @param {UsageUpdateArgs} args - Arguments to update one Usage.
     * @example
     * // Update one Usage
     * const usage = await prisma.usage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageUpdateArgs>(args: SelectSubset<T, UsageUpdateArgs<ExtArgs>>): Prisma__UsageClient<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Usages.
     * @param {UsageDeleteManyArgs} args - Arguments to filter Usages to delete.
     * @example
     * // Delete a few Usages
     * const { count } = await prisma.usage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageDeleteManyArgs>(args?: SelectSubset<T, UsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usages
     * const usage = await prisma.usage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageUpdateManyArgs>(args: SelectSubset<T, UsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usages and returns the data updated in the database.
     * @param {UsageUpdateManyAndReturnArgs} args - Arguments to update many Usages.
     * @example
     * // Update many Usages
     * const usage = await prisma.usage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Usages and only return the `run_id`
     * const usageWithRun_idOnly = await prisma.usage.updateManyAndReturn({
     *   select: { run_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsageUpdateManyAndReturnArgs>(args: SelectSubset<T, UsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Usage.
     * @param {UsageUpsertArgs} args - Arguments to update or create a Usage.
     * @example
     * // Update or create a Usage
     * const usage = await prisma.usage.upsert({
     *   create: {
     *     // ... data to create a Usage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usage we want to update
     *   }
     * })
     */
    upsert<T extends UsageUpsertArgs>(args: SelectSubset<T, UsageUpsertArgs<ExtArgs>>): Prisma__UsageClient<$Result.GetResult<Prisma.$UsagePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Usages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageCountArgs} args - Arguments to filter Usages to count.
     * @example
     * // Count the number of Usages
     * const count = await prisma.usage.count({
     *   where: {
     *     // ... the filter for the Usages we want to count
     *   }
     * })
    **/
    count<T extends UsageCountArgs>(
      args?: Subset<T, UsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageAggregateArgs>(args: Subset<T, UsageAggregateArgs>): Prisma.PrismaPromise<GetUsageAggregateType<T>>

    /**
     * Group by Usage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageGroupByArgs['orderBy'] }
        : { orderBy?: UsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usage model
   */
  readonly fields: UsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Organization<T extends Usage$OrganizationArgs<ExtArgs> = {}>(args?: Subset<T, Usage$OrganizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Run<T extends RunDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RunDefaultArgs<ExtArgs>>): Prisma__RunClient<$Result.GetResult<Prisma.$RunPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usage model
   */ 
  interface UsageFieldRefs {
    readonly run_id: FieldRef<"Usage", 'String'>
    readonly prompt_tokens: FieldRef<"Usage", 'Int'>
    readonly completion_tokens: FieldRef<"Usage", 'Int'>
    readonly total_tokens: FieldRef<"Usage", 'Int'>
    readonly organization_id: FieldRef<"Usage", 'Int'>
    readonly created_at: FieldRef<"Usage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usage findUnique
   */
  export type UsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usage
     */
    omit?: UsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
    /**
     * Filter, which Usage to fetch.
     */
    where: UsageWhereUniqueInput
  }

  /**
   * Usage findUniqueOrThrow
   */
  export type UsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usage
     */
    omit?: UsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
    /**
     * Filter, which Usage to fetch.
     */
    where: UsageWhereUniqueInput
  }

  /**
   * Usage findFirst
   */
  export type UsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usage
     */
    omit?: UsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
    /**
     * Filter, which Usage to fetch.
     */
    where?: UsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usages to fetch.
     */
    orderBy?: UsageOrderByWithRelationInput | UsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usages.
     */
    cursor?: UsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usages.
     */
    distinct?: UsageScalarFieldEnum | UsageScalarFieldEnum[]
  }

  /**
   * Usage findFirstOrThrow
   */
  export type UsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usage
     */
    omit?: UsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
    /**
     * Filter, which Usage to fetch.
     */
    where?: UsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usages to fetch.
     */
    orderBy?: UsageOrderByWithRelationInput | UsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usages.
     */
    cursor?: UsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usages.
     */
    distinct?: UsageScalarFieldEnum | UsageScalarFieldEnum[]
  }

  /**
   * Usage findMany
   */
  export type UsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usage
     */
    omit?: UsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
    /**
     * Filter, which Usages to fetch.
     */
    where?: UsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usages to fetch.
     */
    orderBy?: UsageOrderByWithRelationInput | UsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usages.
     */
    cursor?: UsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usages.
     */
    skip?: number
    distinct?: UsageScalarFieldEnum | UsageScalarFieldEnum[]
  }

  /**
   * Usage create
   */
  export type UsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usage
     */
    omit?: UsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
    /**
     * The data needed to create a Usage.
     */
    data: XOR<UsageCreateInput, UsageUncheckedCreateInput>
  }

  /**
   * Usage createMany
   */
  export type UsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usages.
     */
    data: UsageCreateManyInput | UsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usage createManyAndReturn
   */
  export type UsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usage
     */
    omit?: UsageOmit<ExtArgs> | null
    /**
     * The data used to create many Usages.
     */
    data: UsageCreateManyInput | UsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Usage update
   */
  export type UsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usage
     */
    omit?: UsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
    /**
     * The data needed to update a Usage.
     */
    data: XOR<UsageUpdateInput, UsageUncheckedUpdateInput>
    /**
     * Choose, which Usage to update.
     */
    where: UsageWhereUniqueInput
  }

  /**
   * Usage updateMany
   */
  export type UsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usages.
     */
    data: XOR<UsageUpdateManyMutationInput, UsageUncheckedUpdateManyInput>
    /**
     * Filter which Usages to update
     */
    where?: UsageWhereInput
    /**
     * Limit how many Usages to update.
     */
    limit?: number
  }

  /**
   * Usage updateManyAndReturn
   */
  export type UsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usage
     */
    omit?: UsageOmit<ExtArgs> | null
    /**
     * The data used to update Usages.
     */
    data: XOR<UsageUpdateManyMutationInput, UsageUncheckedUpdateManyInput>
    /**
     * Filter which Usages to update
     */
    where?: UsageWhereInput
    /**
     * Limit how many Usages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Usage upsert
   */
  export type UsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usage
     */
    omit?: UsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
    /**
     * The filter to search for the Usage to update in case it exists.
     */
    where: UsageWhereUniqueInput
    /**
     * In case the Usage found by the `where` argument doesn't exist, create a new Usage with this data.
     */
    create: XOR<UsageCreateInput, UsageUncheckedCreateInput>
    /**
     * In case the Usage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageUpdateInput, UsageUncheckedUpdateInput>
  }

  /**
   * Usage delete
   */
  export type UsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usage
     */
    omit?: UsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
    /**
     * Filter which Usage to delete.
     */
    where: UsageWhereUniqueInput
  }

  /**
   * Usage deleteMany
   */
  export type UsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usages to delete
     */
    where?: UsageWhereInput
    /**
     * Limit how many Usages to delete.
     */
    limit?: number
  }

  /**
   * Usage.Organization
   */
  export type Usage$OrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Usage without action
   */
  export type UsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usage
     */
    select?: UsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usage
     */
    omit?: UsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageInclude<ExtArgs> | null
  }


  /**
   * Model UserOrganization
   */

  export type AggregateUserOrganization = {
    _count: UserOrganizationCountAggregateOutputType | null
    _avg: UserOrganizationAvgAggregateOutputType | null
    _sum: UserOrganizationSumAggregateOutputType | null
    _min: UserOrganizationMinAggregateOutputType | null
    _max: UserOrganizationMaxAggregateOutputType | null
  }

  export type UserOrganizationAvgAggregateOutputType = {
    user_id: number | null
    organization_id: number | null
  }

  export type UserOrganizationSumAggregateOutputType = {
    user_id: number | null
    organization_id: number | null
  }

  export type UserOrganizationMinAggregateOutputType = {
    user_id: number | null
    organization_id: number | null
    role: string | null
    created_at: Date | null
  }

  export type UserOrganizationMaxAggregateOutputType = {
    user_id: number | null
    organization_id: number | null
    role: string | null
    created_at: Date | null
  }

  export type UserOrganizationCountAggregateOutputType = {
    user_id: number
    organization_id: number
    role: number
    created_at: number
    _all: number
  }


  export type UserOrganizationAvgAggregateInputType = {
    user_id?: true
    organization_id?: true
  }

  export type UserOrganizationSumAggregateInputType = {
    user_id?: true
    organization_id?: true
  }

  export type UserOrganizationMinAggregateInputType = {
    user_id?: true
    organization_id?: true
    role?: true
    created_at?: true
  }

  export type UserOrganizationMaxAggregateInputType = {
    user_id?: true
    organization_id?: true
    role?: true
    created_at?: true
  }

  export type UserOrganizationCountAggregateInputType = {
    user_id?: true
    organization_id?: true
    role?: true
    created_at?: true
    _all?: true
  }

  export type UserOrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOrganization to aggregate.
     */
    where?: UserOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOrganizations to fetch.
     */
    orderBy?: UserOrganizationOrderByWithRelationInput | UserOrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserOrganizations
    **/
    _count?: true | UserOrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserOrganizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserOrganizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserOrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserOrganizationMaxAggregateInputType
  }

  export type GetUserOrganizationAggregateType<T extends UserOrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserOrganization[P]>
      : GetScalarType<T[P], AggregateUserOrganization[P]>
  }




  export type UserOrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOrganizationWhereInput
    orderBy?: UserOrganizationOrderByWithAggregationInput | UserOrganizationOrderByWithAggregationInput[]
    by: UserOrganizationScalarFieldEnum[] | UserOrganizationScalarFieldEnum
    having?: UserOrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserOrganizationCountAggregateInputType | true
    _avg?: UserOrganizationAvgAggregateInputType
    _sum?: UserOrganizationSumAggregateInputType
    _min?: UserOrganizationMinAggregateInputType
    _max?: UserOrganizationMaxAggregateInputType
  }

  export type UserOrganizationGroupByOutputType = {
    user_id: number
    organization_id: number
    role: string
    created_at: Date
    _count: UserOrganizationCountAggregateOutputType | null
    _avg: UserOrganizationAvgAggregateOutputType | null
    _sum: UserOrganizationSumAggregateOutputType | null
    _min: UserOrganizationMinAggregateOutputType | null
    _max: UserOrganizationMaxAggregateOutputType | null
  }

  type GetUserOrganizationGroupByPayload<T extends UserOrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserOrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserOrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserOrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], UserOrganizationGroupByOutputType[P]>
        }
      >
    >


  export type UserOrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    organization_id?: boolean
    role?: boolean
    created_at?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOrganization"]>

  export type UserOrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    organization_id?: boolean
    role?: boolean
    created_at?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOrganization"]>

  export type UserOrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    organization_id?: boolean
    role?: boolean
    created_at?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOrganization"]>

  export type UserOrganizationSelectScalar = {
    user_id?: boolean
    organization_id?: boolean
    role?: boolean
    created_at?: boolean
  }

  export type UserOrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "organization_id" | "role" | "created_at", ExtArgs["result"]["userOrganization"]>
  export type UserOrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type UserOrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type UserOrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $UserOrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserOrganization"
    objects: {
      Organization: Prisma.$OrganizationPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      organization_id: number
      role: string
      created_at: Date
    }, ExtArgs["result"]["userOrganization"]>
    composites: {}
  }

  type UserOrganizationGetPayload<S extends boolean | null | undefined | UserOrganizationDefaultArgs> = $Result.GetResult<Prisma.$UserOrganizationPayload, S>

  type UserOrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserOrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserOrganizationCountAggregateInputType | true
    }

  export interface UserOrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'UserOrganization' } }
    /**
     * Find zero or one UserOrganization that matches the filter.
     * @param {UserOrganizationFindUniqueArgs} args - Arguments to find a UserOrganization
     * @example
     * // Get one UserOrganization
     * const userOrganization = await prisma.userOrganization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserOrganizationFindUniqueArgs>(args: SelectSubset<T, UserOrganizationFindUniqueArgs<ExtArgs>>): Prisma__UserOrganizationClient<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserOrganization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserOrganizationFindUniqueOrThrowArgs} args - Arguments to find a UserOrganization
     * @example
     * // Get one UserOrganization
     * const userOrganization = await prisma.userOrganization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserOrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserOrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserOrganizationClient<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserOrganization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrganizationFindFirstArgs} args - Arguments to find a UserOrganization
     * @example
     * // Get one UserOrganization
     * const userOrganization = await prisma.userOrganization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserOrganizationFindFirstArgs>(args?: SelectSubset<T, UserOrganizationFindFirstArgs<ExtArgs>>): Prisma__UserOrganizationClient<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserOrganization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrganizationFindFirstOrThrowArgs} args - Arguments to find a UserOrganization
     * @example
     * // Get one UserOrganization
     * const userOrganization = await prisma.userOrganization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserOrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserOrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserOrganizationClient<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserOrganizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserOrganizations
     * const userOrganizations = await prisma.userOrganization.findMany()
     * 
     * // Get first 10 UserOrganizations
     * const userOrganizations = await prisma.userOrganization.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const userOrganizationWithUser_idOnly = await prisma.userOrganization.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends UserOrganizationFindManyArgs>(args?: SelectSubset<T, UserOrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserOrganization.
     * @param {UserOrganizationCreateArgs} args - Arguments to create a UserOrganization.
     * @example
     * // Create one UserOrganization
     * const UserOrganization = await prisma.userOrganization.create({
     *   data: {
     *     // ... data to create a UserOrganization
     *   }
     * })
     * 
     */
    create<T extends UserOrganizationCreateArgs>(args: SelectSubset<T, UserOrganizationCreateArgs<ExtArgs>>): Prisma__UserOrganizationClient<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserOrganizations.
     * @param {UserOrganizationCreateManyArgs} args - Arguments to create many UserOrganizations.
     * @example
     * // Create many UserOrganizations
     * const userOrganization = await prisma.userOrganization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserOrganizationCreateManyArgs>(args?: SelectSubset<T, UserOrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserOrganizations and returns the data saved in the database.
     * @param {UserOrganizationCreateManyAndReturnArgs} args - Arguments to create many UserOrganizations.
     * @example
     * // Create many UserOrganizations
     * const userOrganization = await prisma.userOrganization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserOrganizations and only return the `user_id`
     * const userOrganizationWithUser_idOnly = await prisma.userOrganization.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserOrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, UserOrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UserOrganization.
     * @param {UserOrganizationDeleteArgs} args - Arguments to delete one UserOrganization.
     * @example
     * // Delete one UserOrganization
     * const UserOrganization = await prisma.userOrganization.delete({
     *   where: {
     *     // ... filter to delete one UserOrganization
     *   }
     * })
     * 
     */
    delete<T extends UserOrganizationDeleteArgs>(args: SelectSubset<T, UserOrganizationDeleteArgs<ExtArgs>>): Prisma__UserOrganizationClient<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserOrganization.
     * @param {UserOrganizationUpdateArgs} args - Arguments to update one UserOrganization.
     * @example
     * // Update one UserOrganization
     * const userOrganization = await prisma.userOrganization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserOrganizationUpdateArgs>(args: SelectSubset<T, UserOrganizationUpdateArgs<ExtArgs>>): Prisma__UserOrganizationClient<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserOrganizations.
     * @param {UserOrganizationDeleteManyArgs} args - Arguments to filter UserOrganizations to delete.
     * @example
     * // Delete a few UserOrganizations
     * const { count } = await prisma.userOrganization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserOrganizationDeleteManyArgs>(args?: SelectSubset<T, UserOrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserOrganizations
     * const userOrganization = await prisma.userOrganization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserOrganizationUpdateManyArgs>(args: SelectSubset<T, UserOrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserOrganizations and returns the data updated in the database.
     * @param {UserOrganizationUpdateManyAndReturnArgs} args - Arguments to update many UserOrganizations.
     * @example
     * // Update many UserOrganizations
     * const userOrganization = await prisma.userOrganization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserOrganizations and only return the `user_id`
     * const userOrganizationWithUser_idOnly = await prisma.userOrganization.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserOrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, UserOrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UserOrganization.
     * @param {UserOrganizationUpsertArgs} args - Arguments to update or create a UserOrganization.
     * @example
     * // Update or create a UserOrganization
     * const userOrganization = await prisma.userOrganization.upsert({
     *   create: {
     *     // ... data to create a UserOrganization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserOrganization we want to update
     *   }
     * })
     */
    upsert<T extends UserOrganizationUpsertArgs>(args: SelectSubset<T, UserOrganizationUpsertArgs<ExtArgs>>): Prisma__UserOrganizationClient<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrganizationCountArgs} args - Arguments to filter UserOrganizations to count.
     * @example
     * // Count the number of UserOrganizations
     * const count = await prisma.userOrganization.count({
     *   where: {
     *     // ... the filter for the UserOrganizations we want to count
     *   }
     * })
    **/
    count<T extends UserOrganizationCountArgs>(
      args?: Subset<T, UserOrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserOrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserOrganization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserOrganizationAggregateArgs>(args: Subset<T, UserOrganizationAggregateArgs>): Prisma.PrismaPromise<GetUserOrganizationAggregateType<T>>

    /**
     * Group by UserOrganization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserOrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserOrganizationGroupByArgs['orderBy'] }
        : { orderBy?: UserOrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserOrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserOrganization model
   */
  readonly fields: UserOrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserOrganization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserOrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserOrganization model
   */ 
  interface UserOrganizationFieldRefs {
    readonly user_id: FieldRef<"UserOrganization", 'Int'>
    readonly organization_id: FieldRef<"UserOrganization", 'Int'>
    readonly role: FieldRef<"UserOrganization", 'String'>
    readonly created_at: FieldRef<"UserOrganization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserOrganization findUnique
   */
  export type UserOrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOrganization
     */
    omit?: UserOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    /**
     * Filter, which UserOrganization to fetch.
     */
    where: UserOrganizationWhereUniqueInput
  }

  /**
   * UserOrganization findUniqueOrThrow
   */
  export type UserOrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOrganization
     */
    omit?: UserOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    /**
     * Filter, which UserOrganization to fetch.
     */
    where: UserOrganizationWhereUniqueInput
  }

  /**
   * UserOrganization findFirst
   */
  export type UserOrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOrganization
     */
    omit?: UserOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    /**
     * Filter, which UserOrganization to fetch.
     */
    where?: UserOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOrganizations to fetch.
     */
    orderBy?: UserOrganizationOrderByWithRelationInput | UserOrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOrganizations.
     */
    cursor?: UserOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOrganizations.
     */
    distinct?: UserOrganizationScalarFieldEnum | UserOrganizationScalarFieldEnum[]
  }

  /**
   * UserOrganization findFirstOrThrow
   */
  export type UserOrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOrganization
     */
    omit?: UserOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    /**
     * Filter, which UserOrganization to fetch.
     */
    where?: UserOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOrganizations to fetch.
     */
    orderBy?: UserOrganizationOrderByWithRelationInput | UserOrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOrganizations.
     */
    cursor?: UserOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOrganizations.
     */
    distinct?: UserOrganizationScalarFieldEnum | UserOrganizationScalarFieldEnum[]
  }

  /**
   * UserOrganization findMany
   */
  export type UserOrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOrganization
     */
    omit?: UserOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    /**
     * Filter, which UserOrganizations to fetch.
     */
    where?: UserOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOrganizations to fetch.
     */
    orderBy?: UserOrganizationOrderByWithRelationInput | UserOrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserOrganizations.
     */
    cursor?: UserOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOrganizations.
     */
    skip?: number
    distinct?: UserOrganizationScalarFieldEnum | UserOrganizationScalarFieldEnum[]
  }

  /**
   * UserOrganization create
   */
  export type UserOrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOrganization
     */
    omit?: UserOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserOrganization.
     */
    data: XOR<UserOrganizationCreateInput, UserOrganizationUncheckedCreateInput>
  }

  /**
   * UserOrganization createMany
   */
  export type UserOrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserOrganizations.
     */
    data: UserOrganizationCreateManyInput | UserOrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserOrganization createManyAndReturn
   */
  export type UserOrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserOrganization
     */
    omit?: UserOrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many UserOrganizations.
     */
    data: UserOrganizationCreateManyInput | UserOrganizationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserOrganization update
   */
  export type UserOrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOrganization
     */
    omit?: UserOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserOrganization.
     */
    data: XOR<UserOrganizationUpdateInput, UserOrganizationUncheckedUpdateInput>
    /**
     * Choose, which UserOrganization to update.
     */
    where: UserOrganizationWhereUniqueInput
  }

  /**
   * UserOrganization updateMany
   */
  export type UserOrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserOrganizations.
     */
    data: XOR<UserOrganizationUpdateManyMutationInput, UserOrganizationUncheckedUpdateManyInput>
    /**
     * Filter which UserOrganizations to update
     */
    where?: UserOrganizationWhereInput
    /**
     * Limit how many UserOrganizations to update.
     */
    limit?: number
  }

  /**
   * UserOrganization updateManyAndReturn
   */
  export type UserOrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserOrganization
     */
    omit?: UserOrganizationOmit<ExtArgs> | null
    /**
     * The data used to update UserOrganizations.
     */
    data: XOR<UserOrganizationUpdateManyMutationInput, UserOrganizationUncheckedUpdateManyInput>
    /**
     * Filter which UserOrganizations to update
     */
    where?: UserOrganizationWhereInput
    /**
     * Limit how many UserOrganizations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserOrganization upsert
   */
  export type UserOrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOrganization
     */
    omit?: UserOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserOrganization to update in case it exists.
     */
    where: UserOrganizationWhereUniqueInput
    /**
     * In case the UserOrganization found by the `where` argument doesn't exist, create a new UserOrganization with this data.
     */
    create: XOR<UserOrganizationCreateInput, UserOrganizationUncheckedCreateInput>
    /**
     * In case the UserOrganization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserOrganizationUpdateInput, UserOrganizationUncheckedUpdateInput>
  }

  /**
   * UserOrganization delete
   */
  export type UserOrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOrganization
     */
    omit?: UserOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    /**
     * Filter which UserOrganization to delete.
     */
    where: UserOrganizationWhereUniqueInput
  }

  /**
   * UserOrganization deleteMany
   */
  export type UserOrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOrganizations to delete
     */
    where?: UserOrganizationWhereInput
    /**
     * Limit how many UserOrganizations to delete.
     */
    limit?: number
  }

  /**
   * UserOrganization without action
   */
  export type UserOrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOrganization
     */
    omit?: UserOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
  }


  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
    media_id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
    organization_id: number | null
    media_id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    email: string | null
    username: string | null
    password: string | null
    security_pin: string | null
    created_at: Date | null
    organization_id: number | null
    updated_at: Date | null
    role: string | null
    media_id: number | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    email: string | null
    username: string | null
    password: string | null
    security_pin: string | null
    created_at: Date | null
    organization_id: number | null
    updated_at: Date | null
    role: string | null
    media_id: number | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    email: number
    username: number
    password: number
    security_pin: number
    created_at: number
    organization_id: number
    updated_at: number
    role: number
    media_id: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    organization_id?: true
    media_id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    organization_id?: true
    media_id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    security_pin?: true
    created_at?: true
    organization_id?: true
    updated_at?: true
    role?: true
    media_id?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    security_pin?: true
    created_at?: true
    organization_id?: true
    updated_at?: true
    role?: true
    media_id?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    security_pin?: true
    created_at?: true
    organization_id?: true
    updated_at?: true
    role?: true
    media_id?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    email: string
    username: string
    password: string
    security_pin: string | null
    created_at: Date
    organization_id: number
    updated_at: Date
    role: string
    media_id: number | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    security_pin?: boolean
    created_at?: boolean
    organization_id?: boolean
    updated_at?: boolean
    role?: boolean
    media_id?: boolean
    UserOrganization?: boolean | Users$UserOrganizationArgs<ExtArgs>
    Media?: boolean | Users$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    security_pin?: boolean
    created_at?: boolean
    organization_id?: boolean
    updated_at?: boolean
    role?: boolean
    media_id?: boolean
    Media?: boolean | Users$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    security_pin?: boolean
    created_at?: boolean
    organization_id?: boolean
    updated_at?: boolean
    role?: boolean
    media_id?: boolean
    Media?: boolean | Users$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    security_pin?: boolean
    created_at?: boolean
    organization_id?: boolean
    updated_at?: boolean
    role?: boolean
    media_id?: boolean
  }

  export type UsersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "password" | "security_pin" | "created_at" | "organization_id" | "updated_at" | "role" | "media_id", ExtArgs["result"]["users"]>
  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserOrganization?: boolean | Users$UserOrganizationArgs<ExtArgs>
    Media?: boolean | Users$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Media?: boolean | Users$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type UsersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Media?: boolean | Users$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      UserOrganization: Prisma.$UserOrganizationPayload<ExtArgs>[]
      Media: Prisma.$MediaPayload<ExtArgs> | null
      Organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      username: string
      password: string
      security_pin: string | null
      created_at: Date
      organization_id: number
      updated_at: Date
      role: string
      media_id: number | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UsersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsersCreateManyAndReturnArgs>(args?: SelectSubset<T, UsersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UsersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsersUpdateManyAndReturnArgs>(args: SelectSubset<T, UsersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UserOrganization<T extends Users$UserOrganizationArgs<ExtArgs> = {}>(args?: Subset<T, Users$UserOrganizationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Media<T extends Users$MediaArgs<ExtArgs> = {}>(args?: Subset<T, Users$MediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */ 
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", 'Int'>
    readonly email: FieldRef<"Users", 'String'>
    readonly username: FieldRef<"Users", 'String'>
    readonly password: FieldRef<"Users", 'String'>
    readonly security_pin: FieldRef<"Users", 'String'>
    readonly created_at: FieldRef<"Users", 'DateTime'>
    readonly organization_id: FieldRef<"Users", 'Int'>
    readonly updated_at: FieldRef<"Users", 'DateTime'>
    readonly role: FieldRef<"Users", 'String'>
    readonly media_id: FieldRef<"Users", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users createManyAndReturn
   */
  export type UsersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users updateManyAndReturn
   */
  export type UsersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * Users.UserOrganization
   */
  export type Users$UserOrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOrganization
     */
    omit?: UserOrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    where?: UserOrganizationWhereInput
    orderBy?: UserOrganizationOrderByWithRelationInput | UserOrganizationOrderByWithRelationInput[]
    cursor?: UserOrganizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserOrganizationScalarFieldEnum | UserOrganizationScalarFieldEnum[]
  }

  /**
   * Users.Media
   */
  export type Users$MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model author
   */

  export type AggregateAuthor = {
    _count: AuthorCountAggregateOutputType | null
    _avg: AuthorAvgAggregateOutputType | null
    _sum: AuthorSumAggregateOutputType | null
    _min: AuthorMinAggregateOutputType | null
    _max: AuthorMaxAggregateOutputType | null
  }

  export type AuthorAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
    media_id: number | null
  }

  export type AuthorSumAggregateOutputType = {
    id: number | null
    organization_id: number | null
    media_id: number | null
  }

  export type AuthorMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    description: string | null
    organization_id: number | null
    media_id: number | null
    slug: string | null
  }

  export type AuthorMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    description: string | null
    organization_id: number | null
    media_id: number | null
    slug: string | null
  }

  export type AuthorCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    name: number
    description: number
    organization_id: number
    media_id: number
    slug: number
    _all: number
  }


  export type AuthorAvgAggregateInputType = {
    id?: true
    organization_id?: true
    media_id?: true
  }

  export type AuthorSumAggregateInputType = {
    id?: true
    organization_id?: true
    media_id?: true
  }

  export type AuthorMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    description?: true
    organization_id?: true
    media_id?: true
    slug?: true
  }

  export type AuthorMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    description?: true
    organization_id?: true
    media_id?: true
    slug?: true
  }

  export type AuthorCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    description?: true
    organization_id?: true
    media_id?: true
    slug?: true
    _all?: true
  }

  export type AuthorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which author to aggregate.
     */
    where?: authorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authors to fetch.
     */
    orderBy?: authorOrderByWithRelationInput | authorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: authorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned authors
    **/
    _count?: true | AuthorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuthorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuthorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthorMaxAggregateInputType
  }

  export type GetAuthorAggregateType<T extends AuthorAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthor[P]>
      : GetScalarType<T[P], AggregateAuthor[P]>
  }




  export type authorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: authorWhereInput
    orderBy?: authorOrderByWithAggregationInput | authorOrderByWithAggregationInput[]
    by: AuthorScalarFieldEnum[] | AuthorScalarFieldEnum
    having?: authorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthorCountAggregateInputType | true
    _avg?: AuthorAvgAggregateInputType
    _sum?: AuthorSumAggregateInputType
    _min?: AuthorMinAggregateInputType
    _max?: AuthorMaxAggregateInputType
  }

  export type AuthorGroupByOutputType = {
    id: number
    created_at: Date
    updated_at: Date
    name: string
    description: string
    organization_id: number
    media_id: number
    slug: string
    _count: AuthorCountAggregateOutputType | null
    _avg: AuthorAvgAggregateOutputType | null
    _sum: AuthorSumAggregateOutputType | null
    _min: AuthorMinAggregateOutputType | null
    _max: AuthorMaxAggregateOutputType | null
  }

  type GetAuthorGroupByPayload<T extends authorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthorGroupByOutputType[P]>
            : GetScalarType<T[P], AuthorGroupByOutputType[P]>
        }
      >
    >


  export type authorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    organization_id?: boolean
    media_id?: boolean
    slug?: boolean
    Content?: boolean | author$ContentArgs<ExtArgs>
    Media?: boolean | MediaDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | AuthorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["author"]>

  export type authorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    organization_id?: boolean
    media_id?: boolean
    slug?: boolean
    Media?: boolean | MediaDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["author"]>

  export type authorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    organization_id?: boolean
    media_id?: boolean
    slug?: boolean
    Media?: boolean | MediaDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["author"]>

  export type authorSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    organization_id?: boolean
    media_id?: boolean
    slug?: boolean
  }

  export type authorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "name" | "description" | "organization_id" | "media_id" | "slug", ExtArgs["result"]["author"]>
  export type authorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Content?: boolean | author$ContentArgs<ExtArgs>
    Media?: boolean | MediaDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | AuthorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type authorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Media?: boolean | MediaDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type authorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Media?: boolean | MediaDefaultArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $authorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "author"
    objects: {
      Content: Prisma.$ContentPayload<ExtArgs>[]
      Media: Prisma.$MediaPayload<ExtArgs>
      Organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      created_at: Date
      updated_at: Date
      name: string
      description: string
      organization_id: number
      media_id: number
      slug: string
    }, ExtArgs["result"]["author"]>
    composites: {}
  }

 export  type authorGetPayload<S extends boolean | null | undefined | authorDefaultArgs> = $Result.GetResult<Prisma.$authorPayload, S>

  type authorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<authorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthorCountAggregateInputType | true
    }

  export interface authorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'author' } }
    /**
     * Find zero or one Author that matches the filter.
     * @param {authorFindUniqueArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends authorFindUniqueArgs>(args: SelectSubset<T, authorFindUniqueArgs<ExtArgs>>): Prisma__authorClient<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Author that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {authorFindUniqueOrThrowArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends authorFindUniqueOrThrowArgs>(args: SelectSubset<T, authorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__authorClient<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Author that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorFindFirstArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends authorFindFirstArgs>(args?: SelectSubset<T, authorFindFirstArgs<ExtArgs>>): Prisma__authorClient<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Author that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorFindFirstOrThrowArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends authorFindFirstOrThrowArgs>(args?: SelectSubset<T, authorFindFirstOrThrowArgs<ExtArgs>>): Prisma__authorClient<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Authors
     * const authors = await prisma.author.findMany()
     * 
     * // Get first 10 Authors
     * const authors = await prisma.author.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authorWithIdOnly = await prisma.author.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends authorFindManyArgs>(args?: SelectSubset<T, authorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Author.
     * @param {authorCreateArgs} args - Arguments to create a Author.
     * @example
     * // Create one Author
     * const Author = await prisma.author.create({
     *   data: {
     *     // ... data to create a Author
     *   }
     * })
     * 
     */
    create<T extends authorCreateArgs>(args: SelectSubset<T, authorCreateArgs<ExtArgs>>): Prisma__authorClient<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Authors.
     * @param {authorCreateManyArgs} args - Arguments to create many Authors.
     * @example
     * // Create many Authors
     * const author = await prisma.author.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends authorCreateManyArgs>(args?: SelectSubset<T, authorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Authors and returns the data saved in the database.
     * @param {authorCreateManyAndReturnArgs} args - Arguments to create many Authors.
     * @example
     * // Create many Authors
     * const author = await prisma.author.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Authors and only return the `id`
     * const authorWithIdOnly = await prisma.author.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends authorCreateManyAndReturnArgs>(args?: SelectSubset<T, authorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Author.
     * @param {authorDeleteArgs} args - Arguments to delete one Author.
     * @example
     * // Delete one Author
     * const Author = await prisma.author.delete({
     *   where: {
     *     // ... filter to delete one Author
     *   }
     * })
     * 
     */
    delete<T extends authorDeleteArgs>(args: SelectSubset<T, authorDeleteArgs<ExtArgs>>): Prisma__authorClient<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Author.
     * @param {authorUpdateArgs} args - Arguments to update one Author.
     * @example
     * // Update one Author
     * const author = await prisma.author.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends authorUpdateArgs>(args: SelectSubset<T, authorUpdateArgs<ExtArgs>>): Prisma__authorClient<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Authors.
     * @param {authorDeleteManyArgs} args - Arguments to filter Authors to delete.
     * @example
     * // Delete a few Authors
     * const { count } = await prisma.author.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends authorDeleteManyArgs>(args?: SelectSubset<T, authorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Authors
     * const author = await prisma.author.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends authorUpdateManyArgs>(args: SelectSubset<T, authorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors and returns the data updated in the database.
     * @param {authorUpdateManyAndReturnArgs} args - Arguments to update many Authors.
     * @example
     * // Update many Authors
     * const author = await prisma.author.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Authors and only return the `id`
     * const authorWithIdOnly = await prisma.author.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends authorUpdateManyAndReturnArgs>(args: SelectSubset<T, authorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Author.
     * @param {authorUpsertArgs} args - Arguments to update or create a Author.
     * @example
     * // Update or create a Author
     * const author = await prisma.author.upsert({
     *   create: {
     *     // ... data to create a Author
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Author we want to update
     *   }
     * })
     */
    upsert<T extends authorUpsertArgs>(args: SelectSubset<T, authorUpsertArgs<ExtArgs>>): Prisma__authorClient<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorCountArgs} args - Arguments to filter Authors to count.
     * @example
     * // Count the number of Authors
     * const count = await prisma.author.count({
     *   where: {
     *     // ... the filter for the Authors we want to count
     *   }
     * })
    **/
    count<T extends authorCountArgs>(
      args?: Subset<T, authorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Author.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthorAggregateArgs>(args: Subset<T, AuthorAggregateArgs>): Prisma.PrismaPromise<GetAuthorAggregateType<T>>

    /**
     * Group by Author.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends authorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: authorGroupByArgs['orderBy'] }
        : { orderBy?: authorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, authorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the author model
   */
  readonly fields: authorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for author.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__authorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Content<T extends author$ContentArgs<ExtArgs> = {}>(args?: Subset<T, author$ContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Media<T extends MediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MediaDefaultArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the author model
   */ 
  interface authorFieldRefs {
    readonly id: FieldRef<"author", 'Int'>
    readonly created_at: FieldRef<"author", 'DateTime'>
    readonly updated_at: FieldRef<"author", 'DateTime'>
    readonly name: FieldRef<"author", 'String'>
    readonly description: FieldRef<"author", 'String'>
    readonly organization_id: FieldRef<"author", 'Int'>
    readonly media_id: FieldRef<"author", 'Int'>
    readonly slug: FieldRef<"author", 'String'>
  }
    

  // Custom InputTypes
  /**
   * author findUnique
   */
  export type authorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    /**
     * Filter, which author to fetch.
     */
    where: authorWhereUniqueInput
  }

  /**
   * author findUniqueOrThrow
   */
  export type authorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    /**
     * Filter, which author to fetch.
     */
    where: authorWhereUniqueInput
  }

  /**
   * author findFirst
   */
  export type authorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    /**
     * Filter, which author to fetch.
     */
    where?: authorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authors to fetch.
     */
    orderBy?: authorOrderByWithRelationInput | authorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for authors.
     */
    cursor?: authorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of authors.
     */
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * author findFirstOrThrow
   */
  export type authorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    /**
     * Filter, which author to fetch.
     */
    where?: authorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authors to fetch.
     */
    orderBy?: authorOrderByWithRelationInput | authorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for authors.
     */
    cursor?: authorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of authors.
     */
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * author findMany
   */
  export type authorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    /**
     * Filter, which authors to fetch.
     */
    where?: authorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authors to fetch.
     */
    orderBy?: authorOrderByWithRelationInput | authorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing authors.
     */
    cursor?: authorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authors.
     */
    skip?: number
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * author create
   */
  export type authorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    /**
     * The data needed to create a author.
     */
    data: XOR<authorCreateInput, authorUncheckedCreateInput>
  }

  /**
   * author createMany
   */
  export type authorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many authors.
     */
    data: authorCreateManyInput | authorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * author createManyAndReturn
   */
  export type authorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * The data used to create many authors.
     */
    data: authorCreateManyInput | authorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * author update
   */
  export type authorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    /**
     * The data needed to update a author.
     */
    data: XOR<authorUpdateInput, authorUncheckedUpdateInput>
    /**
     * Choose, which author to update.
     */
    where: authorWhereUniqueInput
  }

  /**
   * author updateMany
   */
  export type authorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update authors.
     */
    data: XOR<authorUpdateManyMutationInput, authorUncheckedUpdateManyInput>
    /**
     * Filter which authors to update
     */
    where?: authorWhereInput
    /**
     * Limit how many authors to update.
     */
    limit?: number
  }

  /**
   * author updateManyAndReturn
   */
  export type authorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * The data used to update authors.
     */
    data: XOR<authorUpdateManyMutationInput, authorUncheckedUpdateManyInput>
    /**
     * Filter which authors to update
     */
    where?: authorWhereInput
    /**
     * Limit how many authors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * author upsert
   */
  export type authorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    /**
     * The filter to search for the author to update in case it exists.
     */
    where: authorWhereUniqueInput
    /**
     * In case the author found by the `where` argument doesn't exist, create a new author with this data.
     */
    create: XOR<authorCreateInput, authorUncheckedCreateInput>
    /**
     * In case the author was found with the provided `where` argument, update it with this data.
     */
    update: XOR<authorUpdateInput, authorUncheckedUpdateInput>
  }

  /**
   * author delete
   */
  export type authorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    /**
     * Filter which author to delete.
     */
    where: authorWhereUniqueInput
  }

  /**
   * author deleteMany
   */
  export type authorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which authors to delete
     */
    where?: authorWhereInput
    /**
     * Limit how many authors to delete.
     */
    limit?: number
  }

  /**
   * author.Content
   */
  export type author$ContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    where?: ContentWhereInput
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    cursor?: ContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * author without action
   */
  export type authorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
  }


  /**
   * Model form_field
   */

  export type AggregateForm_field = {
    _count: Form_fieldCountAggregateOutputType | null
    _avg: Form_fieldAvgAggregateOutputType | null
    _sum: Form_fieldSumAggregateOutputType | null
    _min: Form_fieldMinAggregateOutputType | null
    _max: Form_fieldMaxAggregateOutputType | null
  }

  export type Form_fieldAvgAggregateOutputType = {
    id: number | null
    order: number | null
    organization_id: number | null
    collection_id: number | null
    struct_id: number | null
  }

  export type Form_fieldSumAggregateOutputType = {
    id: number | null
    order: number | null
    organization_id: number | null
    collection_id: number | null
    struct_id: number | null
  }

  export type Form_fieldMinAggregateOutputType = {
    id: number | null
    name: string | null
    required: boolean | null
    created_at: Date | null
    updated_at: Date | null
    type: $Enums.field_type | null
    default_value: string | null
    help: string | null
    order: number | null
    description: string | null
    label: string | null
    placeholder: string | null
    regex: string | null
    organization_id: number | null
    collection_id: number | null
    struct_id: number | null
  }

  export type Form_fieldMaxAggregateOutputType = {
    id: number | null
    name: string | null
    required: boolean | null
    created_at: Date | null
    updated_at: Date | null
    type: $Enums.field_type | null
    default_value: string | null
    help: string | null
    order: number | null
    description: string | null
    label: string | null
    placeholder: string | null
    regex: string | null
    organization_id: number | null
    collection_id: number | null
    struct_id: number | null
  }

  export type Form_fieldCountAggregateOutputType = {
    id: number
    name: number
    required: number
    created_at: number
    updated_at: number
    type: number
    default_value: number
    help: number
    order: number
    description: number
    label: number
    placeholder: number
    regex: number
    organization_id: number
    collection_id: number
    options: number
    struct_id: number
    _all: number
  }


  export type Form_fieldAvgAggregateInputType = {
    id?: true
    order?: true
    organization_id?: true
    collection_id?: true
    struct_id?: true
  }

  export type Form_fieldSumAggregateInputType = {
    id?: true
    order?: true
    organization_id?: true
    collection_id?: true
    struct_id?: true
  }

  export type Form_fieldMinAggregateInputType = {
    id?: true
    name?: true
    required?: true
    created_at?: true
    updated_at?: true
    type?: true
    default_value?: true
    help?: true
    order?: true
    description?: true
    label?: true
    placeholder?: true
    regex?: true
    organization_id?: true
    collection_id?: true
    struct_id?: true
  }

  export type Form_fieldMaxAggregateInputType = {
    id?: true
    name?: true
    required?: true
    created_at?: true
    updated_at?: true
    type?: true
    default_value?: true
    help?: true
    order?: true
    description?: true
    label?: true
    placeholder?: true
    regex?: true
    organization_id?: true
    collection_id?: true
    struct_id?: true
  }

  export type Form_fieldCountAggregateInputType = {
    id?: true
    name?: true
    required?: true
    created_at?: true
    updated_at?: true
    type?: true
    default_value?: true
    help?: true
    order?: true
    description?: true
    label?: true
    placeholder?: true
    regex?: true
    organization_id?: true
    collection_id?: true
    options?: true
    struct_id?: true
    _all?: true
  }

  export type Form_fieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which form_field to aggregate.
     */
    where?: form_fieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of form_fields to fetch.
     */
    orderBy?: form_fieldOrderByWithRelationInput | form_fieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: form_fieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` form_fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` form_fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned form_fields
    **/
    _count?: true | Form_fieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Form_fieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Form_fieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Form_fieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Form_fieldMaxAggregateInputType
  }

  export type GetForm_fieldAggregateType<T extends Form_fieldAggregateArgs> = {
        [P in keyof T & keyof AggregateForm_field]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForm_field[P]>
      : GetScalarType<T[P], AggregateForm_field[P]>
  }




  export type form_fieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: form_fieldWhereInput
    orderBy?: form_fieldOrderByWithAggregationInput | form_fieldOrderByWithAggregationInput[]
    by: Form_fieldScalarFieldEnum[] | Form_fieldScalarFieldEnum
    having?: form_fieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Form_fieldCountAggregateInputType | true
    _avg?: Form_fieldAvgAggregateInputType
    _sum?: Form_fieldSumAggregateInputType
    _min?: Form_fieldMinAggregateInputType
    _max?: Form_fieldMaxAggregateInputType
  }

  export type Form_fieldGroupByOutputType = {
    id: number
    name: string
    required: boolean
    created_at: Date
    updated_at: Date
    type: $Enums.field_type
    default_value: string | null
    help: string | null
    order: number
    description: string | null
    label: string
    placeholder: string | null
    regex: string | null
    organization_id: number
    collection_id: number | null
    options: JsonValue[]
    struct_id: number | null
    _count: Form_fieldCountAggregateOutputType | null
    _avg: Form_fieldAvgAggregateOutputType | null
    _sum: Form_fieldSumAggregateOutputType | null
    _min: Form_fieldMinAggregateOutputType | null
    _max: Form_fieldMaxAggregateOutputType | null
  }

  type GetForm_fieldGroupByPayload<T extends form_fieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Form_fieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Form_fieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Form_fieldGroupByOutputType[P]>
            : GetScalarType<T[P], Form_fieldGroupByOutputType[P]>
        }
      >
    >


  export type form_fieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    required?: boolean
    created_at?: boolean
    updated_at?: boolean
    type?: boolean
    default_value?: boolean
    help?: boolean
    order?: boolean
    description?: boolean
    label?: boolean
    placeholder?: boolean
    regex?: boolean
    organization_id?: boolean
    collection_id?: boolean
    options?: boolean
    struct_id?: boolean
    Collection?: boolean | form_field$CollectionArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    struct?: boolean | form_field$structArgs<ExtArgs>
  }, ExtArgs["result"]["form_field"]>

  export type form_fieldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    required?: boolean
    created_at?: boolean
    updated_at?: boolean
    type?: boolean
    default_value?: boolean
    help?: boolean
    order?: boolean
    description?: boolean
    label?: boolean
    placeholder?: boolean
    regex?: boolean
    organization_id?: boolean
    collection_id?: boolean
    options?: boolean
    struct_id?: boolean
    Collection?: boolean | form_field$CollectionArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    struct?: boolean | form_field$structArgs<ExtArgs>
  }, ExtArgs["result"]["form_field"]>

  export type form_fieldSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    required?: boolean
    created_at?: boolean
    updated_at?: boolean
    type?: boolean
    default_value?: boolean
    help?: boolean
    order?: boolean
    description?: boolean
    label?: boolean
    placeholder?: boolean
    regex?: boolean
    organization_id?: boolean
    collection_id?: boolean
    options?: boolean
    struct_id?: boolean
    Collection?: boolean | form_field$CollectionArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    struct?: boolean | form_field$structArgs<ExtArgs>
  }, ExtArgs["result"]["form_field"]>

  export type form_fieldSelectScalar = {
    id?: boolean
    name?: boolean
    required?: boolean
    created_at?: boolean
    updated_at?: boolean
    type?: boolean
    default_value?: boolean
    help?: boolean
    order?: boolean
    description?: boolean
    label?: boolean
    placeholder?: boolean
    regex?: boolean
    organization_id?: boolean
    collection_id?: boolean
    options?: boolean
    struct_id?: boolean
  }

  export type form_fieldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "required" | "created_at" | "updated_at" | "type" | "default_value" | "help" | "order" | "description" | "label" | "placeholder" | "regex" | "organization_id" | "collection_id" | "options" | "struct_id", ExtArgs["result"]["form_field"]>
  export type form_fieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Collection?: boolean | form_field$CollectionArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    struct?: boolean | form_field$structArgs<ExtArgs>
  }
  export type form_fieldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Collection?: boolean | form_field$CollectionArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    struct?: boolean | form_field$structArgs<ExtArgs>
  }
  export type form_fieldIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Collection?: boolean | form_field$CollectionArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    struct?: boolean | form_field$structArgs<ExtArgs>
  }

  export type $form_fieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "form_field"
    objects: {
      Collection: Prisma.$CollectionPayload<ExtArgs> | null
      Organization: Prisma.$OrganizationPayload<ExtArgs>
      struct: Prisma.$structPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      required: boolean
      created_at: Date
      updated_at: Date
      type: $Enums.field_type
      default_value: string | null
      help: string | null
      order: number
      description: string | null
      label: string
      placeholder: string | null
      regex: string | null
      organization_id: number
      collection_id: number | null
      options: Prisma.JsonValue[]
      struct_id: number | null
    }, ExtArgs["result"]["form_field"]>
    composites: {}
  }

  type form_fieldGetPayload<S extends boolean | null | undefined | form_fieldDefaultArgs> = $Result.GetResult<Prisma.$form_fieldPayload, S>

  type form_fieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<form_fieldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Form_fieldCountAggregateInputType | true
    }

  export interface form_fieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'form_field' } }
    /**
     * Find zero or one Form_field that matches the filter.
     * @param {form_fieldFindUniqueArgs} args - Arguments to find a Form_field
     * @example
     * // Get one Form_field
     * const form_field = await prisma.form_field.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends form_fieldFindUniqueArgs>(args: SelectSubset<T, form_fieldFindUniqueArgs<ExtArgs>>): Prisma__form_fieldClient<$Result.GetResult<Prisma.$form_fieldPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Form_field that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {form_fieldFindUniqueOrThrowArgs} args - Arguments to find a Form_field
     * @example
     * // Get one Form_field
     * const form_field = await prisma.form_field.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends form_fieldFindUniqueOrThrowArgs>(args: SelectSubset<T, form_fieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__form_fieldClient<$Result.GetResult<Prisma.$form_fieldPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Form_field that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {form_fieldFindFirstArgs} args - Arguments to find a Form_field
     * @example
     * // Get one Form_field
     * const form_field = await prisma.form_field.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends form_fieldFindFirstArgs>(args?: SelectSubset<T, form_fieldFindFirstArgs<ExtArgs>>): Prisma__form_fieldClient<$Result.GetResult<Prisma.$form_fieldPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Form_field that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {form_fieldFindFirstOrThrowArgs} args - Arguments to find a Form_field
     * @example
     * // Get one Form_field
     * const form_field = await prisma.form_field.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends form_fieldFindFirstOrThrowArgs>(args?: SelectSubset<T, form_fieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__form_fieldClient<$Result.GetResult<Prisma.$form_fieldPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Form_fields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {form_fieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Form_fields
     * const form_fields = await prisma.form_field.findMany()
     * 
     * // Get first 10 Form_fields
     * const form_fields = await prisma.form_field.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const form_fieldWithIdOnly = await prisma.form_field.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends form_fieldFindManyArgs>(args?: SelectSubset<T, form_fieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$form_fieldPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Form_field.
     * @param {form_fieldCreateArgs} args - Arguments to create a Form_field.
     * @example
     * // Create one Form_field
     * const Form_field = await prisma.form_field.create({
     *   data: {
     *     // ... data to create a Form_field
     *   }
     * })
     * 
     */
    create<T extends form_fieldCreateArgs>(args: SelectSubset<T, form_fieldCreateArgs<ExtArgs>>): Prisma__form_fieldClient<$Result.GetResult<Prisma.$form_fieldPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Form_fields.
     * @param {form_fieldCreateManyArgs} args - Arguments to create many Form_fields.
     * @example
     * // Create many Form_fields
     * const form_field = await prisma.form_field.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends form_fieldCreateManyArgs>(args?: SelectSubset<T, form_fieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Form_fields and returns the data saved in the database.
     * @param {form_fieldCreateManyAndReturnArgs} args - Arguments to create many Form_fields.
     * @example
     * // Create many Form_fields
     * const form_field = await prisma.form_field.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Form_fields and only return the `id`
     * const form_fieldWithIdOnly = await prisma.form_field.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends form_fieldCreateManyAndReturnArgs>(args?: SelectSubset<T, form_fieldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$form_fieldPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Form_field.
     * @param {form_fieldDeleteArgs} args - Arguments to delete one Form_field.
     * @example
     * // Delete one Form_field
     * const Form_field = await prisma.form_field.delete({
     *   where: {
     *     // ... filter to delete one Form_field
     *   }
     * })
     * 
     */
    delete<T extends form_fieldDeleteArgs>(args: SelectSubset<T, form_fieldDeleteArgs<ExtArgs>>): Prisma__form_fieldClient<$Result.GetResult<Prisma.$form_fieldPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Form_field.
     * @param {form_fieldUpdateArgs} args - Arguments to update one Form_field.
     * @example
     * // Update one Form_field
     * const form_field = await prisma.form_field.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends form_fieldUpdateArgs>(args: SelectSubset<T, form_fieldUpdateArgs<ExtArgs>>): Prisma__form_fieldClient<$Result.GetResult<Prisma.$form_fieldPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Form_fields.
     * @param {form_fieldDeleteManyArgs} args - Arguments to filter Form_fields to delete.
     * @example
     * // Delete a few Form_fields
     * const { count } = await prisma.form_field.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends form_fieldDeleteManyArgs>(args?: SelectSubset<T, form_fieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Form_fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {form_fieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Form_fields
     * const form_field = await prisma.form_field.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends form_fieldUpdateManyArgs>(args: SelectSubset<T, form_fieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Form_fields and returns the data updated in the database.
     * @param {form_fieldUpdateManyAndReturnArgs} args - Arguments to update many Form_fields.
     * @example
     * // Update many Form_fields
     * const form_field = await prisma.form_field.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Form_fields and only return the `id`
     * const form_fieldWithIdOnly = await prisma.form_field.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends form_fieldUpdateManyAndReturnArgs>(args: SelectSubset<T, form_fieldUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$form_fieldPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Form_field.
     * @param {form_fieldUpsertArgs} args - Arguments to update or create a Form_field.
     * @example
     * // Update or create a Form_field
     * const form_field = await prisma.form_field.upsert({
     *   create: {
     *     // ... data to create a Form_field
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Form_field we want to update
     *   }
     * })
     */
    upsert<T extends form_fieldUpsertArgs>(args: SelectSubset<T, form_fieldUpsertArgs<ExtArgs>>): Prisma__form_fieldClient<$Result.GetResult<Prisma.$form_fieldPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Form_fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {form_fieldCountArgs} args - Arguments to filter Form_fields to count.
     * @example
     * // Count the number of Form_fields
     * const count = await prisma.form_field.count({
     *   where: {
     *     // ... the filter for the Form_fields we want to count
     *   }
     * })
    **/
    count<T extends form_fieldCountArgs>(
      args?: Subset<T, form_fieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Form_fieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Form_field.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Form_fieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Form_fieldAggregateArgs>(args: Subset<T, Form_fieldAggregateArgs>): Prisma.PrismaPromise<GetForm_fieldAggregateType<T>>

    /**
     * Group by Form_field.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {form_fieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends form_fieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: form_fieldGroupByArgs['orderBy'] }
        : { orderBy?: form_fieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, form_fieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForm_fieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the form_field model
   */
  readonly fields: form_fieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for form_field.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__form_fieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Collection<T extends form_field$CollectionArgs<ExtArgs> = {}>(args?: Subset<T, form_field$CollectionArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    struct<T extends form_field$structArgs<ExtArgs> = {}>(args?: Subset<T, form_field$structArgs<ExtArgs>>): Prisma__structClient<$Result.GetResult<Prisma.$structPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the form_field model
   */ 
  interface form_fieldFieldRefs {
    readonly id: FieldRef<"form_field", 'Int'>
    readonly name: FieldRef<"form_field", 'String'>
    readonly required: FieldRef<"form_field", 'Boolean'>
    readonly created_at: FieldRef<"form_field", 'DateTime'>
    readonly updated_at: FieldRef<"form_field", 'DateTime'>
    readonly type: FieldRef<"form_field", 'field_type'>
    readonly default_value: FieldRef<"form_field", 'String'>
    readonly help: FieldRef<"form_field", 'String'>
    readonly order: FieldRef<"form_field", 'Float'>
    readonly description: FieldRef<"form_field", 'String'>
    readonly label: FieldRef<"form_field", 'String'>
    readonly placeholder: FieldRef<"form_field", 'String'>
    readonly regex: FieldRef<"form_field", 'String'>
    readonly organization_id: FieldRef<"form_field", 'Int'>
    readonly collection_id: FieldRef<"form_field", 'Int'>
    readonly options: FieldRef<"form_field", 'Json[]'>
    readonly struct_id: FieldRef<"form_field", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * form_field findUnique
   */
  export type form_fieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_field
     */
    select?: form_fieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form_field
     */
    omit?: form_fieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: form_fieldInclude<ExtArgs> | null
    /**
     * Filter, which form_field to fetch.
     */
    where: form_fieldWhereUniqueInput
  }

  /**
   * form_field findUniqueOrThrow
   */
  export type form_fieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_field
     */
    select?: form_fieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form_field
     */
    omit?: form_fieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: form_fieldInclude<ExtArgs> | null
    /**
     * Filter, which form_field to fetch.
     */
    where: form_fieldWhereUniqueInput
  }

  /**
   * form_field findFirst
   */
  export type form_fieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_field
     */
    select?: form_fieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form_field
     */
    omit?: form_fieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: form_fieldInclude<ExtArgs> | null
    /**
     * Filter, which form_field to fetch.
     */
    where?: form_fieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of form_fields to fetch.
     */
    orderBy?: form_fieldOrderByWithRelationInput | form_fieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for form_fields.
     */
    cursor?: form_fieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` form_fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` form_fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of form_fields.
     */
    distinct?: Form_fieldScalarFieldEnum | Form_fieldScalarFieldEnum[]
  }

  /**
   * form_field findFirstOrThrow
   */
  export type form_fieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_field
     */
    select?: form_fieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form_field
     */
    omit?: form_fieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: form_fieldInclude<ExtArgs> | null
    /**
     * Filter, which form_field to fetch.
     */
    where?: form_fieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of form_fields to fetch.
     */
    orderBy?: form_fieldOrderByWithRelationInput | form_fieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for form_fields.
     */
    cursor?: form_fieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` form_fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` form_fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of form_fields.
     */
    distinct?: Form_fieldScalarFieldEnum | Form_fieldScalarFieldEnum[]
  }

  /**
   * form_field findMany
   */
  export type form_fieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_field
     */
    select?: form_fieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form_field
     */
    omit?: form_fieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: form_fieldInclude<ExtArgs> | null
    /**
     * Filter, which form_fields to fetch.
     */
    where?: form_fieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of form_fields to fetch.
     */
    orderBy?: form_fieldOrderByWithRelationInput | form_fieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing form_fields.
     */
    cursor?: form_fieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` form_fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` form_fields.
     */
    skip?: number
    distinct?: Form_fieldScalarFieldEnum | Form_fieldScalarFieldEnum[]
  }

  /**
   * form_field create
   */
  export type form_fieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_field
     */
    select?: form_fieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form_field
     */
    omit?: form_fieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: form_fieldInclude<ExtArgs> | null
    /**
     * The data needed to create a form_field.
     */
    data: XOR<form_fieldCreateInput, form_fieldUncheckedCreateInput>
  }

  /**
   * form_field createMany
   */
  export type form_fieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many form_fields.
     */
    data: form_fieldCreateManyInput | form_fieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * form_field createManyAndReturn
   */
  export type form_fieldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_field
     */
    select?: form_fieldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the form_field
     */
    omit?: form_fieldOmit<ExtArgs> | null
    /**
     * The data used to create many form_fields.
     */
    data: form_fieldCreateManyInput | form_fieldCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: form_fieldIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * form_field update
   */
  export type form_fieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_field
     */
    select?: form_fieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form_field
     */
    omit?: form_fieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: form_fieldInclude<ExtArgs> | null
    /**
     * The data needed to update a form_field.
     */
    data: XOR<form_fieldUpdateInput, form_fieldUncheckedUpdateInput>
    /**
     * Choose, which form_field to update.
     */
    where: form_fieldWhereUniqueInput
  }

  /**
   * form_field updateMany
   */
  export type form_fieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update form_fields.
     */
    data: XOR<form_fieldUpdateManyMutationInput, form_fieldUncheckedUpdateManyInput>
    /**
     * Filter which form_fields to update
     */
    where?: form_fieldWhereInput
    /**
     * Limit how many form_fields to update.
     */
    limit?: number
  }

  /**
   * form_field updateManyAndReturn
   */
  export type form_fieldUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_field
     */
    select?: form_fieldSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the form_field
     */
    omit?: form_fieldOmit<ExtArgs> | null
    /**
     * The data used to update form_fields.
     */
    data: XOR<form_fieldUpdateManyMutationInput, form_fieldUncheckedUpdateManyInput>
    /**
     * Filter which form_fields to update
     */
    where?: form_fieldWhereInput
    /**
     * Limit how many form_fields to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: form_fieldIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * form_field upsert
   */
  export type form_fieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_field
     */
    select?: form_fieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form_field
     */
    omit?: form_fieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: form_fieldInclude<ExtArgs> | null
    /**
     * The filter to search for the form_field to update in case it exists.
     */
    where: form_fieldWhereUniqueInput
    /**
     * In case the form_field found by the `where` argument doesn't exist, create a new form_field with this data.
     */
    create: XOR<form_fieldCreateInput, form_fieldUncheckedCreateInput>
    /**
     * In case the form_field was found with the provided `where` argument, update it with this data.
     */
    update: XOR<form_fieldUpdateInput, form_fieldUncheckedUpdateInput>
  }

  /**
   * form_field delete
   */
  export type form_fieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_field
     */
    select?: form_fieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form_field
     */
    omit?: form_fieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: form_fieldInclude<ExtArgs> | null
    /**
     * Filter which form_field to delete.
     */
    where: form_fieldWhereUniqueInput
  }

  /**
   * form_field deleteMany
   */
  export type form_fieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which form_fields to delete
     */
    where?: form_fieldWhereInput
    /**
     * Limit how many form_fields to delete.
     */
    limit?: number
  }

  /**
   * form_field.Collection
   */
  export type form_field$CollectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    where?: CollectionWhereInput
  }

  /**
   * form_field.struct
   */
  export type form_field$structArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct
     */
    select?: structSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct
     */
    omit?: structOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structInclude<ExtArgs> | null
    where?: structWhereInput
  }

  /**
   * form_field without action
   */
  export type form_fieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_field
     */
    select?: form_fieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form_field
     */
    omit?: form_fieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: form_fieldInclude<ExtArgs> | null
  }


  /**
   * Model org_details
   */

  export type AggregateOrg_details = {
    _count: Org_detailsCountAggregateOutputType | null
    _avg: Org_detailsAvgAggregateOutputType | null
    _sum: Org_detailsSumAggregateOutputType | null
    _min: Org_detailsMinAggregateOutputType | null
    _max: Org_detailsMaxAggregateOutputType | null
  }

  export type Org_detailsAvgAggregateOutputType = {
    id: number | null
    media_id: number | null
    organization_id: number | null
  }

  export type Org_detailsSumAggregateOutputType = {
    id: number | null
    media_id: number | null
    organization_id: number | null
  }

  export type Org_detailsMinAggregateOutputType = {
    gtag: string | null
    url: string | null
    company_name: string | null
    phone: string | null
    email: string | null
    street_address: string | null
    city: string | null
    state: string | null
    country: string | null
    postal_code: string | null
    company_description: string | null
    created_at: Date | null
    id: number | null
    media_id: number | null
    organization_id: number | null
    updated_at: Date | null
  }

  export type Org_detailsMaxAggregateOutputType = {
    gtag: string | null
    url: string | null
    company_name: string | null
    phone: string | null
    email: string | null
    street_address: string | null
    city: string | null
    state: string | null
    country: string | null
    postal_code: string | null
    company_description: string | null
    created_at: Date | null
    id: number | null
    media_id: number | null
    organization_id: number | null
    updated_at: Date | null
  }

  export type Org_detailsCountAggregateOutputType = {
    gtag: number
    url: number
    company_name: number
    phone: number
    email: number
    street_address: number
    city: number
    state: number
    country: number
    postal_code: number
    socials: number
    company_description: number
    created_at: number
    id: number
    media_id: number
    organization_id: number
    updated_at: number
    _all: number
  }


  export type Org_detailsAvgAggregateInputType = {
    id?: true
    media_id?: true
    organization_id?: true
  }

  export type Org_detailsSumAggregateInputType = {
    id?: true
    media_id?: true
    organization_id?: true
  }

  export type Org_detailsMinAggregateInputType = {
    gtag?: true
    url?: true
    company_name?: true
    phone?: true
    email?: true
    street_address?: true
    city?: true
    state?: true
    country?: true
    postal_code?: true
    company_description?: true
    created_at?: true
    id?: true
    media_id?: true
    organization_id?: true
    updated_at?: true
  }

  export type Org_detailsMaxAggregateInputType = {
    gtag?: true
    url?: true
    company_name?: true
    phone?: true
    email?: true
    street_address?: true
    city?: true
    state?: true
    country?: true
    postal_code?: true
    company_description?: true
    created_at?: true
    id?: true
    media_id?: true
    organization_id?: true
    updated_at?: true
  }

  export type Org_detailsCountAggregateInputType = {
    gtag?: true
    url?: true
    company_name?: true
    phone?: true
    email?: true
    street_address?: true
    city?: true
    state?: true
    country?: true
    postal_code?: true
    socials?: true
    company_description?: true
    created_at?: true
    id?: true
    media_id?: true
    organization_id?: true
    updated_at?: true
    _all?: true
  }

  export type Org_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which org_details to aggregate.
     */
    where?: org_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of org_details to fetch.
     */
    orderBy?: org_detailsOrderByWithRelationInput | org_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: org_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` org_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` org_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned org_details
    **/
    _count?: true | Org_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Org_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Org_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Org_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Org_detailsMaxAggregateInputType
  }

  export type GetOrg_detailsAggregateType<T extends Org_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateOrg_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrg_details[P]>
      : GetScalarType<T[P], AggregateOrg_details[P]>
  }




  export type org_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: org_detailsWhereInput
    orderBy?: org_detailsOrderByWithAggregationInput | org_detailsOrderByWithAggregationInput[]
    by: Org_detailsScalarFieldEnum[] | Org_detailsScalarFieldEnum
    having?: org_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Org_detailsCountAggregateInputType | true
    _avg?: Org_detailsAvgAggregateInputType
    _sum?: Org_detailsSumAggregateInputType
    _min?: Org_detailsMinAggregateInputType
    _max?: Org_detailsMaxAggregateInputType
  }

  export type Org_detailsGroupByOutputType = {
    gtag: string | null
    url: string | null
    company_name: string | null
    phone: string | null
    email: string | null
    street_address: string | null
    city: string | null
    state: string | null
    country: string | null
    postal_code: string | null
    socials: string[]
    company_description: string | null
    created_at: Date
    id: number
    media_id: number | null
    organization_id: number
    updated_at: Date
    _count: Org_detailsCountAggregateOutputType | null
    _avg: Org_detailsAvgAggregateOutputType | null
    _sum: Org_detailsSumAggregateOutputType | null
    _min: Org_detailsMinAggregateOutputType | null
    _max: Org_detailsMaxAggregateOutputType | null
  }

  type GetOrg_detailsGroupByPayload<T extends org_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Org_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Org_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Org_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Org_detailsGroupByOutputType[P]>
        }
      >
    >


  export type org_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    gtag?: boolean
    url?: boolean
    company_name?: boolean
    phone?: boolean
    email?: boolean
    street_address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postal_code?: boolean
    socials?: boolean
    company_description?: boolean
    created_at?: boolean
    id?: boolean
    media_id?: boolean
    organization_id?: boolean
    updated_at?: boolean
    Media?: boolean | org_details$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["org_details"]>

  export type org_detailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    gtag?: boolean
    url?: boolean
    company_name?: boolean
    phone?: boolean
    email?: boolean
    street_address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postal_code?: boolean
    socials?: boolean
    company_description?: boolean
    created_at?: boolean
    id?: boolean
    media_id?: boolean
    organization_id?: boolean
    updated_at?: boolean
    Media?: boolean | org_details$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["org_details"]>

  export type org_detailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    gtag?: boolean
    url?: boolean
    company_name?: boolean
    phone?: boolean
    email?: boolean
    street_address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postal_code?: boolean
    socials?: boolean
    company_description?: boolean
    created_at?: boolean
    id?: boolean
    media_id?: boolean
    organization_id?: boolean
    updated_at?: boolean
    Media?: boolean | org_details$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["org_details"]>

  export type org_detailsSelectScalar = {
    gtag?: boolean
    url?: boolean
    company_name?: boolean
    phone?: boolean
    email?: boolean
    street_address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postal_code?: boolean
    socials?: boolean
    company_description?: boolean
    created_at?: boolean
    id?: boolean
    media_id?: boolean
    organization_id?: boolean
    updated_at?: boolean
  }

  export type org_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"gtag" | "url" | "company_name" | "phone" | "email" | "street_address" | "city" | "state" | "country" | "postal_code" | "socials" | "company_description" | "created_at" | "id" | "media_id" | "organization_id" | "updated_at", ExtArgs["result"]["org_details"]>
  export type org_detailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Media?: boolean | org_details$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type org_detailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Media?: boolean | org_details$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type org_detailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Media?: boolean | org_details$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $org_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "org_details"
    objects: {
      Media: Prisma.$MediaPayload<ExtArgs> | null
      Organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      gtag: string | null
      url: string | null
      company_name: string | null
      phone: string | null
      email: string | null
      street_address: string | null
      city: string | null
      state: string | null
      country: string | null
      postal_code: string | null
      socials: string[]
      company_description: string | null
      created_at: Date
      id: number
      media_id: number | null
      organization_id: number
      updated_at: Date
    }, ExtArgs["result"]["org_details"]>
    composites: {}
  }

  type org_detailsGetPayload<S extends boolean | null | undefined | org_detailsDefaultArgs> = $Result.GetResult<Prisma.$org_detailsPayload, S>

  type org_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<org_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Org_detailsCountAggregateInputType | true
    }

  export interface org_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'org_details' } }
    /**
     * Find zero or one Org_details that matches the filter.
     * @param {org_detailsFindUniqueArgs} args - Arguments to find a Org_details
     * @example
     * // Get one Org_details
     * const org_details = await prisma.org_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends org_detailsFindUniqueArgs>(args: SelectSubset<T, org_detailsFindUniqueArgs<ExtArgs>>): Prisma__org_detailsClient<$Result.GetResult<Prisma.$org_detailsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Org_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {org_detailsFindUniqueOrThrowArgs} args - Arguments to find a Org_details
     * @example
     * // Get one Org_details
     * const org_details = await prisma.org_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends org_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, org_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__org_detailsClient<$Result.GetResult<Prisma.$org_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Org_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {org_detailsFindFirstArgs} args - Arguments to find a Org_details
     * @example
     * // Get one Org_details
     * const org_details = await prisma.org_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends org_detailsFindFirstArgs>(args?: SelectSubset<T, org_detailsFindFirstArgs<ExtArgs>>): Prisma__org_detailsClient<$Result.GetResult<Prisma.$org_detailsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Org_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {org_detailsFindFirstOrThrowArgs} args - Arguments to find a Org_details
     * @example
     * // Get one Org_details
     * const org_details = await prisma.org_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends org_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, org_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__org_detailsClient<$Result.GetResult<Prisma.$org_detailsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Org_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {org_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Org_details
     * const org_details = await prisma.org_details.findMany()
     * 
     * // Get first 10 Org_details
     * const org_details = await prisma.org_details.findMany({ take: 10 })
     * 
     * // Only select the `gtag`
     * const org_detailsWithGtagOnly = await prisma.org_details.findMany({ select: { gtag: true } })
     * 
     */
    findMany<T extends org_detailsFindManyArgs>(args?: SelectSubset<T, org_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$org_detailsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Org_details.
     * @param {org_detailsCreateArgs} args - Arguments to create a Org_details.
     * @example
     * // Create one Org_details
     * const Org_details = await prisma.org_details.create({
     *   data: {
     *     // ... data to create a Org_details
     *   }
     * })
     * 
     */
    create<T extends org_detailsCreateArgs>(args: SelectSubset<T, org_detailsCreateArgs<ExtArgs>>): Prisma__org_detailsClient<$Result.GetResult<Prisma.$org_detailsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Org_details.
     * @param {org_detailsCreateManyArgs} args - Arguments to create many Org_details.
     * @example
     * // Create many Org_details
     * const org_details = await prisma.org_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends org_detailsCreateManyArgs>(args?: SelectSubset<T, org_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Org_details and returns the data saved in the database.
     * @param {org_detailsCreateManyAndReturnArgs} args - Arguments to create many Org_details.
     * @example
     * // Create many Org_details
     * const org_details = await prisma.org_details.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Org_details and only return the `gtag`
     * const org_detailsWithGtagOnly = await prisma.org_details.createManyAndReturn({
     *   select: { gtag: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends org_detailsCreateManyAndReturnArgs>(args?: SelectSubset<T, org_detailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$org_detailsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Org_details.
     * @param {org_detailsDeleteArgs} args - Arguments to delete one Org_details.
     * @example
     * // Delete one Org_details
     * const Org_details = await prisma.org_details.delete({
     *   where: {
     *     // ... filter to delete one Org_details
     *   }
     * })
     * 
     */
    delete<T extends org_detailsDeleteArgs>(args: SelectSubset<T, org_detailsDeleteArgs<ExtArgs>>): Prisma__org_detailsClient<$Result.GetResult<Prisma.$org_detailsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Org_details.
     * @param {org_detailsUpdateArgs} args - Arguments to update one Org_details.
     * @example
     * // Update one Org_details
     * const org_details = await prisma.org_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends org_detailsUpdateArgs>(args: SelectSubset<T, org_detailsUpdateArgs<ExtArgs>>): Prisma__org_detailsClient<$Result.GetResult<Prisma.$org_detailsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Org_details.
     * @param {org_detailsDeleteManyArgs} args - Arguments to filter Org_details to delete.
     * @example
     * // Delete a few Org_details
     * const { count } = await prisma.org_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends org_detailsDeleteManyArgs>(args?: SelectSubset<T, org_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Org_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {org_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Org_details
     * const org_details = await prisma.org_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends org_detailsUpdateManyArgs>(args: SelectSubset<T, org_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Org_details and returns the data updated in the database.
     * @param {org_detailsUpdateManyAndReturnArgs} args - Arguments to update many Org_details.
     * @example
     * // Update many Org_details
     * const org_details = await prisma.org_details.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Org_details and only return the `gtag`
     * const org_detailsWithGtagOnly = await prisma.org_details.updateManyAndReturn({
     *   select: { gtag: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends org_detailsUpdateManyAndReturnArgs>(args: SelectSubset<T, org_detailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$org_detailsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Org_details.
     * @param {org_detailsUpsertArgs} args - Arguments to update or create a Org_details.
     * @example
     * // Update or create a Org_details
     * const org_details = await prisma.org_details.upsert({
     *   create: {
     *     // ... data to create a Org_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Org_details we want to update
     *   }
     * })
     */
    upsert<T extends org_detailsUpsertArgs>(args: SelectSubset<T, org_detailsUpsertArgs<ExtArgs>>): Prisma__org_detailsClient<$Result.GetResult<Prisma.$org_detailsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Org_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {org_detailsCountArgs} args - Arguments to filter Org_details to count.
     * @example
     * // Count the number of Org_details
     * const count = await prisma.org_details.count({
     *   where: {
     *     // ... the filter for the Org_details we want to count
     *   }
     * })
    **/
    count<T extends org_detailsCountArgs>(
      args?: Subset<T, org_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Org_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Org_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Org_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Org_detailsAggregateArgs>(args: Subset<T, Org_detailsAggregateArgs>): Prisma.PrismaPromise<GetOrg_detailsAggregateType<T>>

    /**
     * Group by Org_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {org_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends org_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: org_detailsGroupByArgs['orderBy'] }
        : { orderBy?: org_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, org_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrg_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the org_details model
   */
  readonly fields: org_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for org_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__org_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Media<T extends org_details$MediaArgs<ExtArgs> = {}>(args?: Subset<T, org_details$MediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the org_details model
   */ 
  interface org_detailsFieldRefs {
    readonly gtag: FieldRef<"org_details", 'String'>
    readonly url: FieldRef<"org_details", 'String'>
    readonly company_name: FieldRef<"org_details", 'String'>
    readonly phone: FieldRef<"org_details", 'String'>
    readonly email: FieldRef<"org_details", 'String'>
    readonly street_address: FieldRef<"org_details", 'String'>
    readonly city: FieldRef<"org_details", 'String'>
    readonly state: FieldRef<"org_details", 'String'>
    readonly country: FieldRef<"org_details", 'String'>
    readonly postal_code: FieldRef<"org_details", 'String'>
    readonly socials: FieldRef<"org_details", 'String[]'>
    readonly company_description: FieldRef<"org_details", 'String'>
    readonly created_at: FieldRef<"org_details", 'DateTime'>
    readonly id: FieldRef<"org_details", 'Int'>
    readonly media_id: FieldRef<"org_details", 'Int'>
    readonly organization_id: FieldRef<"org_details", 'Int'>
    readonly updated_at: FieldRef<"org_details", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * org_details findUnique
   */
  export type org_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the org_details
     */
    select?: org_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the org_details
     */
    omit?: org_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: org_detailsInclude<ExtArgs> | null
    /**
     * Filter, which org_details to fetch.
     */
    where: org_detailsWhereUniqueInput
  }

  /**
   * org_details findUniqueOrThrow
   */
  export type org_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the org_details
     */
    select?: org_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the org_details
     */
    omit?: org_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: org_detailsInclude<ExtArgs> | null
    /**
     * Filter, which org_details to fetch.
     */
    where: org_detailsWhereUniqueInput
  }

  /**
   * org_details findFirst
   */
  export type org_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the org_details
     */
    select?: org_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the org_details
     */
    omit?: org_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: org_detailsInclude<ExtArgs> | null
    /**
     * Filter, which org_details to fetch.
     */
    where?: org_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of org_details to fetch.
     */
    orderBy?: org_detailsOrderByWithRelationInput | org_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for org_details.
     */
    cursor?: org_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` org_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` org_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of org_details.
     */
    distinct?: Org_detailsScalarFieldEnum | Org_detailsScalarFieldEnum[]
  }

  /**
   * org_details findFirstOrThrow
   */
  export type org_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the org_details
     */
    select?: org_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the org_details
     */
    omit?: org_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: org_detailsInclude<ExtArgs> | null
    /**
     * Filter, which org_details to fetch.
     */
    where?: org_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of org_details to fetch.
     */
    orderBy?: org_detailsOrderByWithRelationInput | org_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for org_details.
     */
    cursor?: org_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` org_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` org_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of org_details.
     */
    distinct?: Org_detailsScalarFieldEnum | Org_detailsScalarFieldEnum[]
  }

  /**
   * org_details findMany
   */
  export type org_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the org_details
     */
    select?: org_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the org_details
     */
    omit?: org_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: org_detailsInclude<ExtArgs> | null
    /**
     * Filter, which org_details to fetch.
     */
    where?: org_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of org_details to fetch.
     */
    orderBy?: org_detailsOrderByWithRelationInput | org_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing org_details.
     */
    cursor?: org_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` org_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` org_details.
     */
    skip?: number
    distinct?: Org_detailsScalarFieldEnum | Org_detailsScalarFieldEnum[]
  }

  /**
   * org_details create
   */
  export type org_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the org_details
     */
    select?: org_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the org_details
     */
    omit?: org_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: org_detailsInclude<ExtArgs> | null
    /**
     * The data needed to create a org_details.
     */
    data: XOR<org_detailsCreateInput, org_detailsUncheckedCreateInput>
  }

  /**
   * org_details createMany
   */
  export type org_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many org_details.
     */
    data: org_detailsCreateManyInput | org_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * org_details createManyAndReturn
   */
  export type org_detailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the org_details
     */
    select?: org_detailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the org_details
     */
    omit?: org_detailsOmit<ExtArgs> | null
    /**
     * The data used to create many org_details.
     */
    data: org_detailsCreateManyInput | org_detailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: org_detailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * org_details update
   */
  export type org_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the org_details
     */
    select?: org_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the org_details
     */
    omit?: org_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: org_detailsInclude<ExtArgs> | null
    /**
     * The data needed to update a org_details.
     */
    data: XOR<org_detailsUpdateInput, org_detailsUncheckedUpdateInput>
    /**
     * Choose, which org_details to update.
     */
    where: org_detailsWhereUniqueInput
  }

  /**
   * org_details updateMany
   */
  export type org_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update org_details.
     */
    data: XOR<org_detailsUpdateManyMutationInput, org_detailsUncheckedUpdateManyInput>
    /**
     * Filter which org_details to update
     */
    where?: org_detailsWhereInput
    /**
     * Limit how many org_details to update.
     */
    limit?: number
  }

  /**
   * org_details updateManyAndReturn
   */
  export type org_detailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the org_details
     */
    select?: org_detailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the org_details
     */
    omit?: org_detailsOmit<ExtArgs> | null
    /**
     * The data used to update org_details.
     */
    data: XOR<org_detailsUpdateManyMutationInput, org_detailsUncheckedUpdateManyInput>
    /**
     * Filter which org_details to update
     */
    where?: org_detailsWhereInput
    /**
     * Limit how many org_details to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: org_detailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * org_details upsert
   */
  export type org_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the org_details
     */
    select?: org_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the org_details
     */
    omit?: org_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: org_detailsInclude<ExtArgs> | null
    /**
     * The filter to search for the org_details to update in case it exists.
     */
    where: org_detailsWhereUniqueInput
    /**
     * In case the org_details found by the `where` argument doesn't exist, create a new org_details with this data.
     */
    create: XOR<org_detailsCreateInput, org_detailsUncheckedCreateInput>
    /**
     * In case the org_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<org_detailsUpdateInput, org_detailsUncheckedUpdateInput>
  }

  /**
   * org_details delete
   */
  export type org_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the org_details
     */
    select?: org_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the org_details
     */
    omit?: org_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: org_detailsInclude<ExtArgs> | null
    /**
     * Filter which org_details to delete.
     */
    where: org_detailsWhereUniqueInput
  }

  /**
   * org_details deleteMany
   */
  export type org_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which org_details to delete
     */
    where?: org_detailsWhereInput
    /**
     * Limit how many org_details to delete.
     */
    limit?: number
  }

  /**
   * org_details.Media
   */
  export type org_details$MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * org_details without action
   */
  export type org_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the org_details
     */
    select?: org_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the org_details
     */
    omit?: org_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: org_detailsInclude<ExtArgs> | null
  }


  /**
   * Model struct
   */

  export type AggregateStruct = {
    _count: StructCountAggregateOutputType | null
    _avg: StructAvgAggregateOutputType | null
    _sum: StructSumAggregateOutputType | null
    _min: StructMinAggregateOutputType | null
    _max: StructMaxAggregateOutputType | null
  }

  export type StructAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
    media_id: number | null
  }

  export type StructSumAggregateOutputType = {
    id: number | null
    organization_id: number | null
    media_id: number | null
  }

  export type StructMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    group: string | null
    organization_id: number | null
    cms: boolean | null
    description: string | null
    media_id: number | null
  }

  export type StructMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    group: string | null
    organization_id: number | null
    cms: boolean | null
    description: string | null
    media_id: number | null
  }

  export type StructCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    name: number
    group: number
    organization_id: number
    cms: number
    description: number
    media_id: number
    _all: number
  }


  export type StructAvgAggregateInputType = {
    id?: true
    organization_id?: true
    media_id?: true
  }

  export type StructSumAggregateInputType = {
    id?: true
    organization_id?: true
    media_id?: true
  }

  export type StructMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    group?: true
    organization_id?: true
    cms?: true
    description?: true
    media_id?: true
  }

  export type StructMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    group?: true
    organization_id?: true
    cms?: true
    description?: true
    media_id?: true
  }

  export type StructCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    group?: true
    organization_id?: true
    cms?: true
    description?: true
    media_id?: true
    _all?: true
  }

  export type StructAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which struct to aggregate.
     */
    where?: structWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of structs to fetch.
     */
    orderBy?: structOrderByWithRelationInput | structOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: structWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` structs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` structs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned structs
    **/
    _count?: true | StructCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StructAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StructSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StructMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StructMaxAggregateInputType
  }

  export type GetStructAggregateType<T extends StructAggregateArgs> = {
        [P in keyof T & keyof AggregateStruct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStruct[P]>
      : GetScalarType<T[P], AggregateStruct[P]>
  }




  export type structGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: structWhereInput
    orderBy?: structOrderByWithAggregationInput | structOrderByWithAggregationInput[]
    by: StructScalarFieldEnum[] | StructScalarFieldEnum
    having?: structScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StructCountAggregateInputType | true
    _avg?: StructAvgAggregateInputType
    _sum?: StructSumAggregateInputType
    _min?: StructMinAggregateInputType
    _max?: StructMaxAggregateInputType
  }

  export type StructGroupByOutputType = {
    id: number
    created_at: Date
    updated_at: Date
    name: string
    group: string
    organization_id: number
    cms: boolean
    description: string | null
    media_id: number | null
    _count: StructCountAggregateOutputType | null
    _avg: StructAvgAggregateOutputType | null
    _sum: StructSumAggregateOutputType | null
    _min: StructMinAggregateOutputType | null
    _max: StructMaxAggregateOutputType | null
  }

  type GetStructGroupByPayload<T extends structGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StructGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StructGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StructGroupByOutputType[P]>
            : GetScalarType<T[P], StructGroupByOutputType[P]>
        }
      >
    >


  export type structSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    group?: boolean
    organization_id?: boolean
    cms?: boolean
    description?: boolean
    media_id?: boolean
    form_field?: boolean | struct$form_fieldArgs<ExtArgs>
    Media?: boolean | struct$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    struct_set_instance?: boolean | struct$struct_set_instanceArgs<ExtArgs>
    _count?: boolean | StructCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["struct"]>

  export type structSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    group?: boolean
    organization_id?: boolean
    cms?: boolean
    description?: boolean
    media_id?: boolean
    Media?: boolean | struct$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["struct"]>

  export type structSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    group?: boolean
    organization_id?: boolean
    cms?: boolean
    description?: boolean
    media_id?: boolean
    Media?: boolean | struct$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["struct"]>

  export type structSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    group?: boolean
    organization_id?: boolean
    cms?: boolean
    description?: boolean
    media_id?: boolean
  }

  export type structOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "name" | "group" | "organization_id" | "cms" | "description" | "media_id", ExtArgs["result"]["struct"]>
  export type structInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form_field?: boolean | struct$form_fieldArgs<ExtArgs>
    Media?: boolean | struct$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    struct_set_instance?: boolean | struct$struct_set_instanceArgs<ExtArgs>
    _count?: boolean | StructCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type structIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Media?: boolean | struct$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type structIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Media?: boolean | struct$MediaArgs<ExtArgs>
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $structPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "struct"
    objects: {
      form_field: Prisma.$form_fieldPayload<ExtArgs>[]
      Media: Prisma.$MediaPayload<ExtArgs> | null
      Organization: Prisma.$OrganizationPayload<ExtArgs>
      struct_set_instance: Prisma.$struct_set_instancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      created_at: Date
      updated_at: Date
      name: string
      group: string
      organization_id: number
      cms: boolean
      description: string | null
      media_id: number | null
    }, ExtArgs["result"]["struct"]>
    composites: {}
  }

  type structGetPayload<S extends boolean | null | undefined | structDefaultArgs> = $Result.GetResult<Prisma.$structPayload, S>

  type structCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<structFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StructCountAggregateInputType | true
    }

  export interface structDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'struct' } }
    /**
     * Find zero or one Struct that matches the filter.
     * @param {structFindUniqueArgs} args - Arguments to find a Struct
     * @example
     * // Get one Struct
     * const struct = await prisma.struct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends structFindUniqueArgs>(args: SelectSubset<T, structFindUniqueArgs<ExtArgs>>): Prisma__structClient<$Result.GetResult<Prisma.$structPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Struct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {structFindUniqueOrThrowArgs} args - Arguments to find a Struct
     * @example
     * // Get one Struct
     * const struct = await prisma.struct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends structFindUniqueOrThrowArgs>(args: SelectSubset<T, structFindUniqueOrThrowArgs<ExtArgs>>): Prisma__structClient<$Result.GetResult<Prisma.$structPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Struct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {structFindFirstArgs} args - Arguments to find a Struct
     * @example
     * // Get one Struct
     * const struct = await prisma.struct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends structFindFirstArgs>(args?: SelectSubset<T, structFindFirstArgs<ExtArgs>>): Prisma__structClient<$Result.GetResult<Prisma.$structPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Struct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {structFindFirstOrThrowArgs} args - Arguments to find a Struct
     * @example
     * // Get one Struct
     * const struct = await prisma.struct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends structFindFirstOrThrowArgs>(args?: SelectSubset<T, structFindFirstOrThrowArgs<ExtArgs>>): Prisma__structClient<$Result.GetResult<Prisma.$structPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Structs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {structFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Structs
     * const structs = await prisma.struct.findMany()
     * 
     * // Get first 10 Structs
     * const structs = await prisma.struct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const structWithIdOnly = await prisma.struct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends structFindManyArgs>(args?: SelectSubset<T, structFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$structPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Struct.
     * @param {structCreateArgs} args - Arguments to create a Struct.
     * @example
     * // Create one Struct
     * const Struct = await prisma.struct.create({
     *   data: {
     *     // ... data to create a Struct
     *   }
     * })
     * 
     */
    create<T extends structCreateArgs>(args: SelectSubset<T, structCreateArgs<ExtArgs>>): Prisma__structClient<$Result.GetResult<Prisma.$structPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Structs.
     * @param {structCreateManyArgs} args - Arguments to create many Structs.
     * @example
     * // Create many Structs
     * const struct = await prisma.struct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends structCreateManyArgs>(args?: SelectSubset<T, structCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Structs and returns the data saved in the database.
     * @param {structCreateManyAndReturnArgs} args - Arguments to create many Structs.
     * @example
     * // Create many Structs
     * const struct = await prisma.struct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Structs and only return the `id`
     * const structWithIdOnly = await prisma.struct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends structCreateManyAndReturnArgs>(args?: SelectSubset<T, structCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$structPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Struct.
     * @param {structDeleteArgs} args - Arguments to delete one Struct.
     * @example
     * // Delete one Struct
     * const Struct = await prisma.struct.delete({
     *   where: {
     *     // ... filter to delete one Struct
     *   }
     * })
     * 
     */
    delete<T extends structDeleteArgs>(args: SelectSubset<T, structDeleteArgs<ExtArgs>>): Prisma__structClient<$Result.GetResult<Prisma.$structPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Struct.
     * @param {structUpdateArgs} args - Arguments to update one Struct.
     * @example
     * // Update one Struct
     * const struct = await prisma.struct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends structUpdateArgs>(args: SelectSubset<T, structUpdateArgs<ExtArgs>>): Prisma__structClient<$Result.GetResult<Prisma.$structPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Structs.
     * @param {structDeleteManyArgs} args - Arguments to filter Structs to delete.
     * @example
     * // Delete a few Structs
     * const { count } = await prisma.struct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends structDeleteManyArgs>(args?: SelectSubset<T, structDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Structs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {structUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Structs
     * const struct = await prisma.struct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends structUpdateManyArgs>(args: SelectSubset<T, structUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Structs and returns the data updated in the database.
     * @param {structUpdateManyAndReturnArgs} args - Arguments to update many Structs.
     * @example
     * // Update many Structs
     * const struct = await prisma.struct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Structs and only return the `id`
     * const structWithIdOnly = await prisma.struct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends structUpdateManyAndReturnArgs>(args: SelectSubset<T, structUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$structPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Struct.
     * @param {structUpsertArgs} args - Arguments to update or create a Struct.
     * @example
     * // Update or create a Struct
     * const struct = await prisma.struct.upsert({
     *   create: {
     *     // ... data to create a Struct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Struct we want to update
     *   }
     * })
     */
    upsert<T extends structUpsertArgs>(args: SelectSubset<T, structUpsertArgs<ExtArgs>>): Prisma__structClient<$Result.GetResult<Prisma.$structPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Structs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {structCountArgs} args - Arguments to filter Structs to count.
     * @example
     * // Count the number of Structs
     * const count = await prisma.struct.count({
     *   where: {
     *     // ... the filter for the Structs we want to count
     *   }
     * })
    **/
    count<T extends structCountArgs>(
      args?: Subset<T, structCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StructCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Struct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StructAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StructAggregateArgs>(args: Subset<T, StructAggregateArgs>): Prisma.PrismaPromise<GetStructAggregateType<T>>

    /**
     * Group by Struct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {structGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends structGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: structGroupByArgs['orderBy'] }
        : { orderBy?: structGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, structGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStructGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the struct model
   */
  readonly fields: structFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for struct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__structClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    form_field<T extends struct$form_fieldArgs<ExtArgs> = {}>(args?: Subset<T, struct$form_fieldArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$form_fieldPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Media<T extends struct$MediaArgs<ExtArgs> = {}>(args?: Subset<T, struct$MediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    struct_set_instance<T extends struct$struct_set_instanceArgs<ExtArgs> = {}>(args?: Subset<T, struct$struct_set_instanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$struct_set_instancePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the struct model
   */ 
  interface structFieldRefs {
    readonly id: FieldRef<"struct", 'Int'>
    readonly created_at: FieldRef<"struct", 'DateTime'>
    readonly updated_at: FieldRef<"struct", 'DateTime'>
    readonly name: FieldRef<"struct", 'String'>
    readonly group: FieldRef<"struct", 'String'>
    readonly organization_id: FieldRef<"struct", 'Int'>
    readonly cms: FieldRef<"struct", 'Boolean'>
    readonly description: FieldRef<"struct", 'String'>
    readonly media_id: FieldRef<"struct", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * struct findUnique
   */
  export type structFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct
     */
    select?: structSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct
     */
    omit?: structOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structInclude<ExtArgs> | null
    /**
     * Filter, which struct to fetch.
     */
    where: structWhereUniqueInput
  }

  /**
   * struct findUniqueOrThrow
   */
  export type structFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct
     */
    select?: structSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct
     */
    omit?: structOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structInclude<ExtArgs> | null
    /**
     * Filter, which struct to fetch.
     */
    where: structWhereUniqueInput
  }

  /**
   * struct findFirst
   */
  export type structFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct
     */
    select?: structSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct
     */
    omit?: structOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structInclude<ExtArgs> | null
    /**
     * Filter, which struct to fetch.
     */
    where?: structWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of structs to fetch.
     */
    orderBy?: structOrderByWithRelationInput | structOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for structs.
     */
    cursor?: structWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` structs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` structs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of structs.
     */
    distinct?: StructScalarFieldEnum | StructScalarFieldEnum[]
  }

  /**
   * struct findFirstOrThrow
   */
  export type structFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct
     */
    select?: structSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct
     */
    omit?: structOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structInclude<ExtArgs> | null
    /**
     * Filter, which struct to fetch.
     */
    where?: structWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of structs to fetch.
     */
    orderBy?: structOrderByWithRelationInput | structOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for structs.
     */
    cursor?: structWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` structs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` structs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of structs.
     */
    distinct?: StructScalarFieldEnum | StructScalarFieldEnum[]
  }

  /**
   * struct findMany
   */
  export type structFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct
     */
    select?: structSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct
     */
    omit?: structOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structInclude<ExtArgs> | null
    /**
     * Filter, which structs to fetch.
     */
    where?: structWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of structs to fetch.
     */
    orderBy?: structOrderByWithRelationInput | structOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing structs.
     */
    cursor?: structWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` structs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` structs.
     */
    skip?: number
    distinct?: StructScalarFieldEnum | StructScalarFieldEnum[]
  }

  /**
   * struct create
   */
  export type structCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct
     */
    select?: structSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct
     */
    omit?: structOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structInclude<ExtArgs> | null
    /**
     * The data needed to create a struct.
     */
    data: XOR<structCreateInput, structUncheckedCreateInput>
  }

  /**
   * struct createMany
   */
  export type structCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many structs.
     */
    data: structCreateManyInput | structCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * struct createManyAndReturn
   */
  export type structCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct
     */
    select?: structSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the struct
     */
    omit?: structOmit<ExtArgs> | null
    /**
     * The data used to create many structs.
     */
    data: structCreateManyInput | structCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * struct update
   */
  export type structUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct
     */
    select?: structSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct
     */
    omit?: structOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structInclude<ExtArgs> | null
    /**
     * The data needed to update a struct.
     */
    data: XOR<structUpdateInput, structUncheckedUpdateInput>
    /**
     * Choose, which struct to update.
     */
    where: structWhereUniqueInput
  }

  /**
   * struct updateMany
   */
  export type structUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update structs.
     */
    data: XOR<structUpdateManyMutationInput, structUncheckedUpdateManyInput>
    /**
     * Filter which structs to update
     */
    where?: structWhereInput
    /**
     * Limit how many structs to update.
     */
    limit?: number
  }

  /**
   * struct updateManyAndReturn
   */
  export type structUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct
     */
    select?: structSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the struct
     */
    omit?: structOmit<ExtArgs> | null
    /**
     * The data used to update structs.
     */
    data: XOR<structUpdateManyMutationInput, structUncheckedUpdateManyInput>
    /**
     * Filter which structs to update
     */
    where?: structWhereInput
    /**
     * Limit how many structs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * struct upsert
   */
  export type structUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct
     */
    select?: structSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct
     */
    omit?: structOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structInclude<ExtArgs> | null
    /**
     * The filter to search for the struct to update in case it exists.
     */
    where: structWhereUniqueInput
    /**
     * In case the struct found by the `where` argument doesn't exist, create a new struct with this data.
     */
    create: XOR<structCreateInput, structUncheckedCreateInput>
    /**
     * In case the struct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<structUpdateInput, structUncheckedUpdateInput>
  }

  /**
   * struct delete
   */
  export type structDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct
     */
    select?: structSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct
     */
    omit?: structOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structInclude<ExtArgs> | null
    /**
     * Filter which struct to delete.
     */
    where: structWhereUniqueInput
  }

  /**
   * struct deleteMany
   */
  export type structDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which structs to delete
     */
    where?: structWhereInput
    /**
     * Limit how many structs to delete.
     */
    limit?: number
  }

  /**
   * struct.form_field
   */
  export type struct$form_fieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_field
     */
    select?: form_fieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the form_field
     */
    omit?: form_fieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: form_fieldInclude<ExtArgs> | null
    where?: form_fieldWhereInput
    orderBy?: form_fieldOrderByWithRelationInput | form_fieldOrderByWithRelationInput[]
    cursor?: form_fieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Form_fieldScalarFieldEnum | Form_fieldScalarFieldEnum[]
  }

  /**
   * struct.Media
   */
  export type struct$MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * struct.struct_set_instance
   */
  export type struct$struct_set_instanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set_instance
     */
    select?: struct_set_instanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set_instance
     */
    omit?: struct_set_instanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_set_instanceInclude<ExtArgs> | null
    where?: struct_set_instanceWhereInput
    orderBy?: struct_set_instanceOrderByWithRelationInput | struct_set_instanceOrderByWithRelationInput[]
    cursor?: struct_set_instanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Struct_set_instanceScalarFieldEnum | Struct_set_instanceScalarFieldEnum[]
  }

  /**
   * struct without action
   */
  export type structDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct
     */
    select?: structSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct
     */
    omit?: structOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structInclude<ExtArgs> | null
  }


  /**
   * Model struct_set
   */

  export type AggregateStruct_set = {
    _count: Struct_setCountAggregateOutputType | null
    _avg: Struct_setAvgAggregateOutputType | null
    _sum: Struct_setSumAggregateOutputType | null
    _min: Struct_setMinAggregateOutputType | null
    _max: Struct_setMaxAggregateOutputType | null
  }

  export type Struct_setAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
  }

  export type Struct_setSumAggregateOutputType = {
    id: number | null
    organization_id: number | null
  }

  export type Struct_setMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
    organization_id: number | null
    icon: string | null
    pinned: boolean | null
  }

  export type Struct_setMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
    organization_id: number | null
    icon: string | null
    pinned: boolean | null
  }

  export type Struct_setCountAggregateOutputType = {
    id: number
    name: number
    description: number
    created_at: number
    updated_at: number
    organization_id: number
    icon: number
    pinned: number
    _all: number
  }


  export type Struct_setAvgAggregateInputType = {
    id?: true
    organization_id?: true
  }

  export type Struct_setSumAggregateInputType = {
    id?: true
    organization_id?: true
  }

  export type Struct_setMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
    organization_id?: true
    icon?: true
    pinned?: true
  }

  export type Struct_setMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
    organization_id?: true
    icon?: true
    pinned?: true
  }

  export type Struct_setCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
    organization_id?: true
    icon?: true
    pinned?: true
    _all?: true
  }

  export type Struct_setAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which struct_set to aggregate.
     */
    where?: struct_setWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of struct_sets to fetch.
     */
    orderBy?: struct_setOrderByWithRelationInput | struct_setOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: struct_setWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` struct_sets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` struct_sets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned struct_sets
    **/
    _count?: true | Struct_setCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Struct_setAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Struct_setSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Struct_setMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Struct_setMaxAggregateInputType
  }

  export type GetStruct_setAggregateType<T extends Struct_setAggregateArgs> = {
        [P in keyof T & keyof AggregateStruct_set]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStruct_set[P]>
      : GetScalarType<T[P], AggregateStruct_set[P]>
  }




  export type struct_setGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: struct_setWhereInput
    orderBy?: struct_setOrderByWithAggregationInput | struct_setOrderByWithAggregationInput[]
    by: Struct_setScalarFieldEnum[] | Struct_setScalarFieldEnum
    having?: struct_setScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Struct_setCountAggregateInputType | true
    _avg?: Struct_setAvgAggregateInputType
    _sum?: Struct_setSumAggregateInputType
    _min?: Struct_setMinAggregateInputType
    _max?: Struct_setMaxAggregateInputType
  }

  export type Struct_setGroupByOutputType = {
    id: number
    name: string
    description: string
    created_at: Date
    updated_at: Date
    organization_id: number
    icon: string
    pinned: boolean
    _count: Struct_setCountAggregateOutputType | null
    _avg: Struct_setAvgAggregateOutputType | null
    _sum: Struct_setSumAggregateOutputType | null
    _min: Struct_setMinAggregateOutputType | null
    _max: Struct_setMaxAggregateOutputType | null
  }

  type GetStruct_setGroupByPayload<T extends struct_setGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Struct_setGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Struct_setGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Struct_setGroupByOutputType[P]>
            : GetScalarType<T[P], Struct_setGroupByOutputType[P]>
        }
      >
    >


  export type struct_setSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    organization_id?: boolean
    icon?: boolean
    pinned?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    struct_set_instance?: boolean | struct_set$struct_set_instanceArgs<ExtArgs>
    _count?: boolean | Struct_setCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["struct_set"]>

  export type struct_setSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    organization_id?: boolean
    icon?: boolean
    pinned?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["struct_set"]>

  export type struct_setSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    organization_id?: boolean
    icon?: boolean
    pinned?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["struct_set"]>

  export type struct_setSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    organization_id?: boolean
    icon?: boolean
    pinned?: boolean
  }

  export type struct_setOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "created_at" | "updated_at" | "organization_id" | "icon" | "pinned", ExtArgs["result"]["struct_set"]>
  export type struct_setInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    struct_set_instance?: boolean | struct_set$struct_set_instanceArgs<ExtArgs>
    _count?: boolean | Struct_setCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type struct_setIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type struct_setIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $struct_setPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "struct_set"
    objects: {
      Organization: Prisma.$OrganizationPayload<ExtArgs>
      struct_set_instance: Prisma.$struct_set_instancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      created_at: Date
      updated_at: Date
      organization_id: number
      icon: string
      pinned: boolean
    }, ExtArgs["result"]["struct_set"]>
    composites: {}
  }

  type struct_setGetPayload<S extends boolean | null | undefined | struct_setDefaultArgs> = $Result.GetResult<Prisma.$struct_setPayload, S>

  type struct_setCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<struct_setFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Struct_setCountAggregateInputType | true
    }

  export interface struct_setDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'struct_set' } }
    /**
     * Find zero or one Struct_set that matches the filter.
     * @param {struct_setFindUniqueArgs} args - Arguments to find a Struct_set
     * @example
     * // Get one Struct_set
     * const struct_set = await prisma.struct_set.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends struct_setFindUniqueArgs>(args: SelectSubset<T, struct_setFindUniqueArgs<ExtArgs>>): Prisma__struct_setClient<$Result.GetResult<Prisma.$struct_setPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Struct_set that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {struct_setFindUniqueOrThrowArgs} args - Arguments to find a Struct_set
     * @example
     * // Get one Struct_set
     * const struct_set = await prisma.struct_set.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends struct_setFindUniqueOrThrowArgs>(args: SelectSubset<T, struct_setFindUniqueOrThrowArgs<ExtArgs>>): Prisma__struct_setClient<$Result.GetResult<Prisma.$struct_setPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Struct_set that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {struct_setFindFirstArgs} args - Arguments to find a Struct_set
     * @example
     * // Get one Struct_set
     * const struct_set = await prisma.struct_set.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends struct_setFindFirstArgs>(args?: SelectSubset<T, struct_setFindFirstArgs<ExtArgs>>): Prisma__struct_setClient<$Result.GetResult<Prisma.$struct_setPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Struct_set that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {struct_setFindFirstOrThrowArgs} args - Arguments to find a Struct_set
     * @example
     * // Get one Struct_set
     * const struct_set = await prisma.struct_set.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends struct_setFindFirstOrThrowArgs>(args?: SelectSubset<T, struct_setFindFirstOrThrowArgs<ExtArgs>>): Prisma__struct_setClient<$Result.GetResult<Prisma.$struct_setPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Struct_sets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {struct_setFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Struct_sets
     * const struct_sets = await prisma.struct_set.findMany()
     * 
     * // Get first 10 Struct_sets
     * const struct_sets = await prisma.struct_set.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const struct_setWithIdOnly = await prisma.struct_set.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends struct_setFindManyArgs>(args?: SelectSubset<T, struct_setFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$struct_setPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Struct_set.
     * @param {struct_setCreateArgs} args - Arguments to create a Struct_set.
     * @example
     * // Create one Struct_set
     * const Struct_set = await prisma.struct_set.create({
     *   data: {
     *     // ... data to create a Struct_set
     *   }
     * })
     * 
     */
    create<T extends struct_setCreateArgs>(args: SelectSubset<T, struct_setCreateArgs<ExtArgs>>): Prisma__struct_setClient<$Result.GetResult<Prisma.$struct_setPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Struct_sets.
     * @param {struct_setCreateManyArgs} args - Arguments to create many Struct_sets.
     * @example
     * // Create many Struct_sets
     * const struct_set = await prisma.struct_set.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends struct_setCreateManyArgs>(args?: SelectSubset<T, struct_setCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Struct_sets and returns the data saved in the database.
     * @param {struct_setCreateManyAndReturnArgs} args - Arguments to create many Struct_sets.
     * @example
     * // Create many Struct_sets
     * const struct_set = await prisma.struct_set.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Struct_sets and only return the `id`
     * const struct_setWithIdOnly = await prisma.struct_set.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends struct_setCreateManyAndReturnArgs>(args?: SelectSubset<T, struct_setCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$struct_setPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Struct_set.
     * @param {struct_setDeleteArgs} args - Arguments to delete one Struct_set.
     * @example
     * // Delete one Struct_set
     * const Struct_set = await prisma.struct_set.delete({
     *   where: {
     *     // ... filter to delete one Struct_set
     *   }
     * })
     * 
     */
    delete<T extends struct_setDeleteArgs>(args: SelectSubset<T, struct_setDeleteArgs<ExtArgs>>): Prisma__struct_setClient<$Result.GetResult<Prisma.$struct_setPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Struct_set.
     * @param {struct_setUpdateArgs} args - Arguments to update one Struct_set.
     * @example
     * // Update one Struct_set
     * const struct_set = await prisma.struct_set.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends struct_setUpdateArgs>(args: SelectSubset<T, struct_setUpdateArgs<ExtArgs>>): Prisma__struct_setClient<$Result.GetResult<Prisma.$struct_setPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Struct_sets.
     * @param {struct_setDeleteManyArgs} args - Arguments to filter Struct_sets to delete.
     * @example
     * // Delete a few Struct_sets
     * const { count } = await prisma.struct_set.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends struct_setDeleteManyArgs>(args?: SelectSubset<T, struct_setDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Struct_sets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {struct_setUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Struct_sets
     * const struct_set = await prisma.struct_set.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends struct_setUpdateManyArgs>(args: SelectSubset<T, struct_setUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Struct_sets and returns the data updated in the database.
     * @param {struct_setUpdateManyAndReturnArgs} args - Arguments to update many Struct_sets.
     * @example
     * // Update many Struct_sets
     * const struct_set = await prisma.struct_set.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Struct_sets and only return the `id`
     * const struct_setWithIdOnly = await prisma.struct_set.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends struct_setUpdateManyAndReturnArgs>(args: SelectSubset<T, struct_setUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$struct_setPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Struct_set.
     * @param {struct_setUpsertArgs} args - Arguments to update or create a Struct_set.
     * @example
     * // Update or create a Struct_set
     * const struct_set = await prisma.struct_set.upsert({
     *   create: {
     *     // ... data to create a Struct_set
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Struct_set we want to update
     *   }
     * })
     */
    upsert<T extends struct_setUpsertArgs>(args: SelectSubset<T, struct_setUpsertArgs<ExtArgs>>): Prisma__struct_setClient<$Result.GetResult<Prisma.$struct_setPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Struct_sets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {struct_setCountArgs} args - Arguments to filter Struct_sets to count.
     * @example
     * // Count the number of Struct_sets
     * const count = await prisma.struct_set.count({
     *   where: {
     *     // ... the filter for the Struct_sets we want to count
     *   }
     * })
    **/
    count<T extends struct_setCountArgs>(
      args?: Subset<T, struct_setCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Struct_setCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Struct_set.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Struct_setAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Struct_setAggregateArgs>(args: Subset<T, Struct_setAggregateArgs>): Prisma.PrismaPromise<GetStruct_setAggregateType<T>>

    /**
     * Group by Struct_set.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {struct_setGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends struct_setGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: struct_setGroupByArgs['orderBy'] }
        : { orderBy?: struct_setGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, struct_setGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStruct_setGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the struct_set model
   */
  readonly fields: struct_setFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for struct_set.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__struct_setClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    struct_set_instance<T extends struct_set$struct_set_instanceArgs<ExtArgs> = {}>(args?: Subset<T, struct_set$struct_set_instanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$struct_set_instancePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the struct_set model
   */ 
  interface struct_setFieldRefs {
    readonly id: FieldRef<"struct_set", 'Int'>
    readonly name: FieldRef<"struct_set", 'String'>
    readonly description: FieldRef<"struct_set", 'String'>
    readonly created_at: FieldRef<"struct_set", 'DateTime'>
    readonly updated_at: FieldRef<"struct_set", 'DateTime'>
    readonly organization_id: FieldRef<"struct_set", 'Int'>
    readonly icon: FieldRef<"struct_set", 'String'>
    readonly pinned: FieldRef<"struct_set", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * struct_set findUnique
   */
  export type struct_setFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set
     */
    select?: struct_setSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set
     */
    omit?: struct_setOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_setInclude<ExtArgs> | null
    /**
     * Filter, which struct_set to fetch.
     */
    where: struct_setWhereUniqueInput
  }

  /**
   * struct_set findUniqueOrThrow
   */
  export type struct_setFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set
     */
    select?: struct_setSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set
     */
    omit?: struct_setOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_setInclude<ExtArgs> | null
    /**
     * Filter, which struct_set to fetch.
     */
    where: struct_setWhereUniqueInput
  }

  /**
   * struct_set findFirst
   */
  export type struct_setFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set
     */
    select?: struct_setSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set
     */
    omit?: struct_setOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_setInclude<ExtArgs> | null
    /**
     * Filter, which struct_set to fetch.
     */
    where?: struct_setWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of struct_sets to fetch.
     */
    orderBy?: struct_setOrderByWithRelationInput | struct_setOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for struct_sets.
     */
    cursor?: struct_setWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` struct_sets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` struct_sets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of struct_sets.
     */
    distinct?: Struct_setScalarFieldEnum | Struct_setScalarFieldEnum[]
  }

  /**
   * struct_set findFirstOrThrow
   */
  export type struct_setFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set
     */
    select?: struct_setSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set
     */
    omit?: struct_setOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_setInclude<ExtArgs> | null
    /**
     * Filter, which struct_set to fetch.
     */
    where?: struct_setWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of struct_sets to fetch.
     */
    orderBy?: struct_setOrderByWithRelationInput | struct_setOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for struct_sets.
     */
    cursor?: struct_setWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` struct_sets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` struct_sets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of struct_sets.
     */
    distinct?: Struct_setScalarFieldEnum | Struct_setScalarFieldEnum[]
  }

  /**
   * struct_set findMany
   */
  export type struct_setFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set
     */
    select?: struct_setSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set
     */
    omit?: struct_setOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_setInclude<ExtArgs> | null
    /**
     * Filter, which struct_sets to fetch.
     */
    where?: struct_setWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of struct_sets to fetch.
     */
    orderBy?: struct_setOrderByWithRelationInput | struct_setOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing struct_sets.
     */
    cursor?: struct_setWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` struct_sets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` struct_sets.
     */
    skip?: number
    distinct?: Struct_setScalarFieldEnum | Struct_setScalarFieldEnum[]
  }

  /**
   * struct_set create
   */
  export type struct_setCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set
     */
    select?: struct_setSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set
     */
    omit?: struct_setOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_setInclude<ExtArgs> | null
    /**
     * The data needed to create a struct_set.
     */
    data: XOR<struct_setCreateInput, struct_setUncheckedCreateInput>
  }

  /**
   * struct_set createMany
   */
  export type struct_setCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many struct_sets.
     */
    data: struct_setCreateManyInput | struct_setCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * struct_set createManyAndReturn
   */
  export type struct_setCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set
     */
    select?: struct_setSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set
     */
    omit?: struct_setOmit<ExtArgs> | null
    /**
     * The data used to create many struct_sets.
     */
    data: struct_setCreateManyInput | struct_setCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_setIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * struct_set update
   */
  export type struct_setUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set
     */
    select?: struct_setSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set
     */
    omit?: struct_setOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_setInclude<ExtArgs> | null
    /**
     * The data needed to update a struct_set.
     */
    data: XOR<struct_setUpdateInput, struct_setUncheckedUpdateInput>
    /**
     * Choose, which struct_set to update.
     */
    where: struct_setWhereUniqueInput
  }

  /**
   * struct_set updateMany
   */
  export type struct_setUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update struct_sets.
     */
    data: XOR<struct_setUpdateManyMutationInput, struct_setUncheckedUpdateManyInput>
    /**
     * Filter which struct_sets to update
     */
    where?: struct_setWhereInput
    /**
     * Limit how many struct_sets to update.
     */
    limit?: number
  }

  /**
   * struct_set updateManyAndReturn
   */
  export type struct_setUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set
     */
    select?: struct_setSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set
     */
    omit?: struct_setOmit<ExtArgs> | null
    /**
     * The data used to update struct_sets.
     */
    data: XOR<struct_setUpdateManyMutationInput, struct_setUncheckedUpdateManyInput>
    /**
     * Filter which struct_sets to update
     */
    where?: struct_setWhereInput
    /**
     * Limit how many struct_sets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_setIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * struct_set upsert
   */
  export type struct_setUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set
     */
    select?: struct_setSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set
     */
    omit?: struct_setOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_setInclude<ExtArgs> | null
    /**
     * The filter to search for the struct_set to update in case it exists.
     */
    where: struct_setWhereUniqueInput
    /**
     * In case the struct_set found by the `where` argument doesn't exist, create a new struct_set with this data.
     */
    create: XOR<struct_setCreateInput, struct_setUncheckedCreateInput>
    /**
     * In case the struct_set was found with the provided `where` argument, update it with this data.
     */
    update: XOR<struct_setUpdateInput, struct_setUncheckedUpdateInput>
  }

  /**
   * struct_set delete
   */
  export type struct_setDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set
     */
    select?: struct_setSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set
     */
    omit?: struct_setOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_setInclude<ExtArgs> | null
    /**
     * Filter which struct_set to delete.
     */
    where: struct_setWhereUniqueInput
  }

  /**
   * struct_set deleteMany
   */
  export type struct_setDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which struct_sets to delete
     */
    where?: struct_setWhereInput
    /**
     * Limit how many struct_sets to delete.
     */
    limit?: number
  }

  /**
   * struct_set.struct_set_instance
   */
  export type struct_set$struct_set_instanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set_instance
     */
    select?: struct_set_instanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set_instance
     */
    omit?: struct_set_instanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_set_instanceInclude<ExtArgs> | null
    where?: struct_set_instanceWhereInput
    orderBy?: struct_set_instanceOrderByWithRelationInput | struct_set_instanceOrderByWithRelationInput[]
    cursor?: struct_set_instanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Struct_set_instanceScalarFieldEnum | Struct_set_instanceScalarFieldEnum[]
  }

  /**
   * struct_set without action
   */
  export type struct_setDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set
     */
    select?: struct_setSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set
     */
    omit?: struct_setOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_setInclude<ExtArgs> | null
  }


  /**
   * Model struct_set_instance
   */

  export type AggregateStruct_set_instance = {
    _count: Struct_set_instanceCountAggregateOutputType | null
    _avg: Struct_set_instanceAvgAggregateOutputType | null
    _sum: Struct_set_instanceSumAggregateOutputType | null
    _min: Struct_set_instanceMinAggregateOutputType | null
    _max: Struct_set_instanceMaxAggregateOutputType | null
  }

  export type Struct_set_instanceAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
    struct_set_id: number | null
    struct_id: number | null
  }

  export type Struct_set_instanceSumAggregateOutputType = {
    id: number | null
    organization_id: number | null
    struct_set_id: number | null
    struct_id: number | null
  }

  export type Struct_set_instanceMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    organization_id: number | null
    struct_set_id: number | null
    struct_id: number | null
    key: string | null
  }

  export type Struct_set_instanceMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    organization_id: number | null
    struct_set_id: number | null
    struct_id: number | null
    key: string | null
  }

  export type Struct_set_instanceCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    instance_data: number
    organization_id: number
    struct_set_id: number
    struct_id: number
    key: number
    _all: number
  }


  export type Struct_set_instanceAvgAggregateInputType = {
    id?: true
    organization_id?: true
    struct_set_id?: true
    struct_id?: true
  }

  export type Struct_set_instanceSumAggregateInputType = {
    id?: true
    organization_id?: true
    struct_set_id?: true
    struct_id?: true
  }

  export type Struct_set_instanceMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    organization_id?: true
    struct_set_id?: true
    struct_id?: true
    key?: true
  }

  export type Struct_set_instanceMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    organization_id?: true
    struct_set_id?: true
    struct_id?: true
    key?: true
  }

  export type Struct_set_instanceCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    instance_data?: true
    organization_id?: true
    struct_set_id?: true
    struct_id?: true
    key?: true
    _all?: true
  }

  export type Struct_set_instanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which struct_set_instance to aggregate.
     */
    where?: struct_set_instanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of struct_set_instances to fetch.
     */
    orderBy?: struct_set_instanceOrderByWithRelationInput | struct_set_instanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: struct_set_instanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` struct_set_instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` struct_set_instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned struct_set_instances
    **/
    _count?: true | Struct_set_instanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Struct_set_instanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Struct_set_instanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Struct_set_instanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Struct_set_instanceMaxAggregateInputType
  }

  export type GetStruct_set_instanceAggregateType<T extends Struct_set_instanceAggregateArgs> = {
        [P in keyof T & keyof AggregateStruct_set_instance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStruct_set_instance[P]>
      : GetScalarType<T[P], AggregateStruct_set_instance[P]>
  }




  export type struct_set_instanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: struct_set_instanceWhereInput
    orderBy?: struct_set_instanceOrderByWithAggregationInput | struct_set_instanceOrderByWithAggregationInput[]
    by: Struct_set_instanceScalarFieldEnum[] | Struct_set_instanceScalarFieldEnum
    having?: struct_set_instanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Struct_set_instanceCountAggregateInputType | true
    _avg?: Struct_set_instanceAvgAggregateInputType
    _sum?: Struct_set_instanceSumAggregateInputType
    _min?: Struct_set_instanceMinAggregateInputType
    _max?: Struct_set_instanceMaxAggregateInputType
  }

  export type Struct_set_instanceGroupByOutputType = {
    id: number
    created_at: Date
    updated_at: Date
    instance_data: JsonValue
    organization_id: number
    struct_set_id: number
    struct_id: number
    key: string
    _count: Struct_set_instanceCountAggregateOutputType | null
    _avg: Struct_set_instanceAvgAggregateOutputType | null
    _sum: Struct_set_instanceSumAggregateOutputType | null
    _min: Struct_set_instanceMinAggregateOutputType | null
    _max: Struct_set_instanceMaxAggregateOutputType | null
  }

  type GetStruct_set_instanceGroupByPayload<T extends struct_set_instanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Struct_set_instanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Struct_set_instanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Struct_set_instanceGroupByOutputType[P]>
            : GetScalarType<T[P], Struct_set_instanceGroupByOutputType[P]>
        }
      >
    >


  export type struct_set_instanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    instance_data?: boolean
    organization_id?: boolean
    struct_set_id?: boolean
    struct_id?: boolean
    key?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    struct?: boolean | structDefaultArgs<ExtArgs>
    struct_set?: boolean | struct_setDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["struct_set_instance"]>

  export type struct_set_instanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    instance_data?: boolean
    organization_id?: boolean
    struct_set_id?: boolean
    struct_id?: boolean
    key?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    struct?: boolean | structDefaultArgs<ExtArgs>
    struct_set?: boolean | struct_setDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["struct_set_instance"]>

  export type struct_set_instanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    instance_data?: boolean
    organization_id?: boolean
    struct_set_id?: boolean
    struct_id?: boolean
    key?: boolean
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    struct?: boolean | structDefaultArgs<ExtArgs>
    struct_set?: boolean | struct_setDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["struct_set_instance"]>

  export type struct_set_instanceSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    instance_data?: boolean
    organization_id?: boolean
    struct_set_id?: boolean
    struct_id?: boolean
    key?: boolean
  }

  export type struct_set_instanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "instance_data" | "organization_id" | "struct_set_id" | "struct_id" | "key", ExtArgs["result"]["struct_set_instance"]>
  export type struct_set_instanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    struct?: boolean | structDefaultArgs<ExtArgs>
    struct_set?: boolean | struct_setDefaultArgs<ExtArgs>
  }
  export type struct_set_instanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    struct?: boolean | structDefaultArgs<ExtArgs>
    struct_set?: boolean | struct_setDefaultArgs<ExtArgs>
  }
  export type struct_set_instanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    struct?: boolean | structDefaultArgs<ExtArgs>
    struct_set?: boolean | struct_setDefaultArgs<ExtArgs>
  }

  export type $struct_set_instancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "struct_set_instance"
    objects: {
      Organization: Prisma.$OrganizationPayload<ExtArgs>
      struct: Prisma.$structPayload<ExtArgs>
      struct_set: Prisma.$struct_setPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      created_at: Date
      updated_at: Date
      instance_data: Prisma.JsonValue
      organization_id: number
      struct_set_id: number
      struct_id: number
      key: string
    }, ExtArgs["result"]["struct_set_instance"]>
    composites: {}
  }

  type struct_set_instanceGetPayload<S extends boolean | null | undefined | struct_set_instanceDefaultArgs> = $Result.GetResult<Prisma.$struct_set_instancePayload, S>

  type struct_set_instanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<struct_set_instanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Struct_set_instanceCountAggregateInputType | true
    }

  export interface struct_set_instanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: any, meta: { name: 'struct_set_instance' } }
    /**
     * Find zero or one Struct_set_instance that matches the filter.
     * @param {struct_set_instanceFindUniqueArgs} args - Arguments to find a Struct_set_instance
     * @example
     * // Get one Struct_set_instance
     * const struct_set_instance = await prisma.struct_set_instance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends struct_set_instanceFindUniqueArgs>(args: SelectSubset<T, struct_set_instanceFindUniqueArgs<ExtArgs>>): Prisma__struct_set_instanceClient<$Result.GetResult<Prisma.$struct_set_instancePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Struct_set_instance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {struct_set_instanceFindUniqueOrThrowArgs} args - Arguments to find a Struct_set_instance
     * @example
     * // Get one Struct_set_instance
     * const struct_set_instance = await prisma.struct_set_instance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends struct_set_instanceFindUniqueOrThrowArgs>(args: SelectSubset<T, struct_set_instanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__struct_set_instanceClient<$Result.GetResult<Prisma.$struct_set_instancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Struct_set_instance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {struct_set_instanceFindFirstArgs} args - Arguments to find a Struct_set_instance
     * @example
     * // Get one Struct_set_instance
     * const struct_set_instance = await prisma.struct_set_instance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends struct_set_instanceFindFirstArgs>(args?: SelectSubset<T, struct_set_instanceFindFirstArgs<ExtArgs>>): Prisma__struct_set_instanceClient<$Result.GetResult<Prisma.$struct_set_instancePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Struct_set_instance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {struct_set_instanceFindFirstOrThrowArgs} args - Arguments to find a Struct_set_instance
     * @example
     * // Get one Struct_set_instance
     * const struct_set_instance = await prisma.struct_set_instance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends struct_set_instanceFindFirstOrThrowArgs>(args?: SelectSubset<T, struct_set_instanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__struct_set_instanceClient<$Result.GetResult<Prisma.$struct_set_instancePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Struct_set_instances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {struct_set_instanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Struct_set_instances
     * const struct_set_instances = await prisma.struct_set_instance.findMany()
     * 
     * // Get first 10 Struct_set_instances
     * const struct_set_instances = await prisma.struct_set_instance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const struct_set_instanceWithIdOnly = await prisma.struct_set_instance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends struct_set_instanceFindManyArgs>(args?: SelectSubset<T, struct_set_instanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$struct_set_instancePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Struct_set_instance.
     * @param {struct_set_instanceCreateArgs} args - Arguments to create a Struct_set_instance.
     * @example
     * // Create one Struct_set_instance
     * const Struct_set_instance = await prisma.struct_set_instance.create({
     *   data: {
     *     // ... data to create a Struct_set_instance
     *   }
     * })
     * 
     */
    create<T extends struct_set_instanceCreateArgs>(args: SelectSubset<T, struct_set_instanceCreateArgs<ExtArgs>>): Prisma__struct_set_instanceClient<$Result.GetResult<Prisma.$struct_set_instancePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Struct_set_instances.
     * @param {struct_set_instanceCreateManyArgs} args - Arguments to create many Struct_set_instances.
     * @example
     * // Create many Struct_set_instances
     * const struct_set_instance = await prisma.struct_set_instance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends struct_set_instanceCreateManyArgs>(args?: SelectSubset<T, struct_set_instanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Struct_set_instances and returns the data saved in the database.
     * @param {struct_set_instanceCreateManyAndReturnArgs} args - Arguments to create many Struct_set_instances.
     * @example
     * // Create many Struct_set_instances
     * const struct_set_instance = await prisma.struct_set_instance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Struct_set_instances and only return the `id`
     * const struct_set_instanceWithIdOnly = await prisma.struct_set_instance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends struct_set_instanceCreateManyAndReturnArgs>(args?: SelectSubset<T, struct_set_instanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$struct_set_instancePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Struct_set_instance.
     * @param {struct_set_instanceDeleteArgs} args - Arguments to delete one Struct_set_instance.
     * @example
     * // Delete one Struct_set_instance
     * const Struct_set_instance = await prisma.struct_set_instance.delete({
     *   where: {
     *     // ... filter to delete one Struct_set_instance
     *   }
     * })
     * 
     */
    delete<T extends struct_set_instanceDeleteArgs>(args: SelectSubset<T, struct_set_instanceDeleteArgs<ExtArgs>>): Prisma__struct_set_instanceClient<$Result.GetResult<Prisma.$struct_set_instancePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Struct_set_instance.
     * @param {struct_set_instanceUpdateArgs} args - Arguments to update one Struct_set_instance.
     * @example
     * // Update one Struct_set_instance
     * const struct_set_instance = await prisma.struct_set_instance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends struct_set_instanceUpdateArgs>(args: SelectSubset<T, struct_set_instanceUpdateArgs<ExtArgs>>): Prisma__struct_set_instanceClient<$Result.GetResult<Prisma.$struct_set_instancePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Struct_set_instances.
     * @param {struct_set_instanceDeleteManyArgs} args - Arguments to filter Struct_set_instances to delete.
     * @example
     * // Delete a few Struct_set_instances
     * const { count } = await prisma.struct_set_instance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends struct_set_instanceDeleteManyArgs>(args?: SelectSubset<T, struct_set_instanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Struct_set_instances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {struct_set_instanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Struct_set_instances
     * const struct_set_instance = await prisma.struct_set_instance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends struct_set_instanceUpdateManyArgs>(args: SelectSubset<T, struct_set_instanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Struct_set_instances and returns the data updated in the database.
     * @param {struct_set_instanceUpdateManyAndReturnArgs} args - Arguments to update many Struct_set_instances.
     * @example
     * // Update many Struct_set_instances
     * const struct_set_instance = await prisma.struct_set_instance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Struct_set_instances and only return the `id`
     * const struct_set_instanceWithIdOnly = await prisma.struct_set_instance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends struct_set_instanceUpdateManyAndReturnArgs>(args: SelectSubset<T, struct_set_instanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$struct_set_instancePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Struct_set_instance.
     * @param {struct_set_instanceUpsertArgs} args - Arguments to update or create a Struct_set_instance.
     * @example
     * // Update or create a Struct_set_instance
     * const struct_set_instance = await prisma.struct_set_instance.upsert({
     *   create: {
     *     // ... data to create a Struct_set_instance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Struct_set_instance we want to update
     *   }
     * })
     */
    upsert<T extends struct_set_instanceUpsertArgs>(args: SelectSubset<T, struct_set_instanceUpsertArgs<ExtArgs>>): Prisma__struct_set_instanceClient<$Result.GetResult<Prisma.$struct_set_instancePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Struct_set_instances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {struct_set_instanceCountArgs} args - Arguments to filter Struct_set_instances to count.
     * @example
     * // Count the number of Struct_set_instances
     * const count = await prisma.struct_set_instance.count({
     *   where: {
     *     // ... the filter for the Struct_set_instances we want to count
     *   }
     * })
    **/
    count<T extends struct_set_instanceCountArgs>(
      args?: Subset<T, struct_set_instanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Struct_set_instanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Struct_set_instance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Struct_set_instanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Struct_set_instanceAggregateArgs>(args: Subset<T, Struct_set_instanceAggregateArgs>): Prisma.PrismaPromise<GetStruct_set_instanceAggregateType<T>>

    /**
     * Group by Struct_set_instance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {struct_set_instanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends struct_set_instanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: struct_set_instanceGroupByArgs['orderBy'] }
        : { orderBy?: struct_set_instanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, struct_set_instanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStruct_set_instanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the struct_set_instance model
   */
  readonly fields: struct_set_instanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for struct_set_instance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__struct_set_instanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    struct<T extends structDefaultArgs<ExtArgs> = {}>(args?: Subset<T, structDefaultArgs<ExtArgs>>): Prisma__structClient<$Result.GetResult<Prisma.$structPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    struct_set<T extends struct_setDefaultArgs<ExtArgs> = {}>(args?: Subset<T, struct_setDefaultArgs<ExtArgs>>): Prisma__struct_setClient<$Result.GetResult<Prisma.$struct_setPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the struct_set_instance model
   */ 
  interface struct_set_instanceFieldRefs {
    readonly id: FieldRef<"struct_set_instance", 'Int'>
    readonly created_at: FieldRef<"struct_set_instance", 'DateTime'>
    readonly updated_at: FieldRef<"struct_set_instance", 'DateTime'>
    readonly instance_data: FieldRef<"struct_set_instance", 'Json'>
    readonly organization_id: FieldRef<"struct_set_instance", 'Int'>
    readonly struct_set_id: FieldRef<"struct_set_instance", 'Int'>
    readonly struct_id: FieldRef<"struct_set_instance", 'Int'>
    readonly key: FieldRef<"struct_set_instance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * struct_set_instance findUnique
   */
  export type struct_set_instanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set_instance
     */
    select?: struct_set_instanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set_instance
     */
    omit?: struct_set_instanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_set_instanceInclude<ExtArgs> | null
    /**
     * Filter, which struct_set_instance to fetch.
     */
    where: struct_set_instanceWhereUniqueInput
  }

  /**
   * struct_set_instance findUniqueOrThrow
   */
  export type struct_set_instanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set_instance
     */
    select?: struct_set_instanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set_instance
     */
    omit?: struct_set_instanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_set_instanceInclude<ExtArgs> | null
    /**
     * Filter, which struct_set_instance to fetch.
     */
    where: struct_set_instanceWhereUniqueInput
  }

  /**
   * struct_set_instance findFirst
   */
  export type struct_set_instanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set_instance
     */
    select?: struct_set_instanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set_instance
     */
    omit?: struct_set_instanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_set_instanceInclude<ExtArgs> | null
    /**
     * Filter, which struct_set_instance to fetch.
     */
    where?: struct_set_instanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of struct_set_instances to fetch.
     */
    orderBy?: struct_set_instanceOrderByWithRelationInput | struct_set_instanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for struct_set_instances.
     */
    cursor?: struct_set_instanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` struct_set_instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` struct_set_instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of struct_set_instances.
     */
    distinct?: Struct_set_instanceScalarFieldEnum | Struct_set_instanceScalarFieldEnum[]
  }

  /**
   * struct_set_instance findFirstOrThrow
   */
  export type struct_set_instanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set_instance
     */
    select?: struct_set_instanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set_instance
     */
    omit?: struct_set_instanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_set_instanceInclude<ExtArgs> | null
    /**
     * Filter, which struct_set_instance to fetch.
     */
    where?: struct_set_instanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of struct_set_instances to fetch.
     */
    orderBy?: struct_set_instanceOrderByWithRelationInput | struct_set_instanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for struct_set_instances.
     */
    cursor?: struct_set_instanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` struct_set_instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` struct_set_instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of struct_set_instances.
     */
    distinct?: Struct_set_instanceScalarFieldEnum | Struct_set_instanceScalarFieldEnum[]
  }

  /**
   * struct_set_instance findMany
   */
  export type struct_set_instanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set_instance
     */
    select?: struct_set_instanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set_instance
     */
    omit?: struct_set_instanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_set_instanceInclude<ExtArgs> | null
    /**
     * Filter, which struct_set_instances to fetch.
     */
    where?: struct_set_instanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of struct_set_instances to fetch.
     */
    orderBy?: struct_set_instanceOrderByWithRelationInput | struct_set_instanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing struct_set_instances.
     */
    cursor?: struct_set_instanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` struct_set_instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` struct_set_instances.
     */
    skip?: number
    distinct?: Struct_set_instanceScalarFieldEnum | Struct_set_instanceScalarFieldEnum[]
  }

  /**
   * struct_set_instance create
   */
  export type struct_set_instanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set_instance
     */
    select?: struct_set_instanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set_instance
     */
    omit?: struct_set_instanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_set_instanceInclude<ExtArgs> | null
    /**
     * The data needed to create a struct_set_instance.
     */
    data: XOR<struct_set_instanceCreateInput, struct_set_instanceUncheckedCreateInput>
  }

  /**
   * struct_set_instance createMany
   */
  export type struct_set_instanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many struct_set_instances.
     */
    data: struct_set_instanceCreateManyInput | struct_set_instanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * struct_set_instance createManyAndReturn
   */
  export type struct_set_instanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set_instance
     */
    select?: struct_set_instanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set_instance
     */
    omit?: struct_set_instanceOmit<ExtArgs> | null
    /**
     * The data used to create many struct_set_instances.
     */
    data: struct_set_instanceCreateManyInput | struct_set_instanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_set_instanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * struct_set_instance update
   */
  export type struct_set_instanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set_instance
     */
    select?: struct_set_instanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set_instance
     */
    omit?: struct_set_instanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_set_instanceInclude<ExtArgs> | null
    /**
     * The data needed to update a struct_set_instance.
     */
    data: XOR<struct_set_instanceUpdateInput, struct_set_instanceUncheckedUpdateInput>
    /**
     * Choose, which struct_set_instance to update.
     */
    where: struct_set_instanceWhereUniqueInput
  }

  /**
   * struct_set_instance updateMany
   */
  export type struct_set_instanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update struct_set_instances.
     */
    data: XOR<struct_set_instanceUpdateManyMutationInput, struct_set_instanceUncheckedUpdateManyInput>
    /**
     * Filter which struct_set_instances to update
     */
    where?: struct_set_instanceWhereInput
    /**
     * Limit how many struct_set_instances to update.
     */
    limit?: number
  }

  /**
   * struct_set_instance updateManyAndReturn
   */
  export type struct_set_instanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set_instance
     */
    select?: struct_set_instanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set_instance
     */
    omit?: struct_set_instanceOmit<ExtArgs> | null
    /**
     * The data used to update struct_set_instances.
     */
    data: XOR<struct_set_instanceUpdateManyMutationInput, struct_set_instanceUncheckedUpdateManyInput>
    /**
     * Filter which struct_set_instances to update
     */
    where?: struct_set_instanceWhereInput
    /**
     * Limit how many struct_set_instances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_set_instanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * struct_set_instance upsert
   */
  export type struct_set_instanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set_instance
     */
    select?: struct_set_instanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set_instance
     */
    omit?: struct_set_instanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_set_instanceInclude<ExtArgs> | null
    /**
     * The filter to search for the struct_set_instance to update in case it exists.
     */
    where: struct_set_instanceWhereUniqueInput
    /**
     * In case the struct_set_instance found by the `where` argument doesn't exist, create a new struct_set_instance with this data.
     */
    create: XOR<struct_set_instanceCreateInput, struct_set_instanceUncheckedCreateInput>
    /**
     * In case the struct_set_instance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<struct_set_instanceUpdateInput, struct_set_instanceUncheckedUpdateInput>
  }

  /**
   * struct_set_instance delete
   */
  export type struct_set_instanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set_instance
     */
    select?: struct_set_instanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set_instance
     */
    omit?: struct_set_instanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_set_instanceInclude<ExtArgs> | null
    /**
     * Filter which struct_set_instance to delete.
     */
    where: struct_set_instanceWhereUniqueInput
  }

  /**
   * struct_set_instance deleteMany
   */
  export type struct_set_instanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which struct_set_instances to delete
     */
    where?: struct_set_instanceWhereInput
    /**
     * Limit how many struct_set_instances to delete.
     */
    limit?: number
  }

  /**
   * struct_set_instance without action
   */
  export type struct_set_instanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the struct_set_instance
     */
    select?: struct_set_instanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the struct_set_instance
     */
    omit?: struct_set_instanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: struct_set_instanceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export declare const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export declare const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    organization_id: 'organization_id',
    slug: 'slug',
    description: 'description',
    parent_id: 'parent_id',
    collection_id: 'collection_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    short_name: 'short_name'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export declare const CollectionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    organization_id: 'organization_id',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at',
    icon: 'icon',
    page_content: 'page_content',
    enable_author: 'enable_author',
    enable_comments: 'enable_comments',
    enable_featured_posts: 'enable_featured_posts',
    enable_rating: 'enable_rating',
    path_prefix: 'path_prefix',
    title: 'title'
  };

  export type CollectionScalarFieldEnum = (typeof CollectionScalarFieldEnum)[keyof typeof CollectionScalarFieldEnum]


  export declare const CommentScalarFieldEnum: {
    id: 'id',
    text: 'text',
    author: 'author',
    content_id: 'content_id',
    parent_id: 'parent_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    approved: 'approved',
    organization_id: 'organization_id',
    email: 'email',
    image_url: 'image_url',
    rating: 'rating'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export declare const CompletionUsageScalarFieldEnum: {
    created_at: 'created_at',
    prompt_tokens: 'prompt_tokens',
    completion_tokens: 'completion_tokens',
    total_tokens: 'total_tokens',
    prompt_tokens_cost: 'prompt_tokens_cost',
    completion_tokens_cost: 'completion_tokens_cost',
    total_tokens_cost: 'total_tokens_cost',
    prompt_tokens_price: 'prompt_tokens_price',
    completion_tokens_price: 'completion_tokens_price',
    total_tokens_price: 'total_tokens_price',
    id: 'id',
    organization_id: 'organization_id'
  };

  export type CompletionUsageScalarFieldEnum = (typeof CompletionUsageScalarFieldEnum)[keyof typeof CompletionUsageScalarFieldEnum]


  export declare const ContentScalarFieldEnum: {
    id: 'id',
    data: 'data',
    created_at: 'created_at',
    updated_at: 'updated_at',
    blocks: 'blocks',
    html: 'html',
    archive: 'archive',
    collection_id: 'collection_id',
    description: 'description',
    draft: 'draft',
    slug: 'slug',
    title: 'title',
    comments_enabled: 'comments_enabled',
    organization_id: 'organization_id',
    author_id: 'author_id',
    featured: 'featured',
    content_category: 'content_category'
  };

  export type ContentScalarFieldEnum = (typeof ContentScalarFieldEnum)[keyof typeof ContentScalarFieldEnum]


  export declare const ContentTemplateInstanceScalarFieldEnum: {
    id: 'id',
    content_id: 'content_id',
    template_instance_id: 'template_instance_id'
  };

  export type ContentTemplateInstanceScalarFieldEnum = (typeof ContentTemplateInstanceScalarFieldEnum)[keyof typeof ContentTemplateInstanceScalarFieldEnum]


  export declare const FieldScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    required: 'required',
    options: 'options',
    created_at: 'created_at',
    updated_at: 'updated_at',
    template_id: 'template_id',
    collection_id: 'collection_id'
  };

  export type FieldScalarFieldEnum = (typeof FieldScalarFieldEnum)[keyof typeof FieldScalarFieldEnum]


  export declare const ImageGenerationBillingScalarFieldEnum: {
    id: 'id',
    completed_at: 'completed_at',
    started_at: 'started_at',
    created_at: 'created_at',
    predict_time: 'predict_time',
    model: 'model',
    status: 'status',
    cost: 'cost',
    price: 'price',
    organization_id: 'organization_id'
  };

  export type ImageGenerationBillingScalarFieldEnum = (typeof ImageGenerationBillingScalarFieldEnum)[keyof typeof ImageGenerationBillingScalarFieldEnum]


  export declare const InvoiceScalarFieldEnum: {
    organization_id: 'organization_id',
    amount_paid: 'amount_paid',
    currency: 'currency',
    paid_at: 'paid_at',
    pdf: 'pdf',
    url: 'url',
    id: 'id'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export declare const LinkPageScalarFieldEnum: {
    id: 'id',
    organization_id: 'organization_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    description: 'description',
    media_id: 'media_id',
    title: 'title',
    links: 'links'
  };

  export type LinkPageScalarFieldEnum = (typeof LinkPageScalarFieldEnum)[keyof typeof LinkPageScalarFieldEnum]


  export declare const MediaScalarFieldEnum: {
    id: 'id',
    url: 'url',
    alt_text: 'alt_text',
    name: 'name',
    created_at: 'created_at',
    organization_id: 'organization_id',
    updated_at: 'updated_at'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export declare const MessagesScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    message: 'message',
    first_name: 'first_name',
    email: 'email',
    phone_number: 'phone_number',
    last_name: 'last_name',
    other_fields: 'other_fields',
    organization_id: 'organization_id',
    viewed: 'viewed',
    archived: 'archived'
  };

  export type MessagesScalarFieldEnum = (typeof MessagesScalarFieldEnum)[keyof typeof MessagesScalarFieldEnum]


  export declare const OrganizationScalarFieldEnum: {
    id: 'id',
    company_name: 'company_name',
    address: 'address',
    country: 'country',
    phone: 'phone',
    email: 'email',
    company_description: 'company_description',
    domain: 'domain',
    logo: 'logo',
    token: 'token',
    stripe_customer_id: 'stripe_customer_id',
    stripe_price_id: 'stripe_price_id',
    stripe_is_subscribed: 'stripe_is_subscribed',
    ai_subscription_id: 'ai_subscription_id',
    notify_by_email: 'notify_by_email',
    notify_by_sms: 'notify_by_sms',
    slack_webhook_url: 'slack_webhook_url',
    city: 'city',
    postal_code: 'postal_code',
    state: 'state',
    street_address: 'street_address'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export declare const PageScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    created_at: 'created_at',
    updated_at: 'updated_at',
    published: 'published',
    archive: 'archive',
    data: 'data',
    organization_id: 'organization_id'
  };

  export type PageScalarFieldEnum = (typeof PageScalarFieldEnum)[keyof typeof PageScalarFieldEnum]


  export declare const RunScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    assistant_id: 'assistant_id',
    thread_id: 'thread_id',
    status: 'status',
    started_at: 'started_at',
    expires_at: 'expires_at',
    cancelled_at: 'cancelled_at',
    failed_at: 'failed_at',
    completed_at: 'completed_at',
    last_error: 'last_error',
    model: 'model',
    instructions: 'instructions'
  };

  export type RunScalarFieldEnum = (typeof RunScalarFieldEnum)[keyof typeof RunScalarFieldEnum]


  export declare const SubscriptionScalarFieldEnum: {
    id: 'id',
    organization_id: 'organization_id',
    stripe_subscription_id: 'stripe_subscription_id'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export declare const TemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    collection_id: 'collection_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TemplateScalarFieldEnum = (typeof TemplateScalarFieldEnum)[keyof typeof TemplateScalarFieldEnum]


  export declare const TemplateInstanceScalarFieldEnum: {
    id: 'id',
    values: 'values',
    created_at: 'created_at',
    updated_at: 'updated_at',
    title: 'title',
    templateId: 'templateId'
  };

  export type TemplateInstanceScalarFieldEnum = (typeof TemplateInstanceScalarFieldEnum)[keyof typeof TemplateInstanceScalarFieldEnum]


  export declare const ThreadScalarFieldEnum: {
    thread_id: 'thread_id',
    title: 'title',
    created_at: 'created_at',
    updated_at: 'updated_at',
    organization_id: 'organization_id',
    should_hide_thread: 'should_hide_thread'
  };

  export type ThreadScalarFieldEnum = (typeof ThreadScalarFieldEnum)[keyof typeof ThreadScalarFieldEnum]


  export declare const ThreadMessageScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    thread_id: 'thread_id',
    role: 'role',
    content: 'content',
    assistant_id: 'assistant_id',
    run_id: 'run_id'
  };

  export type ThreadMessageScalarFieldEnum = (typeof ThreadMessageScalarFieldEnum)[keyof typeof ThreadMessageScalarFieldEnum]


  export declare const UsageScalarFieldEnum: {
    run_id: 'run_id',
    prompt_tokens: 'prompt_tokens',
    completion_tokens: 'completion_tokens',
    total_tokens: 'total_tokens',
    organization_id: 'organization_id',
    created_at: 'created_at'
  };

  export type UsageScalarFieldEnum = (typeof UsageScalarFieldEnum)[keyof typeof UsageScalarFieldEnum]


  export declare const UserOrganizationScalarFieldEnum: {
    user_id: 'user_id',
    organization_id: 'organization_id',
    role: 'role',
    created_at: 'created_at'
  };

  export type UserOrganizationScalarFieldEnum = (typeof UserOrganizationScalarFieldEnum)[keyof typeof UserOrganizationScalarFieldEnum]


  export declare const UsersScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    password: 'password',
    security_pin: 'security_pin',
    created_at: 'created_at',
    organization_id: 'organization_id',
    updated_at: 'updated_at',
    role: 'role',
    media_id: 'media_id'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export declare const AuthorScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    description: 'description',
    organization_id: 'organization_id',
    media_id: 'media_id',
    slug: 'slug'
  };

  export type AuthorScalarFieldEnum = (typeof AuthorScalarFieldEnum)[keyof typeof AuthorScalarFieldEnum]


  export declare const Form_fieldScalarFieldEnum: {
    id: 'id',
    name: 'name',
    required: 'required',
    created_at: 'created_at',
    updated_at: 'updated_at',
    type: 'type',
    default_value: 'default_value',
    help: 'help',
    order: 'order',
    description: 'description',
    label: 'label',
    placeholder: 'placeholder',
    regex: 'regex',
    organization_id: 'organization_id',
    collection_id: 'collection_id',
    options: 'options',
    struct_id: 'struct_id'
  };

  export type Form_fieldScalarFieldEnum = (typeof Form_fieldScalarFieldEnum)[keyof typeof Form_fieldScalarFieldEnum]


  export declare const Org_detailsScalarFieldEnum: {
    gtag: 'gtag',
    url: 'url',
    company_name: 'company_name',
    phone: 'phone',
    email: 'email',
    street_address: 'street_address',
    city: 'city',
    state: 'state',
    country: 'country',
    postal_code: 'postal_code',
    socials: 'socials',
    company_description: 'company_description',
    created_at: 'created_at',
    id: 'id',
    media_id: 'media_id',
    organization_id: 'organization_id',
    updated_at: 'updated_at'
  };

  export type Org_detailsScalarFieldEnum = (typeof Org_detailsScalarFieldEnum)[keyof typeof Org_detailsScalarFieldEnum]


  export declare const StructScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    group: 'group',
    organization_id: 'organization_id',
    cms: 'cms',
    description: 'description',
    media_id: 'media_id'
  };

  export type StructScalarFieldEnum = (typeof StructScalarFieldEnum)[keyof typeof StructScalarFieldEnum]


  export declare const Struct_setScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at',
    organization_id: 'organization_id',
    icon: 'icon',
    pinned: 'pinned'
  };

  export type Struct_setScalarFieldEnum = (typeof Struct_setScalarFieldEnum)[keyof typeof Struct_setScalarFieldEnum]


  export declare const Struct_set_instanceScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    instance_data: 'instance_data',
    organization_id: 'organization_id',
    struct_set_id: 'struct_set_id',
    struct_id: 'struct_id',
    key: 'key'
  };

  export type Struct_set_instanceScalarFieldEnum = (typeof Struct_set_instanceScalarFieldEnum)[keyof typeof Struct_set_instanceScalarFieldEnum]


  export declare const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export declare const JsonNullValueInput: {
    JsonNull: any
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export declare const NullableJsonNullValueInput: {
    DbNull: any,
    JsonNull: any
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export declare const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export declare const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export declare const JsonNullValueFilter: {
    DbNull: any,
    JsonNull: any,
    AnyNull: any
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Json[]'
   */
  export type ListJsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json[]'>
    


  /**
   * Reference to a field of type 'field_type'
   */
  export type Enumfield_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'field_type'>
    


  /**
   * Reference to a field of type 'field_type[]'
   */
  export type ListEnumfield_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'field_type[]'>
    
  /**
   * Deep Input Types
   */


  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    organization_id?: IntFilter<"Category"> | number
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    parent_id?: IntNullableFilter<"Category"> | number | null
    collection_id?: IntFilter<"Category"> | number
    created_at?: DateTimeFilter<"Category"> | Date | string
    updated_at?: DateTimeFilter<"Category"> | Date | string
    short_name?: StringFilter<"Category"> | string
    Collection?: XOR<CollectionScalarRelationFilter, CollectionWhereInput>
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    Category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    other_Category?: CategoryListRelationFilter
    Content?: ContentListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    organization_id?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    parent_id?: SortOrderInput | SortOrder
    collection_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    short_name?: SortOrder
    Collection?: CollectionOrderByWithRelationInput
    Organization?: OrganizationOrderByWithRelationInput
    Category?: CategoryOrderByWithRelationInput
    other_Category?: CategoryOrderByRelationAggregateInput
    Content?: ContentOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug_organization_id?: CategorySlugOrganization_idCompoundUniqueInput
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    organization_id?: IntFilter<"Category"> | number
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    parent_id?: IntNullableFilter<"Category"> | number | null
    collection_id?: IntFilter<"Category"> | number
    created_at?: DateTimeFilter<"Category"> | Date | string
    updated_at?: DateTimeFilter<"Category"> | Date | string
    short_name?: StringFilter<"Category"> | string
    Collection?: XOR<CollectionScalarRelationFilter, CollectionWhereInput>
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    Category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    other_Category?: CategoryListRelationFilter
    Content?: ContentListRelationFilter
  }, "id" | "slug_organization_id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    organization_id?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    parent_id?: SortOrderInput | SortOrder
    collection_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    short_name?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    name?: StringWithAggregatesFilter<"Category"> | string
    organization_id?: IntWithAggregatesFilter<"Category"> | number
    slug?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    parent_id?: IntNullableWithAggregatesFilter<"Category"> | number | null
    collection_id?: IntWithAggregatesFilter<"Category"> | number
    created_at?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    short_name?: StringWithAggregatesFilter<"Category"> | string
  }

  export type CollectionWhereInput = {
    AND?: CollectionWhereInput | CollectionWhereInput[]
    OR?: CollectionWhereInput[]
    NOT?: CollectionWhereInput | CollectionWhereInput[]
    id?: IntFilter<"Collection"> | number
    name?: StringFilter<"Collection"> | string
    organization_id?: IntFilter<"Collection"> | number
    description?: StringNullableFilter<"Collection"> | string | null
    created_at?: DateTimeFilter<"Collection"> | Date | string
    updated_at?: DateTimeFilter<"Collection"> | Date | string
    icon?: StringFilter<"Collection"> | string
    page_content?: BoolFilter<"Collection"> | boolean
    enable_author?: BoolFilter<"Collection"> | boolean
    enable_comments?: BoolFilter<"Collection"> | boolean
    enable_featured_posts?: BoolFilter<"Collection"> | boolean
    enable_rating?: BoolFilter<"Collection"> | boolean
    path_prefix?: StringNullableFilter<"Collection"> | string | null
    title?: StringNullableFilter<"Collection"> | string | null
    Category?: CategoryListRelationFilter
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    Content?: ContentListRelationFilter
    Field?: FieldListRelationFilter
    Template?: TemplateListRelationFilter
    form_field?: Form_fieldListRelationFilter
  }

  export type CollectionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    organization_id?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    icon?: SortOrder
    page_content?: SortOrder
    enable_author?: SortOrder
    enable_comments?: SortOrder
    enable_featured_posts?: SortOrder
    enable_rating?: SortOrder
    path_prefix?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    Category?: CategoryOrderByRelationAggregateInput
    Organization?: OrganizationOrderByWithRelationInput
    Content?: ContentOrderByRelationAggregateInput
    Field?: FieldOrderByRelationAggregateInput
    Template?: TemplateOrderByRelationAggregateInput
    form_field?: form_fieldOrderByRelationAggregateInput
  }

  export type CollectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name_organization_id?: CollectionNameOrganization_idCompoundUniqueInput
    AND?: CollectionWhereInput | CollectionWhereInput[]
    OR?: CollectionWhereInput[]
    NOT?: CollectionWhereInput | CollectionWhereInput[]
    name?: StringFilter<"Collection"> | string
    organization_id?: IntFilter<"Collection"> | number
    description?: StringNullableFilter<"Collection"> | string | null
    created_at?: DateTimeFilter<"Collection"> | Date | string
    updated_at?: DateTimeFilter<"Collection"> | Date | string
    icon?: StringFilter<"Collection"> | string
    page_content?: BoolFilter<"Collection"> | boolean
    enable_author?: BoolFilter<"Collection"> | boolean
    enable_comments?: BoolFilter<"Collection"> | boolean
    enable_featured_posts?: BoolFilter<"Collection"> | boolean
    enable_rating?: BoolFilter<"Collection"> | boolean
    path_prefix?: StringNullableFilter<"Collection"> | string | null
    title?: StringNullableFilter<"Collection"> | string | null
    Category?: CategoryListRelationFilter
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    Content?: ContentListRelationFilter
    Field?: FieldListRelationFilter
    Template?: TemplateListRelationFilter
    form_field?: Form_fieldListRelationFilter
  }, "id" | "name_organization_id">

  export type CollectionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    organization_id?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    icon?: SortOrder
    page_content?: SortOrder
    enable_author?: SortOrder
    enable_comments?: SortOrder
    enable_featured_posts?: SortOrder
    enable_rating?: SortOrder
    path_prefix?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    _count?: CollectionCountOrderByAggregateInput
    _avg?: CollectionAvgOrderByAggregateInput
    _max?: CollectionMaxOrderByAggregateInput
    _min?: CollectionMinOrderByAggregateInput
    _sum?: CollectionSumOrderByAggregateInput
  }

  export type CollectionScalarWhereWithAggregatesInput = {
    AND?: CollectionScalarWhereWithAggregatesInput | CollectionScalarWhereWithAggregatesInput[]
    OR?: CollectionScalarWhereWithAggregatesInput[]
    NOT?: CollectionScalarWhereWithAggregatesInput | CollectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Collection"> | number
    name?: StringWithAggregatesFilter<"Collection"> | string
    organization_id?: IntWithAggregatesFilter<"Collection"> | number
    description?: StringNullableWithAggregatesFilter<"Collection"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Collection"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Collection"> | Date | string
    icon?: StringWithAggregatesFilter<"Collection"> | string
    page_content?: BoolWithAggregatesFilter<"Collection"> | boolean
    enable_author?: BoolWithAggregatesFilter<"Collection"> | boolean
    enable_comments?: BoolWithAggregatesFilter<"Collection"> | boolean
    enable_featured_posts?: BoolWithAggregatesFilter<"Collection"> | boolean
    enable_rating?: BoolWithAggregatesFilter<"Collection"> | boolean
    path_prefix?: StringNullableWithAggregatesFilter<"Collection"> | string | null
    title?: StringNullableWithAggregatesFilter<"Collection"> | string | null
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: IntFilter<"Comment"> | number
    text?: StringFilter<"Comment"> | string
    author?: StringFilter<"Comment"> | string
    content_id?: IntFilter<"Comment"> | number
    parent_id?: IntNullableFilter<"Comment"> | number | null
    created_at?: DateTimeFilter<"Comment"> | Date | string
    updated_at?: DateTimeFilter<"Comment"> | Date | string
    approved?: BoolFilter<"Comment"> | boolean
    organization_id?: IntFilter<"Comment"> | number
    email?: StringFilter<"Comment"> | string
    image_url?: StringNullableFilter<"Comment"> | string | null
    rating?: IntNullableFilter<"Comment"> | number | null
    Content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    Comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    other_Comment?: CommentListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    author?: SortOrder
    content_id?: SortOrder
    parent_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    approved?: SortOrder
    organization_id?: SortOrder
    email?: SortOrder
    image_url?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    Content?: ContentOrderByWithRelationInput
    Organization?: OrganizationOrderByWithRelationInput
    Comment?: CommentOrderByWithRelationInput
    other_Comment?: CommentOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    text?: StringFilter<"Comment"> | string
    author?: StringFilter<"Comment"> | string
    content_id?: IntFilter<"Comment"> | number
    parent_id?: IntNullableFilter<"Comment"> | number | null
    created_at?: DateTimeFilter<"Comment"> | Date | string
    updated_at?: DateTimeFilter<"Comment"> | Date | string
    approved?: BoolFilter<"Comment"> | boolean
    organization_id?: IntFilter<"Comment"> | number
    email?: StringFilter<"Comment"> | string
    image_url?: StringNullableFilter<"Comment"> | string | null
    rating?: IntNullableFilter<"Comment"> | number | null
    Content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    Comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    other_Comment?: CommentListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    author?: SortOrder
    content_id?: SortOrder
    parent_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    approved?: SortOrder
    organization_id?: SortOrder
    email?: SortOrder
    image_url?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comment"> | number
    text?: StringWithAggregatesFilter<"Comment"> | string
    author?: StringWithAggregatesFilter<"Comment"> | string
    content_id?: IntWithAggregatesFilter<"Comment"> | number
    parent_id?: IntNullableWithAggregatesFilter<"Comment"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    approved?: BoolWithAggregatesFilter<"Comment"> | boolean
    organization_id?: IntWithAggregatesFilter<"Comment"> | number
    email?: StringWithAggregatesFilter<"Comment"> | string
    image_url?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    rating?: IntNullableWithAggregatesFilter<"Comment"> | number | null
  }

  export type CompletionUsageWhereInput = {
    AND?: CompletionUsageWhereInput | CompletionUsageWhereInput[]
    OR?: CompletionUsageWhereInput[]
    NOT?: CompletionUsageWhereInput | CompletionUsageWhereInput[]
    created_at?: DateTimeFilter<"CompletionUsage"> | Date | string
    prompt_tokens?: IntFilter<"CompletionUsage"> | number
    completion_tokens?: IntFilter<"CompletionUsage"> | number
    total_tokens?: IntFilter<"CompletionUsage"> | number
    prompt_tokens_cost?: FloatFilter<"CompletionUsage"> | number
    completion_tokens_cost?: FloatFilter<"CompletionUsage"> | number
    total_tokens_cost?: FloatFilter<"CompletionUsage"> | number
    prompt_tokens_price?: FloatFilter<"CompletionUsage"> | number
    completion_tokens_price?: FloatFilter<"CompletionUsage"> | number
    total_tokens_price?: FloatFilter<"CompletionUsage"> | number
    id?: IntFilter<"CompletionUsage"> | number
    organization_id?: IntFilter<"CompletionUsage"> | number
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type CompletionUsageOrderByWithRelationInput = {
    created_at?: SortOrder
    prompt_tokens?: SortOrder
    completion_tokens?: SortOrder
    total_tokens?: SortOrder
    prompt_tokens_cost?: SortOrder
    completion_tokens_cost?: SortOrder
    total_tokens_cost?: SortOrder
    prompt_tokens_price?: SortOrder
    completion_tokens_price?: SortOrder
    total_tokens_price?: SortOrder
    id?: SortOrder
    organization_id?: SortOrder
    Organization?: OrganizationOrderByWithRelationInput
  }

  export type CompletionUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompletionUsageWhereInput | CompletionUsageWhereInput[]
    OR?: CompletionUsageWhereInput[]
    NOT?: CompletionUsageWhereInput | CompletionUsageWhereInput[]
    created_at?: DateTimeFilter<"CompletionUsage"> | Date | string
    prompt_tokens?: IntFilter<"CompletionUsage"> | number
    completion_tokens?: IntFilter<"CompletionUsage"> | number
    total_tokens?: IntFilter<"CompletionUsage"> | number
    prompt_tokens_cost?: FloatFilter<"CompletionUsage"> | number
    completion_tokens_cost?: FloatFilter<"CompletionUsage"> | number
    total_tokens_cost?: FloatFilter<"CompletionUsage"> | number
    prompt_tokens_price?: FloatFilter<"CompletionUsage"> | number
    completion_tokens_price?: FloatFilter<"CompletionUsage"> | number
    total_tokens_price?: FloatFilter<"CompletionUsage"> | number
    organization_id?: IntFilter<"CompletionUsage"> | number
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id">

  export type CompletionUsageOrderByWithAggregationInput = {
    created_at?: SortOrder
    prompt_tokens?: SortOrder
    completion_tokens?: SortOrder
    total_tokens?: SortOrder
    prompt_tokens_cost?: SortOrder
    completion_tokens_cost?: SortOrder
    total_tokens_cost?: SortOrder
    prompt_tokens_price?: SortOrder
    completion_tokens_price?: SortOrder
    total_tokens_price?: SortOrder
    id?: SortOrder
    organization_id?: SortOrder
    _count?: CompletionUsageCountOrderByAggregateInput
    _avg?: CompletionUsageAvgOrderByAggregateInput
    _max?: CompletionUsageMaxOrderByAggregateInput
    _min?: CompletionUsageMinOrderByAggregateInput
    _sum?: CompletionUsageSumOrderByAggregateInput
  }

  export type CompletionUsageScalarWhereWithAggregatesInput = {
    AND?: CompletionUsageScalarWhereWithAggregatesInput | CompletionUsageScalarWhereWithAggregatesInput[]
    OR?: CompletionUsageScalarWhereWithAggregatesInput[]
    NOT?: CompletionUsageScalarWhereWithAggregatesInput | CompletionUsageScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"CompletionUsage"> | Date | string
    prompt_tokens?: IntWithAggregatesFilter<"CompletionUsage"> | number
    completion_tokens?: IntWithAggregatesFilter<"CompletionUsage"> | number
    total_tokens?: IntWithAggregatesFilter<"CompletionUsage"> | number
    prompt_tokens_cost?: FloatWithAggregatesFilter<"CompletionUsage"> | number
    completion_tokens_cost?: FloatWithAggregatesFilter<"CompletionUsage"> | number
    total_tokens_cost?: FloatWithAggregatesFilter<"CompletionUsage"> | number
    prompt_tokens_price?: FloatWithAggregatesFilter<"CompletionUsage"> | number
    completion_tokens_price?: FloatWithAggregatesFilter<"CompletionUsage"> | number
    total_tokens_price?: FloatWithAggregatesFilter<"CompletionUsage"> | number
    id?: IntWithAggregatesFilter<"CompletionUsage"> | number
    organization_id?: IntWithAggregatesFilter<"CompletionUsage"> | number
  }

  export type ContentWhereInput = {
    AND?: ContentWhereInput | ContentWhereInput[]
    OR?: ContentWhereInput[]
    NOT?: ContentWhereInput | ContentWhereInput[]
    id?: IntFilter<"Content"> | number
    data?: JsonFilter<"Content">
    created_at?: DateTimeFilter<"Content"> | Date | string
    updated_at?: DateTimeFilter<"Content"> | Date | string
    blocks?: JsonFilter<"Content">
    html?: StringFilter<"Content"> | string
    archive?: BoolFilter<"Content"> | boolean
    collection_id?: IntFilter<"Content"> | number
    description?: StringNullableFilter<"Content"> | string | null
    draft?: BoolFilter<"Content"> | boolean
    slug?: StringFilter<"Content"> | string
    title?: StringNullableFilter<"Content"> | string | null
    comments_enabled?: BoolFilter<"Content"> | boolean
    organization_id?: IntNullableFilter<"Content"> | number | null
    author_id?: IntNullableFilter<"Content"> | number | null
    featured?: BoolFilter<"Content"> | boolean
    content_category?: StringNullableListFilter<"Content">
    Comment?: CommentListRelationFilter
    author?: XOR<AuthorNullableScalarRelationFilter, authorWhereInput> | null
    Collection?: XOR<CollectionScalarRelationFilter, CollectionWhereInput>
    Organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    ContentTemplateInstance?: ContentTemplateInstanceListRelationFilter
    Category?: CategoryListRelationFilter
  }

  export type ContentOrderByWithRelationInput = {
    id?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    blocks?: SortOrder
    html?: SortOrder
    archive?: SortOrder
    collection_id?: SortOrder
    description?: SortOrderInput | SortOrder
    draft?: SortOrder
    slug?: SortOrder
    title?: SortOrderInput | SortOrder
    comments_enabled?: SortOrder
    organization_id?: SortOrderInput | SortOrder
    author_id?: SortOrderInput | SortOrder
    featured?: SortOrder
    content_category?: SortOrder
    Comment?: CommentOrderByRelationAggregateInput
    author?: authorOrderByWithRelationInput
    Collection?: CollectionOrderByWithRelationInput
    Organization?: OrganizationOrderByWithRelationInput
    ContentTemplateInstance?: ContentTemplateInstanceOrderByRelationAggregateInput
    Category?: CategoryOrderByRelationAggregateInput
  }

  export type ContentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug_organization_id?: ContentSlugOrganization_idCompoundUniqueInput
    AND?: ContentWhereInput | ContentWhereInput[]
    OR?: ContentWhereInput[]
    NOT?: ContentWhereInput | ContentWhereInput[]
    data?: JsonFilter<"Content">
    created_at?: DateTimeFilter<"Content"> | Date | string
    updated_at?: DateTimeFilter<"Content"> | Date | string
    blocks?: JsonFilter<"Content">
    html?: StringFilter<"Content"> | string
    archive?: BoolFilter<"Content"> | boolean
    collection_id?: IntFilter<"Content"> | number
    description?: StringNullableFilter<"Content"> | string | null
    draft?: BoolFilter<"Content"> | boolean
    slug?: StringFilter<"Content"> | string
    title?: StringNullableFilter<"Content"> | string | null
    comments_enabled?: BoolFilter<"Content"> | boolean
    organization_id?: IntNullableFilter<"Content"> | number | null
    author_id?: IntNullableFilter<"Content"> | number | null
    featured?: BoolFilter<"Content"> | boolean
    content_category?: StringNullableListFilter<"Content">
    Comment?: CommentListRelationFilter
    author?: XOR<AuthorNullableScalarRelationFilter, authorWhereInput> | null
    Collection?: XOR<CollectionScalarRelationFilter, CollectionWhereInput>
    Organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    ContentTemplateInstance?: ContentTemplateInstanceListRelationFilter
    Category?: CategoryListRelationFilter
  }, "id" | "slug_organization_id">

  export type ContentOrderByWithAggregationInput = {
    id?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    blocks?: SortOrder
    html?: SortOrder
    archive?: SortOrder
    collection_id?: SortOrder
    description?: SortOrderInput | SortOrder
    draft?: SortOrder
    slug?: SortOrder
    title?: SortOrderInput | SortOrder
    comments_enabled?: SortOrder
    organization_id?: SortOrderInput | SortOrder
    author_id?: SortOrderInput | SortOrder
    featured?: SortOrder
    content_category?: SortOrder
    _count?: ContentCountOrderByAggregateInput
    _avg?: ContentAvgOrderByAggregateInput
    _max?: ContentMaxOrderByAggregateInput
    _min?: ContentMinOrderByAggregateInput
    _sum?: ContentSumOrderByAggregateInput
  }

  export type ContentScalarWhereWithAggregatesInput = {
    AND?: ContentScalarWhereWithAggregatesInput | ContentScalarWhereWithAggregatesInput[]
    OR?: ContentScalarWhereWithAggregatesInput[]
    NOT?: ContentScalarWhereWithAggregatesInput | ContentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Content"> | number
    data?: JsonWithAggregatesFilter<"Content">
    created_at?: DateTimeWithAggregatesFilter<"Content"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Content"> | Date | string
    blocks?: JsonWithAggregatesFilter<"Content">
    html?: StringWithAggregatesFilter<"Content"> | string
    archive?: BoolWithAggregatesFilter<"Content"> | boolean
    collection_id?: IntWithAggregatesFilter<"Content"> | number
    description?: StringNullableWithAggregatesFilter<"Content"> | string | null
    draft?: BoolWithAggregatesFilter<"Content"> | boolean
    slug?: StringWithAggregatesFilter<"Content"> | string
    title?: StringNullableWithAggregatesFilter<"Content"> | string | null
    comments_enabled?: BoolWithAggregatesFilter<"Content"> | boolean
    organization_id?: IntNullableWithAggregatesFilter<"Content"> | number | null
    author_id?: IntNullableWithAggregatesFilter<"Content"> | number | null
    featured?: BoolWithAggregatesFilter<"Content"> | boolean
    content_category?: StringNullableListFilter<"Content">
  }

  export type ContentTemplateInstanceWhereInput = {
    AND?: ContentTemplateInstanceWhereInput | ContentTemplateInstanceWhereInput[]
    OR?: ContentTemplateInstanceWhereInput[]
    NOT?: ContentTemplateInstanceWhereInput | ContentTemplateInstanceWhereInput[]
    id?: IntFilter<"ContentTemplateInstance"> | number
    content_id?: IntFilter<"ContentTemplateInstance"> | number
    template_instance_id?: IntFilter<"ContentTemplateInstance"> | number
    Content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
    TemplateInstance?: XOR<TemplateInstanceScalarRelationFilter, TemplateInstanceWhereInput>
  }

  export type ContentTemplateInstanceOrderByWithRelationInput = {
    id?: SortOrder
    content_id?: SortOrder
    template_instance_id?: SortOrder
    Content?: ContentOrderByWithRelationInput
    TemplateInstance?: TemplateInstanceOrderByWithRelationInput
  }

  export type ContentTemplateInstanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContentTemplateInstanceWhereInput | ContentTemplateInstanceWhereInput[]
    OR?: ContentTemplateInstanceWhereInput[]
    NOT?: ContentTemplateInstanceWhereInput | ContentTemplateInstanceWhereInput[]
    content_id?: IntFilter<"ContentTemplateInstance"> | number
    template_instance_id?: IntFilter<"ContentTemplateInstance"> | number
    Content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
    TemplateInstance?: XOR<TemplateInstanceScalarRelationFilter, TemplateInstanceWhereInput>
  }, "id">

  export type ContentTemplateInstanceOrderByWithAggregationInput = {
    id?: SortOrder
    content_id?: SortOrder
    template_instance_id?: SortOrder
    _count?: ContentTemplateInstanceCountOrderByAggregateInput
    _avg?: ContentTemplateInstanceAvgOrderByAggregateInput
    _max?: ContentTemplateInstanceMaxOrderByAggregateInput
    _min?: ContentTemplateInstanceMinOrderByAggregateInput
    _sum?: ContentTemplateInstanceSumOrderByAggregateInput
  }

  export type ContentTemplateInstanceScalarWhereWithAggregatesInput = {
    AND?: ContentTemplateInstanceScalarWhereWithAggregatesInput | ContentTemplateInstanceScalarWhereWithAggregatesInput[]
    OR?: ContentTemplateInstanceScalarWhereWithAggregatesInput[]
    NOT?: ContentTemplateInstanceScalarWhereWithAggregatesInput | ContentTemplateInstanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContentTemplateInstance"> | number
    content_id?: IntWithAggregatesFilter<"ContentTemplateInstance"> | number
    template_instance_id?: IntWithAggregatesFilter<"ContentTemplateInstance"> | number
  }

  export type FieldWhereInput = {
    AND?: FieldWhereInput | FieldWhereInput[]
    OR?: FieldWhereInput[]
    NOT?: FieldWhereInput | FieldWhereInput[]
    id?: IntFilter<"Field"> | number
    name?: StringFilter<"Field"> | string
    type?: StringFilter<"Field"> | string
    required?: BoolFilter<"Field"> | boolean
    options?: StringNullableListFilter<"Field">
    created_at?: DateTimeFilter<"Field"> | Date | string
    updated_at?: DateTimeFilter<"Field"> | Date | string
    template_id?: IntNullableFilter<"Field"> | number | null
    collection_id?: IntNullableFilter<"Field"> | number | null
    Collection?: XOR<CollectionNullableScalarRelationFilter, CollectionWhereInput> | null
    Template?: XOR<TemplateNullableScalarRelationFilter, TemplateWhereInput> | null
  }

  export type FieldOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    required?: SortOrder
    options?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    template_id?: SortOrderInput | SortOrder
    collection_id?: SortOrderInput | SortOrder
    Collection?: CollectionOrderByWithRelationInput
    Template?: TemplateOrderByWithRelationInput
  }

  export type FieldWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name_collection_id?: FieldNameCollection_idCompoundUniqueInput
    name_template_id?: FieldNameTemplate_idCompoundUniqueInput
    AND?: FieldWhereInput | FieldWhereInput[]
    OR?: FieldWhereInput[]
    NOT?: FieldWhereInput | FieldWhereInput[]
    name?: StringFilter<"Field"> | string
    type?: StringFilter<"Field"> | string
    required?: BoolFilter<"Field"> | boolean
    options?: StringNullableListFilter<"Field">
    created_at?: DateTimeFilter<"Field"> | Date | string
    updated_at?: DateTimeFilter<"Field"> | Date | string
    template_id?: IntNullableFilter<"Field"> | number | null
    collection_id?: IntNullableFilter<"Field"> | number | null
    Collection?: XOR<CollectionNullableScalarRelationFilter, CollectionWhereInput> | null
    Template?: XOR<TemplateNullableScalarRelationFilter, TemplateWhereInput> | null
  }, "id" | "name_collection_id" | "name_template_id">

  export type FieldOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    required?: SortOrder
    options?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    template_id?: SortOrderInput | SortOrder
    collection_id?: SortOrderInput | SortOrder
    _count?: FieldCountOrderByAggregateInput
    _avg?: FieldAvgOrderByAggregateInput
    _max?: FieldMaxOrderByAggregateInput
    _min?: FieldMinOrderByAggregateInput
    _sum?: FieldSumOrderByAggregateInput
  }

  export type FieldScalarWhereWithAggregatesInput = {
    AND?: FieldScalarWhereWithAggregatesInput | FieldScalarWhereWithAggregatesInput[]
    OR?: FieldScalarWhereWithAggregatesInput[]
    NOT?: FieldScalarWhereWithAggregatesInput | FieldScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Field"> | number
    name?: StringWithAggregatesFilter<"Field"> | string
    type?: StringWithAggregatesFilter<"Field"> | string
    required?: BoolWithAggregatesFilter<"Field"> | boolean
    options?: StringNullableListFilter<"Field">
    created_at?: DateTimeWithAggregatesFilter<"Field"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Field"> | Date | string
    template_id?: IntNullableWithAggregatesFilter<"Field"> | number | null
    collection_id?: IntNullableWithAggregatesFilter<"Field"> | number | null
  }

  export type ImageGenerationBillingWhereInput = {
    AND?: ImageGenerationBillingWhereInput | ImageGenerationBillingWhereInput[]
    OR?: ImageGenerationBillingWhereInput[]
    NOT?: ImageGenerationBillingWhereInput | ImageGenerationBillingWhereInput[]
    id?: StringFilter<"ImageGenerationBilling"> | string
    completed_at?: DateTimeFilter<"ImageGenerationBilling"> | Date | string
    started_at?: DateTimeFilter<"ImageGenerationBilling"> | Date | string
    created_at?: DateTimeFilter<"ImageGenerationBilling"> | Date | string
    predict_time?: FloatFilter<"ImageGenerationBilling"> | number
    model?: StringFilter<"ImageGenerationBilling"> | string
    status?: StringFilter<"ImageGenerationBilling"> | string
    cost?: FloatFilter<"ImageGenerationBilling"> | number
    price?: FloatFilter<"ImageGenerationBilling"> | number
    organization_id?: IntFilter<"ImageGenerationBilling"> | number
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type ImageGenerationBillingOrderByWithRelationInput = {
    id?: SortOrder
    completed_at?: SortOrder
    started_at?: SortOrder
    created_at?: SortOrder
    predict_time?: SortOrder
    model?: SortOrder
    status?: SortOrder
    cost?: SortOrder
    price?: SortOrder
    organization_id?: SortOrder
    Organization?: OrganizationOrderByWithRelationInput
  }

  export type ImageGenerationBillingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImageGenerationBillingWhereInput | ImageGenerationBillingWhereInput[]
    OR?: ImageGenerationBillingWhereInput[]
    NOT?: ImageGenerationBillingWhereInput | ImageGenerationBillingWhereInput[]
    completed_at?: DateTimeFilter<"ImageGenerationBilling"> | Date | string
    started_at?: DateTimeFilter<"ImageGenerationBilling"> | Date | string
    created_at?: DateTimeFilter<"ImageGenerationBilling"> | Date | string
    predict_time?: FloatFilter<"ImageGenerationBilling"> | number
    model?: StringFilter<"ImageGenerationBilling"> | string
    status?: StringFilter<"ImageGenerationBilling"> | string
    cost?: FloatFilter<"ImageGenerationBilling"> | number
    price?: FloatFilter<"ImageGenerationBilling"> | number
    organization_id?: IntFilter<"ImageGenerationBilling"> | number
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "id">

  export type ImageGenerationBillingOrderByWithAggregationInput = {
    id?: SortOrder
    completed_at?: SortOrder
    started_at?: SortOrder
    created_at?: SortOrder
    predict_time?: SortOrder
    model?: SortOrder
    status?: SortOrder
    cost?: SortOrder
    price?: SortOrder
    organization_id?: SortOrder
    _count?: ImageGenerationBillingCountOrderByAggregateInput
    _avg?: ImageGenerationBillingAvgOrderByAggregateInput
    _max?: ImageGenerationBillingMaxOrderByAggregateInput
    _min?: ImageGenerationBillingMinOrderByAggregateInput
    _sum?: ImageGenerationBillingSumOrderByAggregateInput
  }

  export type ImageGenerationBillingScalarWhereWithAggregatesInput = {
    AND?: ImageGenerationBillingScalarWhereWithAggregatesInput | ImageGenerationBillingScalarWhereWithAggregatesInput[]
    OR?: ImageGenerationBillingScalarWhereWithAggregatesInput[]
    NOT?: ImageGenerationBillingScalarWhereWithAggregatesInput | ImageGenerationBillingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImageGenerationBilling"> | string
    completed_at?: DateTimeWithAggregatesFilter<"ImageGenerationBilling"> | Date | string
    started_at?: DateTimeWithAggregatesFilter<"ImageGenerationBilling"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"ImageGenerationBilling"> | Date | string
    predict_time?: FloatWithAggregatesFilter<"ImageGenerationBilling"> | number
    model?: StringWithAggregatesFilter<"ImageGenerationBilling"> | string
    status?: StringWithAggregatesFilter<"ImageGenerationBilling"> | string
    cost?: FloatWithAggregatesFilter<"ImageGenerationBilling"> | number
    price?: FloatWithAggregatesFilter<"ImageGenerationBilling"> | number
    organization_id?: IntWithAggregatesFilter<"ImageGenerationBilling"> | number
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    organization_id?: IntFilter<"Invoice"> | number
    amount_paid?: IntFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    paid_at?: DateTimeFilter<"Invoice"> | Date | string
    pdf?: StringFilter<"Invoice"> | string
    url?: StringFilter<"Invoice"> | string
    id?: StringFilter<"Invoice"> | string
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type InvoiceOrderByWithRelationInput = {
    organization_id?: SortOrder
    amount_paid?: SortOrder
    currency?: SortOrder
    paid_at?: SortOrder
    pdf?: SortOrder
    url?: SortOrder
    id?: SortOrder
    Organization?: OrganizationOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    organization_id?: IntFilter<"Invoice"> | number
    amount_paid?: IntFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    paid_at?: DateTimeFilter<"Invoice"> | Date | string
    pdf?: StringFilter<"Invoice"> | string
    url?: StringFilter<"Invoice"> | string
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "id">

  export type InvoiceOrderByWithAggregationInput = {
    organization_id?: SortOrder
    amount_paid?: SortOrder
    currency?: SortOrder
    paid_at?: SortOrder
    pdf?: SortOrder
    url?: SortOrder
    id?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    organization_id?: IntWithAggregatesFilter<"Invoice"> | number
    amount_paid?: IntWithAggregatesFilter<"Invoice"> | number
    currency?: StringWithAggregatesFilter<"Invoice"> | string
    paid_at?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    pdf?: StringWithAggregatesFilter<"Invoice"> | string
    url?: StringWithAggregatesFilter<"Invoice"> | string
    id?: StringWithAggregatesFilter<"Invoice"> | string
  }

  export type LinkPageWhereInput = {
    AND?: LinkPageWhereInput | LinkPageWhereInput[]
    OR?: LinkPageWhereInput[]
    NOT?: LinkPageWhereInput | LinkPageWhereInput[]
    id?: IntFilter<"LinkPage"> | number
    organization_id?: IntFilter<"LinkPage"> | number
    created_at?: DateTimeFilter<"LinkPage"> | Date | string
    updated_at?: DateTimeFilter<"LinkPage"> | Date | string
    description?: StringNullableFilter<"LinkPage"> | string | null
    media_id?: IntNullableFilter<"LinkPage"> | number | null
    title?: StringNullableFilter<"LinkPage"> | string | null
    links?: JsonNullableListFilter<"LinkPage">
    Media?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type LinkPageOrderByWithRelationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    description?: SortOrderInput | SortOrder
    media_id?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    links?: SortOrder
    Media?: MediaOrderByWithRelationInput
    Organization?: OrganizationOrderByWithRelationInput
  }

  export type LinkPageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LinkPageWhereInput | LinkPageWhereInput[]
    OR?: LinkPageWhereInput[]
    NOT?: LinkPageWhereInput | LinkPageWhereInput[]
    organization_id?: IntFilter<"LinkPage"> | number
    created_at?: DateTimeFilter<"LinkPage"> | Date | string
    updated_at?: DateTimeFilter<"LinkPage"> | Date | string
    description?: StringNullableFilter<"LinkPage"> | string | null
    media_id?: IntNullableFilter<"LinkPage"> | number | null
    title?: StringNullableFilter<"LinkPage"> | string | null
    links?: JsonNullableListFilter<"LinkPage">
    Media?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id">

  export type LinkPageOrderByWithAggregationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    description?: SortOrderInput | SortOrder
    media_id?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    links?: SortOrder
    _count?: LinkPageCountOrderByAggregateInput
    _avg?: LinkPageAvgOrderByAggregateInput
    _max?: LinkPageMaxOrderByAggregateInput
    _min?: LinkPageMinOrderByAggregateInput
    _sum?: LinkPageSumOrderByAggregateInput
  }

  export type LinkPageScalarWhereWithAggregatesInput = {
    AND?: LinkPageScalarWhereWithAggregatesInput | LinkPageScalarWhereWithAggregatesInput[]
    OR?: LinkPageScalarWhereWithAggregatesInput[]
    NOT?: LinkPageScalarWhereWithAggregatesInput | LinkPageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LinkPage"> | number
    organization_id?: IntWithAggregatesFilter<"LinkPage"> | number
    created_at?: DateTimeWithAggregatesFilter<"LinkPage"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"LinkPage"> | Date | string
    description?: StringNullableWithAggregatesFilter<"LinkPage"> | string | null
    media_id?: IntNullableWithAggregatesFilter<"LinkPage"> | number | null
    title?: StringNullableWithAggregatesFilter<"LinkPage"> | string | null
    links?: JsonNullableListFilter<"LinkPage">
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: IntFilter<"Media"> | number
    url?: StringFilter<"Media"> | string
    alt_text?: StringFilter<"Media"> | string
    name?: StringFilter<"Media"> | string
    created_at?: DateTimeFilter<"Media"> | Date | string
    organization_id?: IntFilter<"Media"> | number
    updated_at?: DateTimeFilter<"Media"> | Date | string
    LinkPage?: LinkPageListRelationFilter
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    Users?: UsersListRelationFilter
    author?: AuthorListRelationFilter
    org_details?: XOR<Org_detailsNullableScalarRelationFilter, org_detailsWhereInput> | null
    struct?: StructListRelationFilter
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    alt_text?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    organization_id?: SortOrder
    updated_at?: SortOrder
    LinkPage?: LinkPageOrderByRelationAggregateInput
    Organization?: OrganizationOrderByWithRelationInput
    Users?: UsersOrderByRelationAggregateInput
    author?: authorOrderByRelationAggregateInput
    org_details?: org_detailsOrderByWithRelationInput
    struct?: structOrderByRelationAggregateInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    url?: StringFilter<"Media"> | string
    alt_text?: StringFilter<"Media"> | string
    name?: StringFilter<"Media"> | string
    created_at?: DateTimeFilter<"Media"> | Date | string
    organization_id?: IntFilter<"Media"> | number
    updated_at?: DateTimeFilter<"Media"> | Date | string
    LinkPage?: LinkPageListRelationFilter
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    Users?: UsersListRelationFilter
    author?: AuthorListRelationFilter
    org_details?: XOR<Org_detailsNullableScalarRelationFilter, org_detailsWhereInput> | null
    struct?: StructListRelationFilter
  }, "id">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    alt_text?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    organization_id?: SortOrder
    updated_at?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _avg?: MediaAvgOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
    _sum?: MediaSumOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Media"> | number
    url?: StringWithAggregatesFilter<"Media"> | string
    alt_text?: StringWithAggregatesFilter<"Media"> | string
    name?: StringWithAggregatesFilter<"Media"> | string
    created_at?: DateTimeWithAggregatesFilter<"Media"> | Date | string
    organization_id?: IntWithAggregatesFilter<"Media"> | number
    updated_at?: DateTimeWithAggregatesFilter<"Media"> | Date | string
  }

  export type MessagesWhereInput = {
    AND?: MessagesWhereInput | MessagesWhereInput[]
    OR?: MessagesWhereInput[]
    NOT?: MessagesWhereInput | MessagesWhereInput[]
    id?: IntFilter<"Messages"> | number
    created_at?: DateTimeFilter<"Messages"> | Date | string
    updated_at?: DateTimeFilter<"Messages"> | Date | string
    message?: StringFilter<"Messages"> | string
    first_name?: StringFilter<"Messages"> | string
    email?: StringFilter<"Messages"> | string
    phone_number?: StringNullableFilter<"Messages"> | string | null
    last_name?: StringNullableFilter<"Messages"> | string | null
    other_fields?: JsonNullableFilter<"Messages">
    organization_id?: IntFilter<"Messages"> | number
    viewed?: BoolFilter<"Messages"> | boolean
    archived?: BoolFilter<"Messages"> | boolean
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type MessagesOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    message?: SortOrder
    first_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    other_fields?: SortOrderInput | SortOrder
    organization_id?: SortOrder
    viewed?: SortOrder
    archived?: SortOrder
    Organization?: OrganizationOrderByWithRelationInput
  }

  export type MessagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MessagesWhereInput | MessagesWhereInput[]
    OR?: MessagesWhereInput[]
    NOT?: MessagesWhereInput | MessagesWhereInput[]
    created_at?: DateTimeFilter<"Messages"> | Date | string
    updated_at?: DateTimeFilter<"Messages"> | Date | string
    message?: StringFilter<"Messages"> | string
    first_name?: StringFilter<"Messages"> | string
    email?: StringFilter<"Messages"> | string
    phone_number?: StringNullableFilter<"Messages"> | string | null
    last_name?: StringNullableFilter<"Messages"> | string | null
    other_fields?: JsonNullableFilter<"Messages">
    organization_id?: IntFilter<"Messages"> | number
    viewed?: BoolFilter<"Messages"> | boolean
    archived?: BoolFilter<"Messages"> | boolean
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id">

  export type MessagesOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    message?: SortOrder
    first_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    other_fields?: SortOrderInput | SortOrder
    organization_id?: SortOrder
    viewed?: SortOrder
    archived?: SortOrder
    _count?: MessagesCountOrderByAggregateInput
    _avg?: MessagesAvgOrderByAggregateInput
    _max?: MessagesMaxOrderByAggregateInput
    _min?: MessagesMinOrderByAggregateInput
    _sum?: MessagesSumOrderByAggregateInput
  }

  export type MessagesScalarWhereWithAggregatesInput = {
    AND?: MessagesScalarWhereWithAggregatesInput | MessagesScalarWhereWithAggregatesInput[]
    OR?: MessagesScalarWhereWithAggregatesInput[]
    NOT?: MessagesScalarWhereWithAggregatesInput | MessagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Messages"> | number
    created_at?: DateTimeWithAggregatesFilter<"Messages"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Messages"> | Date | string
    message?: StringWithAggregatesFilter<"Messages"> | string
    first_name?: StringWithAggregatesFilter<"Messages"> | string
    email?: StringWithAggregatesFilter<"Messages"> | string
    phone_number?: StringNullableWithAggregatesFilter<"Messages"> | string | null
    last_name?: StringNullableWithAggregatesFilter<"Messages"> | string | null
    other_fields?: JsonNullableWithAggregatesFilter<"Messages">
    organization_id?: IntWithAggregatesFilter<"Messages"> | number
    viewed?: BoolWithAggregatesFilter<"Messages"> | boolean
    archived?: BoolWithAggregatesFilter<"Messages"> | boolean
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: IntFilter<"Organization"> | number
    company_name?: StringFilter<"Organization"> | string
    address?: StringNullableFilter<"Organization"> | string | null
    country?: StringNullableFilter<"Organization"> | string | null
    phone?: StringFilter<"Organization"> | string
    email?: StringFilter<"Organization"> | string
    company_description?: StringFilter<"Organization"> | string
    domain?: StringNullableFilter<"Organization"> | string | null
    logo?: StringNullableFilter<"Organization"> | string | null
    token?: StringFilter<"Organization"> | string
    stripe_customer_id?: StringNullableFilter<"Organization"> | string | null
    stripe_price_id?: StringFilter<"Organization"> | string
    stripe_is_subscribed?: BoolFilter<"Organization"> | boolean
    ai_subscription_id?: StringNullableFilter<"Organization"> | string | null
    notify_by_email?: BoolFilter<"Organization"> | boolean
    notify_by_sms?: BoolFilter<"Organization"> | boolean
    slack_webhook_url?: StringNullableFilter<"Organization"> | string | null
    city?: StringNullableFilter<"Organization"> | string | null
    postal_code?: StringNullableFilter<"Organization"> | string | null
    state?: StringNullableFilter<"Organization"> | string | null
    street_address?: StringNullableFilter<"Organization"> | string | null
    Category?: CategoryListRelationFilter
    Collection?: CollectionListRelationFilter
    Comment?: CommentListRelationFilter
    CompletionUsage?: CompletionUsageListRelationFilter
    Content?: ContentListRelationFilter
    ImageGenerationBilling?: ImageGenerationBillingListRelationFilter
    Invoice?: InvoiceListRelationFilter
    LinkPage?: LinkPageListRelationFilter
    Media?: MediaListRelationFilter
    Messages?: MessagesListRelationFilter
    Page?: PageListRelationFilter
    Subscription?: SubscriptionListRelationFilter
    Thread?: ThreadListRelationFilter
    Usage?: UsageListRelationFilter
    UserOrganization?: UserOrganizationListRelationFilter
    Users?: UsersListRelationFilter
    author?: AuthorListRelationFilter
    form_field?: Form_fieldListRelationFilter
    org_details?: XOR<Org_detailsNullableScalarRelationFilter, org_detailsWhereInput> | null
    struct?: StructListRelationFilter
    struct_set?: Struct_setListRelationFilter
    struct_set_instance?: Struct_set_instanceListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    company_name?: SortOrder
    address?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    phone?: SortOrder
    email?: SortOrder
    company_description?: SortOrder
    domain?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    token?: SortOrder
    stripe_customer_id?: SortOrderInput | SortOrder
    stripe_price_id?: SortOrder
    stripe_is_subscribed?: SortOrder
    ai_subscription_id?: SortOrderInput | SortOrder
    notify_by_email?: SortOrder
    notify_by_sms?: SortOrder
    slack_webhook_url?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    street_address?: SortOrderInput | SortOrder
    Category?: CategoryOrderByRelationAggregateInput
    Collection?: CollectionOrderByRelationAggregateInput
    Comment?: CommentOrderByRelationAggregateInput
    CompletionUsage?: CompletionUsageOrderByRelationAggregateInput
    Content?: ContentOrderByRelationAggregateInput
    ImageGenerationBilling?: ImageGenerationBillingOrderByRelationAggregateInput
    Invoice?: InvoiceOrderByRelationAggregateInput
    LinkPage?: LinkPageOrderByRelationAggregateInput
    Media?: MediaOrderByRelationAggregateInput
    Messages?: MessagesOrderByRelationAggregateInput
    Page?: PageOrderByRelationAggregateInput
    Subscription?: SubscriptionOrderByRelationAggregateInput
    Thread?: ThreadOrderByRelationAggregateInput
    Usage?: UsageOrderByRelationAggregateInput
    UserOrganization?: UserOrganizationOrderByRelationAggregateInput
    Users?: UsersOrderByRelationAggregateInput
    author?: authorOrderByRelationAggregateInput
    form_field?: form_fieldOrderByRelationAggregateInput
    org_details?: org_detailsOrderByWithRelationInput
    struct?: structOrderByRelationAggregateInput
    struct_set?: struct_setOrderByRelationAggregateInput
    struct_set_instance?: struct_set_instanceOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    stripe_customer_id?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    company_name?: StringFilter<"Organization"> | string
    address?: StringNullableFilter<"Organization"> | string | null
    country?: StringNullableFilter<"Organization"> | string | null
    phone?: StringFilter<"Organization"> | string
    email?: StringFilter<"Organization"> | string
    company_description?: StringFilter<"Organization"> | string
    domain?: StringNullableFilter<"Organization"> | string | null
    logo?: StringNullableFilter<"Organization"> | string | null
    token?: StringFilter<"Organization"> | string
    stripe_price_id?: StringFilter<"Organization"> | string
    stripe_is_subscribed?: BoolFilter<"Organization"> | boolean
    ai_subscription_id?: StringNullableFilter<"Organization"> | string | null
    notify_by_email?: BoolFilter<"Organization"> | boolean
    notify_by_sms?: BoolFilter<"Organization"> | boolean
    slack_webhook_url?: StringNullableFilter<"Organization"> | string | null
    city?: StringNullableFilter<"Organization"> | string | null
    postal_code?: StringNullableFilter<"Organization"> | string | null
    state?: StringNullableFilter<"Organization"> | string | null
    street_address?: StringNullableFilter<"Organization"> | string | null
    Category?: CategoryListRelationFilter
    Collection?: CollectionListRelationFilter
    Comment?: CommentListRelationFilter
    CompletionUsage?: CompletionUsageListRelationFilter
    Content?: ContentListRelationFilter
    ImageGenerationBilling?: ImageGenerationBillingListRelationFilter
    Invoice?: InvoiceListRelationFilter
    LinkPage?: LinkPageListRelationFilter
    Media?: MediaListRelationFilter
    Messages?: MessagesListRelationFilter
    Page?: PageListRelationFilter
    Subscription?: SubscriptionListRelationFilter
    Thread?: ThreadListRelationFilter
    Usage?: UsageListRelationFilter
    UserOrganization?: UserOrganizationListRelationFilter
    Users?: UsersListRelationFilter
    author?: AuthorListRelationFilter
    form_field?: Form_fieldListRelationFilter
    org_details?: XOR<Org_detailsNullableScalarRelationFilter, org_detailsWhereInput> | null
    struct?: StructListRelationFilter
    struct_set?: Struct_setListRelationFilter
    struct_set_instance?: Struct_set_instanceListRelationFilter
  }, "id" | "stripe_customer_id">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    company_name?: SortOrder
    address?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    phone?: SortOrder
    email?: SortOrder
    company_description?: SortOrder
    domain?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    token?: SortOrder
    stripe_customer_id?: SortOrderInput | SortOrder
    stripe_price_id?: SortOrder
    stripe_is_subscribed?: SortOrder
    ai_subscription_id?: SortOrderInput | SortOrder
    notify_by_email?: SortOrder
    notify_by_sms?: SortOrder
    slack_webhook_url?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    street_address?: SortOrderInput | SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _avg?: OrganizationAvgOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
    _sum?: OrganizationSumOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Organization"> | number
    company_name?: StringWithAggregatesFilter<"Organization"> | string
    address?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    country?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    phone?: StringWithAggregatesFilter<"Organization"> | string
    email?: StringWithAggregatesFilter<"Organization"> | string
    company_description?: StringWithAggregatesFilter<"Organization"> | string
    domain?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    token?: StringWithAggregatesFilter<"Organization"> | string
    stripe_customer_id?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    stripe_price_id?: StringWithAggregatesFilter<"Organization"> | string
    stripe_is_subscribed?: BoolWithAggregatesFilter<"Organization"> | boolean
    ai_subscription_id?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    notify_by_email?: BoolWithAggregatesFilter<"Organization"> | boolean
    notify_by_sms?: BoolWithAggregatesFilter<"Organization"> | boolean
    slack_webhook_url?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    city?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    postal_code?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    state?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    street_address?: StringNullableWithAggregatesFilter<"Organization"> | string | null
  }

  export type PageWhereInput = {
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    id?: IntFilter<"Page"> | number
    title?: StringFilter<"Page"> | string
    slug?: StringFilter<"Page"> | string
    created_at?: DateTimeFilter<"Page"> | Date | string
    updated_at?: DateTimeFilter<"Page"> | Date | string
    published?: BoolFilter<"Page"> | boolean
    archive?: BoolFilter<"Page"> | boolean
    data?: JsonNullableFilter<"Page">
    organization_id?: IntFilter<"Page"> | number
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type PageOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    published?: SortOrder
    archive?: SortOrder
    data?: SortOrderInput | SortOrder
    organization_id?: SortOrder
    Organization?: OrganizationOrderByWithRelationInput
  }

  export type PageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    title?: StringFilter<"Page"> | string
    slug?: StringFilter<"Page"> | string
    created_at?: DateTimeFilter<"Page"> | Date | string
    updated_at?: DateTimeFilter<"Page"> | Date | string
    published?: BoolFilter<"Page"> | boolean
    archive?: BoolFilter<"Page"> | boolean
    data?: JsonNullableFilter<"Page">
    organization_id?: IntFilter<"Page"> | number
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id">

  export type PageOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    published?: SortOrder
    archive?: SortOrder
    data?: SortOrderInput | SortOrder
    organization_id?: SortOrder
    _count?: PageCountOrderByAggregateInput
    _avg?: PageAvgOrderByAggregateInput
    _max?: PageMaxOrderByAggregateInput
    _min?: PageMinOrderByAggregateInput
    _sum?: PageSumOrderByAggregateInput
  }

  export type PageScalarWhereWithAggregatesInput = {
    AND?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    OR?: PageScalarWhereWithAggregatesInput[]
    NOT?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Page"> | number
    title?: StringWithAggregatesFilter<"Page"> | string
    slug?: StringWithAggregatesFilter<"Page"> | string
    created_at?: DateTimeWithAggregatesFilter<"Page"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Page"> | Date | string
    published?: BoolWithAggregatesFilter<"Page"> | boolean
    archive?: BoolWithAggregatesFilter<"Page"> | boolean
    data?: JsonNullableWithAggregatesFilter<"Page">
    organization_id?: IntWithAggregatesFilter<"Page"> | number
  }

  export type RunWhereInput = {
    AND?: RunWhereInput | RunWhereInput[]
    OR?: RunWhereInput[]
    NOT?: RunWhereInput | RunWhereInput[]
    id?: StringFilter<"Run"> | string
    created_at?: DateTimeFilter<"Run"> | Date | string
    assistant_id?: StringFilter<"Run"> | string
    thread_id?: StringFilter<"Run"> | string
    status?: StringFilter<"Run"> | string
    started_at?: DateTimeFilter<"Run"> | Date | string
    expires_at?: DateTimeNullableFilter<"Run"> | Date | string | null
    cancelled_at?: DateTimeNullableFilter<"Run"> | Date | string | null
    failed_at?: DateTimeNullableFilter<"Run"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"Run"> | Date | string | null
    last_error?: StringNullableFilter<"Run"> | string | null
    model?: StringFilter<"Run"> | string
    instructions?: StringNullableFilter<"Run"> | string | null
    Thread?: XOR<ThreadScalarRelationFilter, ThreadWhereInput>
    ThreadMessage?: ThreadMessageListRelationFilter
    Usage?: XOR<UsageNullableScalarRelationFilter, UsageWhereInput> | null
  }

  export type RunOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    assistant_id?: SortOrder
    thread_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    expires_at?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    failed_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    last_error?: SortOrderInput | SortOrder
    model?: SortOrder
    instructions?: SortOrderInput | SortOrder
    Thread?: ThreadOrderByWithRelationInput
    ThreadMessage?: ThreadMessageOrderByRelationAggregateInput
    Usage?: UsageOrderByWithRelationInput
  }

  export type RunWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RunWhereInput | RunWhereInput[]
    OR?: RunWhereInput[]
    NOT?: RunWhereInput | RunWhereInput[]
    created_at?: DateTimeFilter<"Run"> | Date | string
    assistant_id?: StringFilter<"Run"> | string
    thread_id?: StringFilter<"Run"> | string
    status?: StringFilter<"Run"> | string
    started_at?: DateTimeFilter<"Run"> | Date | string
    expires_at?: DateTimeNullableFilter<"Run"> | Date | string | null
    cancelled_at?: DateTimeNullableFilter<"Run"> | Date | string | null
    failed_at?: DateTimeNullableFilter<"Run"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"Run"> | Date | string | null
    last_error?: StringNullableFilter<"Run"> | string | null
    model?: StringFilter<"Run"> | string
    instructions?: StringNullableFilter<"Run"> | string | null
    Thread?: XOR<ThreadScalarRelationFilter, ThreadWhereInput>
    ThreadMessage?: ThreadMessageListRelationFilter
    Usage?: XOR<UsageNullableScalarRelationFilter, UsageWhereInput> | null
  }, "id">

  export type RunOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    assistant_id?: SortOrder
    thread_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    expires_at?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    failed_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    last_error?: SortOrderInput | SortOrder
    model?: SortOrder
    instructions?: SortOrderInput | SortOrder
    _count?: RunCountOrderByAggregateInput
    _max?: RunMaxOrderByAggregateInput
    _min?: RunMinOrderByAggregateInput
  }

  export type RunScalarWhereWithAggregatesInput = {
    AND?: RunScalarWhereWithAggregatesInput | RunScalarWhereWithAggregatesInput[]
    OR?: RunScalarWhereWithAggregatesInput[]
    NOT?: RunScalarWhereWithAggregatesInput | RunScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Run"> | string
    created_at?: DateTimeWithAggregatesFilter<"Run"> | Date | string
    assistant_id?: StringWithAggregatesFilter<"Run"> | string
    thread_id?: StringWithAggregatesFilter<"Run"> | string
    status?: StringWithAggregatesFilter<"Run"> | string
    started_at?: DateTimeWithAggregatesFilter<"Run"> | Date | string
    expires_at?: DateTimeNullableWithAggregatesFilter<"Run"> | Date | string | null
    cancelled_at?: DateTimeNullableWithAggregatesFilter<"Run"> | Date | string | null
    failed_at?: DateTimeNullableWithAggregatesFilter<"Run"> | Date | string | null
    completed_at?: DateTimeNullableWithAggregatesFilter<"Run"> | Date | string | null
    last_error?: StringNullableWithAggregatesFilter<"Run"> | string | null
    model?: StringWithAggregatesFilter<"Run"> | string
    instructions?: StringNullableWithAggregatesFilter<"Run"> | string | null
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: IntFilter<"Subscription"> | number
    organization_id?: IntFilter<"Subscription"> | number
    stripe_subscription_id?: StringFilter<"Subscription"> | string
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    stripe_subscription_id?: SortOrder
    Organization?: OrganizationOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    stripe_subscription_id?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    organization_id?: IntFilter<"Subscription"> | number
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "stripe_subscription_id">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    stripe_subscription_id?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Subscription"> | number
    organization_id?: IntWithAggregatesFilter<"Subscription"> | number
    stripe_subscription_id?: StringWithAggregatesFilter<"Subscription"> | string
  }

  export type TemplateWhereInput = {
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    id?: IntFilter<"Template"> | number
    name?: StringFilter<"Template"> | string
    collection_id?: IntFilter<"Template"> | number
    created_at?: DateTimeFilter<"Template"> | Date | string
    updated_at?: DateTimeFilter<"Template"> | Date | string
    Field?: FieldListRelationFilter
    Collection?: XOR<CollectionScalarRelationFilter, CollectionWhereInput>
    TemplateInstance?: TemplateInstanceListRelationFilter
  }

  export type TemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    collection_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    Field?: FieldOrderByRelationAggregateInput
    Collection?: CollectionOrderByWithRelationInput
    TemplateInstance?: TemplateInstanceOrderByRelationAggregateInput
  }

  export type TemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    name?: StringFilter<"Template"> | string
    collection_id?: IntFilter<"Template"> | number
    created_at?: DateTimeFilter<"Template"> | Date | string
    updated_at?: DateTimeFilter<"Template"> | Date | string
    Field?: FieldListRelationFilter
    Collection?: XOR<CollectionScalarRelationFilter, CollectionWhereInput>
    TemplateInstance?: TemplateInstanceListRelationFilter
  }, "id">

  export type TemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    collection_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TemplateCountOrderByAggregateInput
    _avg?: TemplateAvgOrderByAggregateInput
    _max?: TemplateMaxOrderByAggregateInput
    _min?: TemplateMinOrderByAggregateInput
    _sum?: TemplateSumOrderByAggregateInput
  }

  export type TemplateScalarWhereWithAggregatesInput = {
    AND?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    OR?: TemplateScalarWhereWithAggregatesInput[]
    NOT?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Template"> | number
    name?: StringWithAggregatesFilter<"Template"> | string
    collection_id?: IntWithAggregatesFilter<"Template"> | number
    created_at?: DateTimeWithAggregatesFilter<"Template"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Template"> | Date | string
  }

  export type TemplateInstanceWhereInput = {
    AND?: TemplateInstanceWhereInput | TemplateInstanceWhereInput[]
    OR?: TemplateInstanceWhereInput[]
    NOT?: TemplateInstanceWhereInput | TemplateInstanceWhereInput[]
    id?: IntFilter<"TemplateInstance"> | number
    values?: JsonFilter<"TemplateInstance">
    created_at?: DateTimeFilter<"TemplateInstance"> | Date | string
    updated_at?: DateTimeFilter<"TemplateInstance"> | Date | string
    title?: StringFilter<"TemplateInstance"> | string
    templateId?: IntFilter<"TemplateInstance"> | number
    ContentTemplateInstance?: ContentTemplateInstanceListRelationFilter
    Template?: XOR<TemplateScalarRelationFilter, TemplateWhereInput>
  }

  export type TemplateInstanceOrderByWithRelationInput = {
    id?: SortOrder
    values?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    title?: SortOrder
    templateId?: SortOrder
    ContentTemplateInstance?: ContentTemplateInstanceOrderByRelationAggregateInput
    Template?: TemplateOrderByWithRelationInput
  }

  export type TemplateInstanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TemplateInstanceWhereInput | TemplateInstanceWhereInput[]
    OR?: TemplateInstanceWhereInput[]
    NOT?: TemplateInstanceWhereInput | TemplateInstanceWhereInput[]
    values?: JsonFilter<"TemplateInstance">
    created_at?: DateTimeFilter<"TemplateInstance"> | Date | string
    updated_at?: DateTimeFilter<"TemplateInstance"> | Date | string
    title?: StringFilter<"TemplateInstance"> | string
    templateId?: IntFilter<"TemplateInstance"> | number
    ContentTemplateInstance?: ContentTemplateInstanceListRelationFilter
    Template?: XOR<TemplateScalarRelationFilter, TemplateWhereInput>
  }, "id">

  export type TemplateInstanceOrderByWithAggregationInput = {
    id?: SortOrder
    values?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    title?: SortOrder
    templateId?: SortOrder
    _count?: TemplateInstanceCountOrderByAggregateInput
    _avg?: TemplateInstanceAvgOrderByAggregateInput
    _max?: TemplateInstanceMaxOrderByAggregateInput
    _min?: TemplateInstanceMinOrderByAggregateInput
    _sum?: TemplateInstanceSumOrderByAggregateInput
  }

  export type TemplateInstanceScalarWhereWithAggregatesInput = {
    AND?: TemplateInstanceScalarWhereWithAggregatesInput | TemplateInstanceScalarWhereWithAggregatesInput[]
    OR?: TemplateInstanceScalarWhereWithAggregatesInput[]
    NOT?: TemplateInstanceScalarWhereWithAggregatesInput | TemplateInstanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TemplateInstance"> | number
    values?: JsonWithAggregatesFilter<"TemplateInstance">
    created_at?: DateTimeWithAggregatesFilter<"TemplateInstance"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"TemplateInstance"> | Date | string
    title?: StringWithAggregatesFilter<"TemplateInstance"> | string
    templateId?: IntWithAggregatesFilter<"TemplateInstance"> | number
  }

  export type ThreadWhereInput = {
    AND?: ThreadWhereInput | ThreadWhereInput[]
    OR?: ThreadWhereInput[]
    NOT?: ThreadWhereInput | ThreadWhereInput[]
    thread_id?: StringFilter<"Thread"> | string
    title?: StringFilter<"Thread"> | string
    created_at?: DateTimeFilter<"Thread"> | Date | string
    updated_at?: DateTimeFilter<"Thread"> | Date | string
    organization_id?: IntFilter<"Thread"> | number
    should_hide_thread?: BoolFilter<"Thread"> | boolean
    Run?: RunListRelationFilter
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    ThreadMessage?: ThreadMessageListRelationFilter
  }

  export type ThreadOrderByWithRelationInput = {
    thread_id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organization_id?: SortOrder
    should_hide_thread?: SortOrder
    Run?: RunOrderByRelationAggregateInput
    Organization?: OrganizationOrderByWithRelationInput
    ThreadMessage?: ThreadMessageOrderByRelationAggregateInput
  }

  export type ThreadWhereUniqueInput = Prisma.AtLeast<{
    thread_id?: string
    AND?: ThreadWhereInput | ThreadWhereInput[]
    OR?: ThreadWhereInput[]
    NOT?: ThreadWhereInput | ThreadWhereInput[]
    title?: StringFilter<"Thread"> | string
    created_at?: DateTimeFilter<"Thread"> | Date | string
    updated_at?: DateTimeFilter<"Thread"> | Date | string
    organization_id?: IntFilter<"Thread"> | number
    should_hide_thread?: BoolFilter<"Thread"> | boolean
    Run?: RunListRelationFilter
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    ThreadMessage?: ThreadMessageListRelationFilter
  }, "thread_id">

  export type ThreadOrderByWithAggregationInput = {
    thread_id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organization_id?: SortOrder
    should_hide_thread?: SortOrder
    _count?: ThreadCountOrderByAggregateInput
    _avg?: ThreadAvgOrderByAggregateInput
    _max?: ThreadMaxOrderByAggregateInput
    _min?: ThreadMinOrderByAggregateInput
    _sum?: ThreadSumOrderByAggregateInput
  }

  export type ThreadScalarWhereWithAggregatesInput = {
    AND?: ThreadScalarWhereWithAggregatesInput | ThreadScalarWhereWithAggregatesInput[]
    OR?: ThreadScalarWhereWithAggregatesInput[]
    NOT?: ThreadScalarWhereWithAggregatesInput | ThreadScalarWhereWithAggregatesInput[]
    thread_id?: StringWithAggregatesFilter<"Thread"> | string
    title?: StringWithAggregatesFilter<"Thread"> | string
    created_at?: DateTimeWithAggregatesFilter<"Thread"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Thread"> | Date | string
    organization_id?: IntWithAggregatesFilter<"Thread"> | number
    should_hide_thread?: BoolWithAggregatesFilter<"Thread"> | boolean
  }

  export type ThreadMessageWhereInput = {
    AND?: ThreadMessageWhereInput | ThreadMessageWhereInput[]
    OR?: ThreadMessageWhereInput[]
    NOT?: ThreadMessageWhereInput | ThreadMessageWhereInput[]
    id?: StringFilter<"ThreadMessage"> | string
    created_at?: DateTimeFilter<"ThreadMessage"> | Date | string
    thread_id?: StringFilter<"ThreadMessage"> | string
    role?: StringFilter<"ThreadMessage"> | string
    content?: StringFilter<"ThreadMessage"> | string
    assistant_id?: StringNullableFilter<"ThreadMessage"> | string | null
    run_id?: StringNullableFilter<"ThreadMessage"> | string | null
    Run?: XOR<RunNullableScalarRelationFilter, RunWhereInput> | null
    Thread?: XOR<ThreadScalarRelationFilter, ThreadWhereInput>
  }

  export type ThreadMessageOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    thread_id?: SortOrder
    role?: SortOrder
    content?: SortOrder
    assistant_id?: SortOrderInput | SortOrder
    run_id?: SortOrderInput | SortOrder
    Run?: RunOrderByWithRelationInput
    Thread?: ThreadOrderByWithRelationInput
  }

  export type ThreadMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ThreadMessageWhereInput | ThreadMessageWhereInput[]
    OR?: ThreadMessageWhereInput[]
    NOT?: ThreadMessageWhereInput | ThreadMessageWhereInput[]
    created_at?: DateTimeFilter<"ThreadMessage"> | Date | string
    thread_id?: StringFilter<"ThreadMessage"> | string
    role?: StringFilter<"ThreadMessage"> | string
    content?: StringFilter<"ThreadMessage"> | string
    assistant_id?: StringNullableFilter<"ThreadMessage"> | string | null
    run_id?: StringNullableFilter<"ThreadMessage"> | string | null
    Run?: XOR<RunNullableScalarRelationFilter, RunWhereInput> | null
    Thread?: XOR<ThreadScalarRelationFilter, ThreadWhereInput>
  }, "id">

  export type ThreadMessageOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    thread_id?: SortOrder
    role?: SortOrder
    content?: SortOrder
    assistant_id?: SortOrderInput | SortOrder
    run_id?: SortOrderInput | SortOrder
    _count?: ThreadMessageCountOrderByAggregateInput
    _max?: ThreadMessageMaxOrderByAggregateInput
    _min?: ThreadMessageMinOrderByAggregateInput
  }

  export type ThreadMessageScalarWhereWithAggregatesInput = {
    AND?: ThreadMessageScalarWhereWithAggregatesInput | ThreadMessageScalarWhereWithAggregatesInput[]
    OR?: ThreadMessageScalarWhereWithAggregatesInput[]
    NOT?: ThreadMessageScalarWhereWithAggregatesInput | ThreadMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ThreadMessage"> | string
    created_at?: DateTimeWithAggregatesFilter<"ThreadMessage"> | Date | string
    thread_id?: StringWithAggregatesFilter<"ThreadMessage"> | string
    role?: StringWithAggregatesFilter<"ThreadMessage"> | string
    content?: StringWithAggregatesFilter<"ThreadMessage"> | string
    assistant_id?: StringNullableWithAggregatesFilter<"ThreadMessage"> | string | null
    run_id?: StringNullableWithAggregatesFilter<"ThreadMessage"> | string | null
  }

  export type UsageWhereInput = {
    AND?: UsageWhereInput | UsageWhereInput[]
    OR?: UsageWhereInput[]
    NOT?: UsageWhereInput | UsageWhereInput[]
    run_id?: StringFilter<"Usage"> | string
    prompt_tokens?: IntFilter<"Usage"> | number
    completion_tokens?: IntFilter<"Usage"> | number
    total_tokens?: IntFilter<"Usage"> | number
    organization_id?: IntNullableFilter<"Usage"> | number | null
    created_at?: DateTimeFilter<"Usage"> | Date | string
    Organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    Run?: XOR<RunScalarRelationFilter, RunWhereInput>
  }

  export type UsageOrderByWithRelationInput = {
    run_id?: SortOrder
    prompt_tokens?: SortOrder
    completion_tokens?: SortOrder
    total_tokens?: SortOrder
    organization_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    Organization?: OrganizationOrderByWithRelationInput
    Run?: RunOrderByWithRelationInput
  }

  export type UsageWhereUniqueInput = Prisma.AtLeast<{
    run_id?: string
    AND?: UsageWhereInput | UsageWhereInput[]
    OR?: UsageWhereInput[]
    NOT?: UsageWhereInput | UsageWhereInput[]
    prompt_tokens?: IntFilter<"Usage"> | number
    completion_tokens?: IntFilter<"Usage"> | number
    total_tokens?: IntFilter<"Usage"> | number
    organization_id?: IntNullableFilter<"Usage"> | number | null
    created_at?: DateTimeFilter<"Usage"> | Date | string
    Organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    Run?: XOR<RunScalarRelationFilter, RunWhereInput>
  }, "run_id">

  export type UsageOrderByWithAggregationInput = {
    run_id?: SortOrder
    prompt_tokens?: SortOrder
    completion_tokens?: SortOrder
    total_tokens?: SortOrder
    organization_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: UsageCountOrderByAggregateInput
    _avg?: UsageAvgOrderByAggregateInput
    _max?: UsageMaxOrderByAggregateInput
    _min?: UsageMinOrderByAggregateInput
    _sum?: UsageSumOrderByAggregateInput
  }

  export type UsageScalarWhereWithAggregatesInput = {
    AND?: UsageScalarWhereWithAggregatesInput | UsageScalarWhereWithAggregatesInput[]
    OR?: UsageScalarWhereWithAggregatesInput[]
    NOT?: UsageScalarWhereWithAggregatesInput | UsageScalarWhereWithAggregatesInput[]
    run_id?: StringWithAggregatesFilter<"Usage"> | string
    prompt_tokens?: IntWithAggregatesFilter<"Usage"> | number
    completion_tokens?: IntWithAggregatesFilter<"Usage"> | number
    total_tokens?: IntWithAggregatesFilter<"Usage"> | number
    organization_id?: IntNullableWithAggregatesFilter<"Usage"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"Usage"> | Date | string
  }

  export type UserOrganizationWhereInput = {
    AND?: UserOrganizationWhereInput | UserOrganizationWhereInput[]
    OR?: UserOrganizationWhereInput[]
    NOT?: UserOrganizationWhereInput | UserOrganizationWhereInput[]
    user_id?: IntFilter<"UserOrganization"> | number
    organization_id?: IntFilter<"UserOrganization"> | number
    role?: StringFilter<"UserOrganization"> | string
    created_at?: DateTimeFilter<"UserOrganization"> | Date | string
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type UserOrganizationOrderByWithRelationInput = {
    user_id?: SortOrder
    organization_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    Organization?: OrganizationOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type UserOrganizationWhereUniqueInput = Prisma.AtLeast<{
    user_id_organization_id?: UserOrganizationUser_idOrganization_idCompoundUniqueInput
    AND?: UserOrganizationWhereInput | UserOrganizationWhereInput[]
    OR?: UserOrganizationWhereInput[]
    NOT?: UserOrganizationWhereInput | UserOrganizationWhereInput[]
    user_id?: IntFilter<"UserOrganization"> | number
    organization_id?: IntFilter<"UserOrganization"> | number
    role?: StringFilter<"UserOrganization"> | string
    created_at?: DateTimeFilter<"UserOrganization"> | Date | string
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "user_id_organization_id">

  export type UserOrganizationOrderByWithAggregationInput = {
    user_id?: SortOrder
    organization_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    _count?: UserOrganizationCountOrderByAggregateInput
    _avg?: UserOrganizationAvgOrderByAggregateInput
    _max?: UserOrganizationMaxOrderByAggregateInput
    _min?: UserOrganizationMinOrderByAggregateInput
    _sum?: UserOrganizationSumOrderByAggregateInput
  }

  export type UserOrganizationScalarWhereWithAggregatesInput = {
    AND?: UserOrganizationScalarWhereWithAggregatesInput | UserOrganizationScalarWhereWithAggregatesInput[]
    OR?: UserOrganizationScalarWhereWithAggregatesInput[]
    NOT?: UserOrganizationScalarWhereWithAggregatesInput | UserOrganizationScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"UserOrganization"> | number
    organization_id?: IntWithAggregatesFilter<"UserOrganization"> | number
    role?: StringWithAggregatesFilter<"UserOrganization"> | string
    created_at?: DateTimeWithAggregatesFilter<"UserOrganization"> | Date | string
  }

  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    id?: IntFilter<"Users"> | number
    email?: StringFilter<"Users"> | string
    username?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    security_pin?: StringNullableFilter<"Users"> | string | null
    created_at?: DateTimeFilter<"Users"> | Date | string
    organization_id?: IntFilter<"Users"> | number
    updated_at?: DateTimeFilter<"Users"> | Date | string
    role?: StringFilter<"Users"> | string
    media_id?: IntNullableFilter<"Users"> | number | null
    UserOrganization?: UserOrganizationListRelationFilter
    Media?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    security_pin?: SortOrderInput | SortOrder
    created_at?: SortOrder
    organization_id?: SortOrder
    updated_at?: SortOrder
    role?: SortOrder
    media_id?: SortOrderInput | SortOrder
    UserOrganization?: UserOrganizationOrderByRelationAggregateInput
    Media?: MediaOrderByWithRelationInput
    Organization?: OrganizationOrderByWithRelationInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    username?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    security_pin?: StringNullableFilter<"Users"> | string | null
    created_at?: DateTimeFilter<"Users"> | Date | string
    organization_id?: IntFilter<"Users"> | number
    updated_at?: DateTimeFilter<"Users"> | Date | string
    role?: StringFilter<"Users"> | string
    media_id?: IntNullableFilter<"Users"> | number | null
    UserOrganization?: UserOrganizationListRelationFilter
    Media?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "email">

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    security_pin?: SortOrderInput | SortOrder
    created_at?: SortOrder
    organization_id?: SortOrder
    updated_at?: SortOrder
    role?: SortOrder
    media_id?: SortOrderInput | SortOrder
    _count?: UsersCountOrderByAggregateInput
    _avg?: UsersAvgOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
    _sum?: UsersSumOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Users"> | number
    email?: StringWithAggregatesFilter<"Users"> | string
    username?: StringWithAggregatesFilter<"Users"> | string
    password?: StringWithAggregatesFilter<"Users"> | string
    security_pin?: StringNullableWithAggregatesFilter<"Users"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    organization_id?: IntWithAggregatesFilter<"Users"> | number
    updated_at?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    role?: StringWithAggregatesFilter<"Users"> | string
    media_id?: IntNullableWithAggregatesFilter<"Users"> | number | null
  }

  export type authorWhereInput = {
    AND?: authorWhereInput | authorWhereInput[]
    OR?: authorWhereInput[]
    NOT?: authorWhereInput | authorWhereInput[]
    id?: IntFilter<"author"> | number
    created_at?: DateTimeFilter<"author"> | Date | string
    updated_at?: DateTimeFilter<"author"> | Date | string
    name?: StringFilter<"author"> | string
    description?: StringFilter<"author"> | string
    organization_id?: IntFilter<"author"> | number
    media_id?: IntFilter<"author"> | number
    slug?: StringFilter<"author"> | string
    Content?: ContentListRelationFilter
    Media?: XOR<MediaScalarRelationFilter, MediaWhereInput>
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type authorOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
    organization_id?: SortOrder
    media_id?: SortOrder
    slug?: SortOrder
    Content?: ContentOrderByRelationAggregateInput
    Media?: MediaOrderByWithRelationInput
    Organization?: OrganizationOrderByWithRelationInput
  }

  export type authorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug_organization_id?: authorSlugOrganization_idCompoundUniqueInput
    AND?: authorWhereInput | authorWhereInput[]
    OR?: authorWhereInput[]
    NOT?: authorWhereInput | authorWhereInput[]
    created_at?: DateTimeFilter<"author"> | Date | string
    updated_at?: DateTimeFilter<"author"> | Date | string
    name?: StringFilter<"author"> | string
    description?: StringFilter<"author"> | string
    organization_id?: IntFilter<"author"> | number
    media_id?: IntFilter<"author"> | number
    slug?: StringFilter<"author"> | string
    Content?: ContentListRelationFilter
    Media?: XOR<MediaScalarRelationFilter, MediaWhereInput>
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "slug_organization_id">

  export type authorOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
    organization_id?: SortOrder
    media_id?: SortOrder
    slug?: SortOrder
    _count?: authorCountOrderByAggregateInput
    _avg?: authorAvgOrderByAggregateInput
    _max?: authorMaxOrderByAggregateInput
    _min?: authorMinOrderByAggregateInput
    _sum?: authorSumOrderByAggregateInput
  }

  export type authorScalarWhereWithAggregatesInput = {
    AND?: authorScalarWhereWithAggregatesInput | authorScalarWhereWithAggregatesInput[]
    OR?: authorScalarWhereWithAggregatesInput[]
    NOT?: authorScalarWhereWithAggregatesInput | authorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"author"> | number
    created_at?: DateTimeWithAggregatesFilter<"author"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"author"> | Date | string
    name?: StringWithAggregatesFilter<"author"> | string
    description?: StringWithAggregatesFilter<"author"> | string
    organization_id?: IntWithAggregatesFilter<"author"> | number
    media_id?: IntWithAggregatesFilter<"author"> | number
    slug?: StringWithAggregatesFilter<"author"> | string
  }

  export type form_fieldWhereInput = {
    AND?: form_fieldWhereInput | form_fieldWhereInput[]
    OR?: form_fieldWhereInput[]
    NOT?: form_fieldWhereInput | form_fieldWhereInput[]
    id?: IntFilter<"form_field"> | number
    name?: StringFilter<"form_field"> | string
    required?: BoolFilter<"form_field"> | boolean
    created_at?: DateTimeFilter<"form_field"> | Date | string
    updated_at?: DateTimeFilter<"form_field"> | Date | string
    type?: Enumfield_typeFilter<"form_field"> | $Enums.field_type
    default_value?: StringNullableFilter<"form_field"> | string | null
    help?: StringNullableFilter<"form_field"> | string | null
    order?: FloatFilter<"form_field"> | number
    description?: StringNullableFilter<"form_field"> | string | null
    label?: StringFilter<"form_field"> | string
    placeholder?: StringNullableFilter<"form_field"> | string | null
    regex?: StringNullableFilter<"form_field"> | string | null
    organization_id?: IntFilter<"form_field"> | number
    collection_id?: IntNullableFilter<"form_field"> | number | null
    options?: JsonNullableListFilter<"form_field">
    struct_id?: IntNullableFilter<"form_field"> | number | null
    Collection?: XOR<CollectionNullableScalarRelationFilter, CollectionWhereInput> | null
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    struct?: XOR<StructNullableScalarRelationFilter, structWhereInput> | null
  }

  export type form_fieldOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    required?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    type?: SortOrder
    default_value?: SortOrderInput | SortOrder
    help?: SortOrderInput | SortOrder
    order?: SortOrder
    description?: SortOrderInput | SortOrder
    label?: SortOrder
    placeholder?: SortOrderInput | SortOrder
    regex?: SortOrderInput | SortOrder
    organization_id?: SortOrder
    collection_id?: SortOrderInput | SortOrder
    options?: SortOrder
    struct_id?: SortOrderInput | SortOrder
    Collection?: CollectionOrderByWithRelationInput
    Organization?: OrganizationOrderByWithRelationInput
    struct?: structOrderByWithRelationInput
  }

  export type form_fieldWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name_collection_id?: form_fieldNameCollection_idCompoundUniqueInput
    AND?: form_fieldWhereInput | form_fieldWhereInput[]
    OR?: form_fieldWhereInput[]
    NOT?: form_fieldWhereInput | form_fieldWhereInput[]
    name?: StringFilter<"form_field"> | string
    required?: BoolFilter<"form_field"> | boolean
    created_at?: DateTimeFilter<"form_field"> | Date | string
    updated_at?: DateTimeFilter<"form_field"> | Date | string
    type?: Enumfield_typeFilter<"form_field"> | $Enums.field_type
    default_value?: StringNullableFilter<"form_field"> | string | null
    help?: StringNullableFilter<"form_field"> | string | null
    order?: FloatFilter<"form_field"> | number
    description?: StringNullableFilter<"form_field"> | string | null
    label?: StringFilter<"form_field"> | string
    placeholder?: StringNullableFilter<"form_field"> | string | null
    regex?: StringNullableFilter<"form_field"> | string | null
    organization_id?: IntFilter<"form_field"> | number
    collection_id?: IntNullableFilter<"form_field"> | number | null
    options?: JsonNullableListFilter<"form_field">
    struct_id?: IntNullableFilter<"form_field"> | number | null
    Collection?: XOR<CollectionNullableScalarRelationFilter, CollectionWhereInput> | null
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    struct?: XOR<StructNullableScalarRelationFilter, structWhereInput> | null
  }, "id" | "name_collection_id">

  export type form_fieldOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    required?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    type?: SortOrder
    default_value?: SortOrderInput | SortOrder
    help?: SortOrderInput | SortOrder
    order?: SortOrder
    description?: SortOrderInput | SortOrder
    label?: SortOrder
    placeholder?: SortOrderInput | SortOrder
    regex?: SortOrderInput | SortOrder
    organization_id?: SortOrder
    collection_id?: SortOrderInput | SortOrder
    options?: SortOrder
    struct_id?: SortOrderInput | SortOrder
    _count?: form_fieldCountOrderByAggregateInput
    _avg?: form_fieldAvgOrderByAggregateInput
    _max?: form_fieldMaxOrderByAggregateInput
    _min?: form_fieldMinOrderByAggregateInput
    _sum?: form_fieldSumOrderByAggregateInput
  }

  export type form_fieldScalarWhereWithAggregatesInput = {
    AND?: form_fieldScalarWhereWithAggregatesInput | form_fieldScalarWhereWithAggregatesInput[]
    OR?: form_fieldScalarWhereWithAggregatesInput[]
    NOT?: form_fieldScalarWhereWithAggregatesInput | form_fieldScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"form_field"> | number
    name?: StringWithAggregatesFilter<"form_field"> | string
    required?: BoolWithAggregatesFilter<"form_field"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"form_field"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"form_field"> | Date | string
    type?: Enumfield_typeWithAggregatesFilter<"form_field"> | $Enums.field_type
    default_value?: StringNullableWithAggregatesFilter<"form_field"> | string | null
    help?: StringNullableWithAggregatesFilter<"form_field"> | string | null
    order?: FloatWithAggregatesFilter<"form_field"> | number
    description?: StringNullableWithAggregatesFilter<"form_field"> | string | null
    label?: StringWithAggregatesFilter<"form_field"> | string
    placeholder?: StringNullableWithAggregatesFilter<"form_field"> | string | null
    regex?: StringNullableWithAggregatesFilter<"form_field"> | string | null
    organization_id?: IntWithAggregatesFilter<"form_field"> | number
    collection_id?: IntNullableWithAggregatesFilter<"form_field"> | number | null
    options?: JsonNullableListFilter<"form_field">
    struct_id?: IntNullableWithAggregatesFilter<"form_field"> | number | null
  }

  export type org_detailsWhereInput = {
    AND?: org_detailsWhereInput | org_detailsWhereInput[]
    OR?: org_detailsWhereInput[]
    NOT?: org_detailsWhereInput | org_detailsWhereInput[]
    gtag?: StringNullableFilter<"org_details"> | string | null
    url?: StringNullableFilter<"org_details"> | string | null
    company_name?: StringNullableFilter<"org_details"> | string | null
    phone?: StringNullableFilter<"org_details"> | string | null
    email?: StringNullableFilter<"org_details"> | string | null
    street_address?: StringNullableFilter<"org_details"> | string | null
    city?: StringNullableFilter<"org_details"> | string | null
    state?: StringNullableFilter<"org_details"> | string | null
    country?: StringNullableFilter<"org_details"> | string | null
    postal_code?: StringNullableFilter<"org_details"> | string | null
    socials?: StringNullableListFilter<"org_details">
    company_description?: StringNullableFilter<"org_details"> | string | null
    created_at?: DateTimeFilter<"org_details"> | Date | string
    id?: IntFilter<"org_details"> | number
    media_id?: IntNullableFilter<"org_details"> | number | null
    organization_id?: IntFilter<"org_details"> | number
    updated_at?: DateTimeFilter<"org_details"> | Date | string
    Media?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type org_detailsOrderByWithRelationInput = {
    gtag?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    company_name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    street_address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    socials?: SortOrder
    company_description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    id?: SortOrder
    media_id?: SortOrderInput | SortOrder
    organization_id?: SortOrder
    updated_at?: SortOrder
    Media?: MediaOrderByWithRelationInput
    Organization?: OrganizationOrderByWithRelationInput
  }

  export type org_detailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    media_id?: number
    organization_id?: number
    AND?: org_detailsWhereInput | org_detailsWhereInput[]
    OR?: org_detailsWhereInput[]
    NOT?: org_detailsWhereInput | org_detailsWhereInput[]
    gtag?: StringNullableFilter<"org_details"> | string | null
    url?: StringNullableFilter<"org_details"> | string | null
    company_name?: StringNullableFilter<"org_details"> | string | null
    phone?: StringNullableFilter<"org_details"> | string | null
    email?: StringNullableFilter<"org_details"> | string | null
    street_address?: StringNullableFilter<"org_details"> | string | null
    city?: StringNullableFilter<"org_details"> | string | null
    state?: StringNullableFilter<"org_details"> | string | null
    country?: StringNullableFilter<"org_details"> | string | null
    postal_code?: StringNullableFilter<"org_details"> | string | null
    socials?: StringNullableListFilter<"org_details">
    company_description?: StringNullableFilter<"org_details"> | string | null
    created_at?: DateTimeFilter<"org_details"> | Date | string
    updated_at?: DateTimeFilter<"org_details"> | Date | string
    Media?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "media_id" | "organization_id">

  export type org_detailsOrderByWithAggregationInput = {
    gtag?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    company_name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    street_address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    socials?: SortOrder
    company_description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    id?: SortOrder
    media_id?: SortOrderInput | SortOrder
    organization_id?: SortOrder
    updated_at?: SortOrder
    _count?: org_detailsCountOrderByAggregateInput
    _avg?: org_detailsAvgOrderByAggregateInput
    _max?: org_detailsMaxOrderByAggregateInput
    _min?: org_detailsMinOrderByAggregateInput
    _sum?: org_detailsSumOrderByAggregateInput
  }

  export type org_detailsScalarWhereWithAggregatesInput = {
    AND?: org_detailsScalarWhereWithAggregatesInput | org_detailsScalarWhereWithAggregatesInput[]
    OR?: org_detailsScalarWhereWithAggregatesInput[]
    NOT?: org_detailsScalarWhereWithAggregatesInput | org_detailsScalarWhereWithAggregatesInput[]
    gtag?: StringNullableWithAggregatesFilter<"org_details"> | string | null
    url?: StringNullableWithAggregatesFilter<"org_details"> | string | null
    company_name?: StringNullableWithAggregatesFilter<"org_details"> | string | null
    phone?: StringNullableWithAggregatesFilter<"org_details"> | string | null
    email?: StringNullableWithAggregatesFilter<"org_details"> | string | null
    street_address?: StringNullableWithAggregatesFilter<"org_details"> | string | null
    city?: StringNullableWithAggregatesFilter<"org_details"> | string | null
    state?: StringNullableWithAggregatesFilter<"org_details"> | string | null
    country?: StringNullableWithAggregatesFilter<"org_details"> | string | null
    postal_code?: StringNullableWithAggregatesFilter<"org_details"> | string | null
    socials?: StringNullableListFilter<"org_details">
    company_description?: StringNullableWithAggregatesFilter<"org_details"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"org_details"> | Date | string
    id?: IntWithAggregatesFilter<"org_details"> | number
    media_id?: IntNullableWithAggregatesFilter<"org_details"> | number | null
    organization_id?: IntWithAggregatesFilter<"org_details"> | number
    updated_at?: DateTimeWithAggregatesFilter<"org_details"> | Date | string
  }

  export type structWhereInput = {
    AND?: structWhereInput | structWhereInput[]
    OR?: structWhereInput[]
    NOT?: structWhereInput | structWhereInput[]
    id?: IntFilter<"struct"> | number
    created_at?: DateTimeFilter<"struct"> | Date | string
    updated_at?: DateTimeFilter<"struct"> | Date | string
    name?: StringFilter<"struct"> | string
    group?: StringFilter<"struct"> | string
    organization_id?: IntFilter<"struct"> | number
    cms?: BoolFilter<"struct"> | boolean
    description?: StringNullableFilter<"struct"> | string | null
    media_id?: IntNullableFilter<"struct"> | number | null
    form_field?: Form_fieldListRelationFilter
    Media?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    struct_set_instance?: Struct_set_instanceListRelationFilter
  }

  export type structOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    group?: SortOrder
    organization_id?: SortOrder
    cms?: SortOrder
    description?: SortOrderInput | SortOrder
    media_id?: SortOrderInput | SortOrder
    form_field?: form_fieldOrderByRelationAggregateInput
    Media?: MediaOrderByWithRelationInput
    Organization?: OrganizationOrderByWithRelationInput
    struct_set_instance?: struct_set_instanceOrderByRelationAggregateInput
  }

  export type structWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: structWhereInput | structWhereInput[]
    OR?: structWhereInput[]
    NOT?: structWhereInput | structWhereInput[]
    created_at?: DateTimeFilter<"struct"> | Date | string
    updated_at?: DateTimeFilter<"struct"> | Date | string
    name?: StringFilter<"struct"> | string
    group?: StringFilter<"struct"> | string
    organization_id?: IntFilter<"struct"> | number
    cms?: BoolFilter<"struct"> | boolean
    description?: StringNullableFilter<"struct"> | string | null
    media_id?: IntNullableFilter<"struct"> | number | null
    form_field?: Form_fieldListRelationFilter
    Media?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    struct_set_instance?: Struct_set_instanceListRelationFilter
  }, "id">

  export type structOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    group?: SortOrder
    organization_id?: SortOrder
    cms?: SortOrder
    description?: SortOrderInput | SortOrder
    media_id?: SortOrderInput | SortOrder
    _count?: structCountOrderByAggregateInput
    _avg?: structAvgOrderByAggregateInput
    _max?: structMaxOrderByAggregateInput
    _min?: structMinOrderByAggregateInput
    _sum?: structSumOrderByAggregateInput
  }

  export type structScalarWhereWithAggregatesInput = {
    AND?: structScalarWhereWithAggregatesInput | structScalarWhereWithAggregatesInput[]
    OR?: structScalarWhereWithAggregatesInput[]
    NOT?: structScalarWhereWithAggregatesInput | structScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"struct"> | number
    created_at?: DateTimeWithAggregatesFilter<"struct"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"struct"> | Date | string
    name?: StringWithAggregatesFilter<"struct"> | string
    group?: StringWithAggregatesFilter<"struct"> | string
    organization_id?: IntWithAggregatesFilter<"struct"> | number
    cms?: BoolWithAggregatesFilter<"struct"> | boolean
    description?: StringNullableWithAggregatesFilter<"struct"> | string | null
    media_id?: IntNullableWithAggregatesFilter<"struct"> | number | null
  }

  export type struct_setWhereInput = {
    AND?: struct_setWhereInput | struct_setWhereInput[]
    OR?: struct_setWhereInput[]
    NOT?: struct_setWhereInput | struct_setWhereInput[]
    id?: IntFilter<"struct_set"> | number
    name?: StringFilter<"struct_set"> | string
    description?: StringFilter<"struct_set"> | string
    created_at?: DateTimeFilter<"struct_set"> | Date | string
    updated_at?: DateTimeFilter<"struct_set"> | Date | string
    organization_id?: IntFilter<"struct_set"> | number
    icon?: StringFilter<"struct_set"> | string
    pinned?: BoolFilter<"struct_set"> | boolean
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    struct_set_instance?: Struct_set_instanceListRelationFilter
  }

  export type struct_setOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organization_id?: SortOrder
    icon?: SortOrder
    pinned?: SortOrder
    Organization?: OrganizationOrderByWithRelationInput
    struct_set_instance?: struct_set_instanceOrderByRelationAggregateInput
  }

  export type struct_setWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: struct_setWhereInput | struct_setWhereInput[]
    OR?: struct_setWhereInput[]
    NOT?: struct_setWhereInput | struct_setWhereInput[]
    name?: StringFilter<"struct_set"> | string
    description?: StringFilter<"struct_set"> | string
    created_at?: DateTimeFilter<"struct_set"> | Date | string
    updated_at?: DateTimeFilter<"struct_set"> | Date | string
    organization_id?: IntFilter<"struct_set"> | number
    icon?: StringFilter<"struct_set"> | string
    pinned?: BoolFilter<"struct_set"> | boolean
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    struct_set_instance?: Struct_set_instanceListRelationFilter
  }, "id">

  export type struct_setOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organization_id?: SortOrder
    icon?: SortOrder
    pinned?: SortOrder
    _count?: struct_setCountOrderByAggregateInput
    _avg?: struct_setAvgOrderByAggregateInput
    _max?: struct_setMaxOrderByAggregateInput
    _min?: struct_setMinOrderByAggregateInput
    _sum?: struct_setSumOrderByAggregateInput
  }

  export type struct_setScalarWhereWithAggregatesInput = {
    AND?: struct_setScalarWhereWithAggregatesInput | struct_setScalarWhereWithAggregatesInput[]
    OR?: struct_setScalarWhereWithAggregatesInput[]
    NOT?: struct_setScalarWhereWithAggregatesInput | struct_setScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"struct_set"> | number
    name?: StringWithAggregatesFilter<"struct_set"> | string
    description?: StringWithAggregatesFilter<"struct_set"> | string
    created_at?: DateTimeWithAggregatesFilter<"struct_set"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"struct_set"> | Date | string
    organization_id?: IntWithAggregatesFilter<"struct_set"> | number
    icon?: StringWithAggregatesFilter<"struct_set"> | string
    pinned?: BoolWithAggregatesFilter<"struct_set"> | boolean
  }

  export type struct_set_instanceWhereInput = {
    AND?: struct_set_instanceWhereInput | struct_set_instanceWhereInput[]
    OR?: struct_set_instanceWhereInput[]
    NOT?: struct_set_instanceWhereInput | struct_set_instanceWhereInput[]
    id?: IntFilter<"struct_set_instance"> | number
    created_at?: DateTimeFilter<"struct_set_instance"> | Date | string
    updated_at?: DateTimeFilter<"struct_set_instance"> | Date | string
    instance_data?: JsonFilter<"struct_set_instance">
    organization_id?: IntFilter<"struct_set_instance"> | number
    struct_set_id?: IntFilter<"struct_set_instance"> | number
    struct_id?: IntFilter<"struct_set_instance"> | number
    key?: StringFilter<"struct_set_instance"> | string
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    struct?: XOR<StructScalarRelationFilter, structWhereInput>
    struct_set?: XOR<Struct_setScalarRelationFilter, struct_setWhereInput>
  }

  export type struct_set_instanceOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    instance_data?: SortOrder
    organization_id?: SortOrder
    struct_set_id?: SortOrder
    struct_id?: SortOrder
    key?: SortOrder
    Organization?: OrganizationOrderByWithRelationInput
    struct?: structOrderByWithRelationInput
    struct_set?: struct_setOrderByWithRelationInput
  }

  export type struct_set_instanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    key_struct_set_id?: struct_set_instanceKeyStruct_set_idCompoundUniqueInput
    AND?: struct_set_instanceWhereInput | struct_set_instanceWhereInput[]
    OR?: struct_set_instanceWhereInput[]
    NOT?: struct_set_instanceWhereInput | struct_set_instanceWhereInput[]
    created_at?: DateTimeFilter<"struct_set_instance"> | Date | string
    updated_at?: DateTimeFilter<"struct_set_instance"> | Date | string
    instance_data?: JsonFilter<"struct_set_instance">
    organization_id?: IntFilter<"struct_set_instance"> | number
    struct_set_id?: IntFilter<"struct_set_instance"> | number
    struct_id?: IntFilter<"struct_set_instance"> | number
    key?: StringFilter<"struct_set_instance"> | string
    Organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    struct?: XOR<StructScalarRelationFilter, structWhereInput>
    struct_set?: XOR<Struct_setScalarRelationFilter, struct_setWhereInput>
  }, "id" | "key_struct_set_id">

  export type struct_set_instanceOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    instance_data?: SortOrder
    organization_id?: SortOrder
    struct_set_id?: SortOrder
    struct_id?: SortOrder
    key?: SortOrder
    _count?: struct_set_instanceCountOrderByAggregateInput
    _avg?: struct_set_instanceAvgOrderByAggregateInput
    _max?: struct_set_instanceMaxOrderByAggregateInput
    _min?: struct_set_instanceMinOrderByAggregateInput
    _sum?: struct_set_instanceSumOrderByAggregateInput
  }

  export type struct_set_instanceScalarWhereWithAggregatesInput = {
    AND?: struct_set_instanceScalarWhereWithAggregatesInput | struct_set_instanceScalarWhereWithAggregatesInput[]
    OR?: struct_set_instanceScalarWhereWithAggregatesInput[]
    NOT?: struct_set_instanceScalarWhereWithAggregatesInput | struct_set_instanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"struct_set_instance"> | number
    created_at?: DateTimeWithAggregatesFilter<"struct_set_instance"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"struct_set_instance"> | Date | string
    instance_data?: JsonWithAggregatesFilter<"struct_set_instance">
    organization_id?: IntWithAggregatesFilter<"struct_set_instance"> | number
    struct_set_id?: IntWithAggregatesFilter<"struct_set_instance"> | number
    struct_id?: IntWithAggregatesFilter<"struct_set_instance"> | number
    key?: StringWithAggregatesFilter<"struct_set_instance"> | string
  }

  export type CategoryCreateInput = {
    name: string
    slug: string
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    short_name: string
    Collection: CollectionCreateNestedOneWithoutCategoryInput
    Organization: OrganizationCreateNestedOneWithoutCategoryInput
    Category?: CategoryCreateNestedOneWithoutOther_CategoryInput
    other_Category?: CategoryCreateNestedManyWithoutCategoryInput
    Content?: ContentCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    organization_id: number
    slug: string
    description?: string | null
    parent_id?: number | null
    collection_id: number
    created_at?: Date | string
    updated_at: Date | string
    short_name: string
    other_Category?: CategoryUncheckedCreateNestedManyWithoutCategoryInput
    Content?: ContentUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    short_name?: StringFieldUpdateOperationsInput | string
    Collection?: CollectionUpdateOneRequiredWithoutCategoryNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutCategoryNestedInput
    Category?: CategoryUpdateOneWithoutOther_CategoryNestedInput
    other_Category?: CategoryUpdateManyWithoutCategoryNestedInput
    Content?: ContentUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    collection_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    short_name?: StringFieldUpdateOperationsInput | string
    other_Category?: CategoryUncheckedUpdateManyWithoutCategoryNestedInput
    Content?: ContentUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
    organization_id: number
    slug: string
    description?: string | null
    parent_id?: number | null
    collection_id: number
    created_at?: Date | string
    updated_at: Date | string
    short_name: string
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    short_name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    collection_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    short_name?: StringFieldUpdateOperationsInput | string
  }

  export type CollectionCreateInput = {
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    icon: string
    page_content?: boolean
    enable_author?: boolean
    enable_comments?: boolean
    enable_featured_posts?: boolean
    enable_rating?: boolean
    path_prefix?: string | null
    title?: string | null
    Category?: CategoryCreateNestedManyWithoutCollectionInput
    Organization: OrganizationCreateNestedOneWithoutCollectionInput
    Content?: ContentCreateNestedManyWithoutCollectionInput
    Field?: FieldCreateNestedManyWithoutCollectionInput
    Template?: TemplateCreateNestedManyWithoutCollectionInput
    form_field?: form_fieldCreateNestedManyWithoutCollectionInput
  }

  export type CollectionUncheckedCreateInput = {
    id?: number
    name: string
    organization_id: number
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    icon: string
    page_content?: boolean
    enable_author?: boolean
    enable_comments?: boolean
    enable_featured_posts?: boolean
    enable_rating?: boolean
    path_prefix?: string | null
    title?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutCollectionInput
    Content?: ContentUncheckedCreateNestedManyWithoutCollectionInput
    Field?: FieldUncheckedCreateNestedManyWithoutCollectionInput
    Template?: TemplateUncheckedCreateNestedManyWithoutCollectionInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type CollectionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    page_content?: BoolFieldUpdateOperationsInput | boolean
    enable_author?: BoolFieldUpdateOperationsInput | boolean
    enable_comments?: BoolFieldUpdateOperationsInput | boolean
    enable_featured_posts?: BoolFieldUpdateOperationsInput | boolean
    enable_rating?: BoolFieldUpdateOperationsInput | boolean
    path_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutCollectionNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutCollectionNestedInput
    Content?: ContentUpdateManyWithoutCollectionNestedInput
    Field?: FieldUpdateManyWithoutCollectionNestedInput
    Template?: TemplateUpdateManyWithoutCollectionNestedInput
    form_field?: form_fieldUpdateManyWithoutCollectionNestedInput
  }

  export type CollectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    page_content?: BoolFieldUpdateOperationsInput | boolean
    enable_author?: BoolFieldUpdateOperationsInput | boolean
    enable_comments?: BoolFieldUpdateOperationsInput | boolean
    enable_featured_posts?: BoolFieldUpdateOperationsInput | boolean
    enable_rating?: BoolFieldUpdateOperationsInput | boolean
    path_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutCollectionNestedInput
    Content?: ContentUncheckedUpdateManyWithoutCollectionNestedInput
    Field?: FieldUncheckedUpdateManyWithoutCollectionNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutCollectionNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type CollectionCreateManyInput = {
    id?: number
    name: string
    organization_id: number
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    icon: string
    page_content?: boolean
    enable_author?: boolean
    enable_comments?: boolean
    enable_featured_posts?: boolean
    enable_rating?: boolean
    path_prefix?: string | null
    title?: string | null
  }

  export type CollectionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    page_content?: BoolFieldUpdateOperationsInput | boolean
    enable_author?: BoolFieldUpdateOperationsInput | boolean
    enable_comments?: BoolFieldUpdateOperationsInput | boolean
    enable_featured_posts?: BoolFieldUpdateOperationsInput | boolean
    enable_rating?: BoolFieldUpdateOperationsInput | boolean
    path_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CollectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    page_content?: BoolFieldUpdateOperationsInput | boolean
    enable_author?: BoolFieldUpdateOperationsInput | boolean
    enable_comments?: BoolFieldUpdateOperationsInput | boolean
    enable_featured_posts?: BoolFieldUpdateOperationsInput | boolean
    enable_rating?: BoolFieldUpdateOperationsInput | boolean
    path_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateInput = {
    text: string
    author: string
    created_at?: Date | string
    updated_at: Date | string
    approved?: boolean
    email: string
    image_url?: string | null
    rating?: number | null
    Content: ContentCreateNestedOneWithoutCommentInput
    Organization: OrganizationCreateNestedOneWithoutCommentInput
    Comment?: CommentCreateNestedOneWithoutOther_CommentInput
    other_Comment?: CommentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    text: string
    author: string
    content_id: number
    parent_id?: number | null
    created_at?: Date | string
    updated_at: Date | string
    approved?: boolean
    organization_id: number
    email: string
    image_url?: string | null
    rating?: number | null
    other_Comment?: CommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    Content?: ContentUpdateOneRequiredWithoutCommentNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutCommentNestedInput
    Comment?: CommentUpdateOneWithoutOther_CommentNestedInput
    other_Comment?: CommentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    content_id?: IntFieldUpdateOperationsInput | number
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    organization_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    other_Comment?: CommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: number
    text: string
    author: string
    content_id: number
    parent_id?: number | null
    created_at?: Date | string
    updated_at: Date | string
    approved?: boolean
    organization_id: number
    email: string
    image_url?: string | null
    rating?: number | null
  }

  export type CommentUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    content_id?: IntFieldUpdateOperationsInput | number
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    organization_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CompletionUsageCreateInput = {
    created_at?: Date | string
    prompt_tokens: number
    completion_tokens: number
    total_tokens: number
    prompt_tokens_cost: number
    completion_tokens_cost: number
    total_tokens_cost: number
    prompt_tokens_price: number
    completion_tokens_price: number
    total_tokens_price: number
    Organization: OrganizationCreateNestedOneWithoutCompletionUsageInput
  }

  export type CompletionUsageUncheckedCreateInput = {
    created_at?: Date | string
    prompt_tokens: number
    completion_tokens: number
    total_tokens: number
    prompt_tokens_cost: number
    completion_tokens_cost: number
    total_tokens_cost: number
    prompt_tokens_price: number
    completion_tokens_price: number
    total_tokens_price: number
    id?: number
    organization_id: number
  }

  export type CompletionUsageUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt_tokens?: IntFieldUpdateOperationsInput | number
    completion_tokens?: IntFieldUpdateOperationsInput | number
    total_tokens?: IntFieldUpdateOperationsInput | number
    prompt_tokens_cost?: FloatFieldUpdateOperationsInput | number
    completion_tokens_cost?: FloatFieldUpdateOperationsInput | number
    total_tokens_cost?: FloatFieldUpdateOperationsInput | number
    prompt_tokens_price?: FloatFieldUpdateOperationsInput | number
    completion_tokens_price?: FloatFieldUpdateOperationsInput | number
    total_tokens_price?: FloatFieldUpdateOperationsInput | number
    Organization?: OrganizationUpdateOneRequiredWithoutCompletionUsageNestedInput
  }

  export type CompletionUsageUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt_tokens?: IntFieldUpdateOperationsInput | number
    completion_tokens?: IntFieldUpdateOperationsInput | number
    total_tokens?: IntFieldUpdateOperationsInput | number
    prompt_tokens_cost?: FloatFieldUpdateOperationsInput | number
    completion_tokens_cost?: FloatFieldUpdateOperationsInput | number
    total_tokens_cost?: FloatFieldUpdateOperationsInput | number
    prompt_tokens_price?: FloatFieldUpdateOperationsInput | number
    completion_tokens_price?: FloatFieldUpdateOperationsInput | number
    total_tokens_price?: FloatFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
    organization_id?: IntFieldUpdateOperationsInput | number
  }

  export type CompletionUsageCreateManyInput = {
    created_at?: Date | string
    prompt_tokens: number
    completion_tokens: number
    total_tokens: number
    prompt_tokens_cost: number
    completion_tokens_cost: number
    total_tokens_cost: number
    prompt_tokens_price: number
    completion_tokens_price: number
    total_tokens_price: number
    id?: number
    organization_id: number
  }

  export type CompletionUsageUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt_tokens?: IntFieldUpdateOperationsInput | number
    completion_tokens?: IntFieldUpdateOperationsInput | number
    total_tokens?: IntFieldUpdateOperationsInput | number
    prompt_tokens_cost?: FloatFieldUpdateOperationsInput | number
    completion_tokens_cost?: FloatFieldUpdateOperationsInput | number
    total_tokens_cost?: FloatFieldUpdateOperationsInput | number
    prompt_tokens_price?: FloatFieldUpdateOperationsInput | number
    completion_tokens_price?: FloatFieldUpdateOperationsInput | number
    total_tokens_price?: FloatFieldUpdateOperationsInput | number
  }

  export type CompletionUsageUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt_tokens?: IntFieldUpdateOperationsInput | number
    completion_tokens?: IntFieldUpdateOperationsInput | number
    total_tokens?: IntFieldUpdateOperationsInput | number
    prompt_tokens_cost?: FloatFieldUpdateOperationsInput | number
    completion_tokens_cost?: FloatFieldUpdateOperationsInput | number
    total_tokens_cost?: FloatFieldUpdateOperationsInput | number
    prompt_tokens_price?: FloatFieldUpdateOperationsInput | number
    completion_tokens_price?: FloatFieldUpdateOperationsInput | number
    total_tokens_price?: FloatFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
    organization_id?: IntFieldUpdateOperationsInput | number
  }

  export type ContentCreateInput = {
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    blocks: JsonNullValueInput | InputJsonValue
    html: string
    archive?: boolean
    description?: string | null
    draft?: boolean
    slug: string
    title?: string | null
    comments_enabled?: boolean
    featured?: boolean
    content_category?: ContentCreatecontent_categoryInput | string[]
    Comment?: CommentCreateNestedManyWithoutContentInput
    author?: authorCreateNestedOneWithoutContentInput
    Collection: CollectionCreateNestedOneWithoutContentInput
    Organization?: OrganizationCreateNestedOneWithoutContentInput
    ContentTemplateInstance?: ContentTemplateInstanceCreateNestedManyWithoutContentInput
    Category?: CategoryCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    blocks: JsonNullValueInput | InputJsonValue
    html: string
    archive?: boolean
    collection_id: number
    description?: string | null
    draft?: boolean
    slug: string
    title?: string | null
    comments_enabled?: boolean
    organization_id?: number | null
    author_id?: number | null
    featured?: boolean
    content_category?: ContentCreatecontent_categoryInput | string[]
    Comment?: CommentUncheckedCreateNestedManyWithoutContentInput
    ContentTemplateInstance?: ContentTemplateInstanceUncheckedCreateNestedManyWithoutContentInput
    Category?: CategoryUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentUpdateInput = {
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: JsonNullValueInput | InputJsonValue
    html?: StringFieldUpdateOperationsInput | string
    archive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    draft?: BoolFieldUpdateOperationsInput | boolean
    slug?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comments_enabled?: BoolFieldUpdateOperationsInput | boolean
    featured?: BoolFieldUpdateOperationsInput | boolean
    content_category?: ContentUpdatecontent_categoryInput | string[]
    Comment?: CommentUpdateManyWithoutContentNestedInput
    author?: authorUpdateOneWithoutContentNestedInput
    Collection?: CollectionUpdateOneRequiredWithoutContentNestedInput
    Organization?: OrganizationUpdateOneWithoutContentNestedInput
    ContentTemplateInstance?: ContentTemplateInstanceUpdateManyWithoutContentNestedInput
    Category?: CategoryUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: JsonNullValueInput | InputJsonValue
    html?: StringFieldUpdateOperationsInput | string
    archive?: BoolFieldUpdateOperationsInput | boolean
    collection_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    draft?: BoolFieldUpdateOperationsInput | boolean
    slug?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comments_enabled?: BoolFieldUpdateOperationsInput | boolean
    organization_id?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    content_category?: ContentUpdatecontent_categoryInput | string[]
    Comment?: CommentUncheckedUpdateManyWithoutContentNestedInput
    ContentTemplateInstance?: ContentTemplateInstanceUncheckedUpdateManyWithoutContentNestedInput
    Category?: CategoryUncheckedUpdateManyWithoutContentNestedInput
  }

  export type ContentCreateManyInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    blocks: JsonNullValueInput | InputJsonValue
    html: string
    archive?: boolean
    collection_id: number
    description?: string | null
    draft?: boolean
    slug: string
    title?: string | null
    comments_enabled?: boolean
    organization_id?: number | null
    author_id?: number | null
    featured?: boolean
    content_category?: ContentCreatecontent_categoryInput | string[]
  }

  export type ContentUpdateManyMutationInput = {
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: JsonNullValueInput | InputJsonValue
    html?: StringFieldUpdateOperationsInput | string
    archive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    draft?: BoolFieldUpdateOperationsInput | boolean
    slug?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comments_enabled?: BoolFieldUpdateOperationsInput | boolean
    featured?: BoolFieldUpdateOperationsInput | boolean
    content_category?: ContentUpdatecontent_categoryInput | string[]
  }

  export type ContentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: JsonNullValueInput | InputJsonValue
    html?: StringFieldUpdateOperationsInput | string
    archive?: BoolFieldUpdateOperationsInput | boolean
    collection_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    draft?: BoolFieldUpdateOperationsInput | boolean
    slug?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comments_enabled?: BoolFieldUpdateOperationsInput | boolean
    organization_id?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    content_category?: ContentUpdatecontent_categoryInput | string[]
  }

  export type ContentTemplateInstanceCreateInput = {
    Content: ContentCreateNestedOneWithoutContentTemplateInstanceInput
    TemplateInstance: TemplateInstanceCreateNestedOneWithoutContentTemplateInstanceInput
  }

  export type ContentTemplateInstanceUncheckedCreateInput = {
    id?: number
    content_id: number
    template_instance_id: number
  }

  export type ContentTemplateInstanceUpdateInput = {
    Content?: ContentUpdateOneRequiredWithoutContentTemplateInstanceNestedInput
    TemplateInstance?: TemplateInstanceUpdateOneRequiredWithoutContentTemplateInstanceNestedInput
  }

  export type ContentTemplateInstanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content_id?: IntFieldUpdateOperationsInput | number
    template_instance_id?: IntFieldUpdateOperationsInput | number
  }

  export type ContentTemplateInstanceCreateManyInput = {
    id?: number
    content_id: number
    template_instance_id: number
  }

  export type ContentTemplateInstanceUpdateManyMutationInput = {

  }

  export type ContentTemplateInstanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content_id?: IntFieldUpdateOperationsInput | number
    template_instance_id?: IntFieldUpdateOperationsInput | number
  }

  export type FieldCreateInput = {
    name: string
    type: string
    required: boolean
    options?: FieldCreateoptionsInput | string[]
    created_at?: Date | string
    updated_at: Date | string
    Collection?: CollectionCreateNestedOneWithoutFieldInput
    Template?: TemplateCreateNestedOneWithoutFieldInput
  }

  export type FieldUncheckedCreateInput = {
    id?: number
    name: string
    type: string
    required: boolean
    options?: FieldCreateoptionsInput | string[]
    created_at?: Date | string
    updated_at: Date | string
    template_id?: number | null
    collection_id?: number | null
  }

  export type FieldUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    options?: FieldUpdateoptionsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Collection?: CollectionUpdateOneWithoutFieldNestedInput
    Template?: TemplateUpdateOneWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    options?: FieldUpdateoptionsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    template_id?: NullableIntFieldUpdateOperationsInput | number | null
    collection_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FieldCreateManyInput = {
    id?: number
    name: string
    type: string
    required: boolean
    options?: FieldCreateoptionsInput | string[]
    created_at?: Date | string
    updated_at: Date | string
    template_id?: number | null
    collection_id?: number | null
  }

  export type FieldUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    options?: FieldUpdateoptionsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    options?: FieldUpdateoptionsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    template_id?: NullableIntFieldUpdateOperationsInput | number | null
    collection_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ImageGenerationBillingCreateInput = {
    id: string
    completed_at: Date | string
    started_at: Date | string
    created_at: Date | string
    predict_time: number
    model: string
    status: string
    cost: number
    price: number
    Organization: OrganizationCreateNestedOneWithoutImageGenerationBillingInput
  }

  export type ImageGenerationBillingUncheckedCreateInput = {
    id: string
    completed_at: Date | string
    started_at: Date | string
    created_at: Date | string
    predict_time: number
    model: string
    status: string
    cost: number
    price: number
    organization_id: number
  }

  export type ImageGenerationBillingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    predict_time?: FloatFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    Organization?: OrganizationUpdateOneRequiredWithoutImageGenerationBillingNestedInput
  }

  export type ImageGenerationBillingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    predict_time?: FloatFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    organization_id?: IntFieldUpdateOperationsInput | number
  }

  export type ImageGenerationBillingCreateManyInput = {
    id: string
    completed_at: Date | string
    started_at: Date | string
    created_at: Date | string
    predict_time: number
    model: string
    status: string
    cost: number
    price: number
    organization_id: number
  }

  export type ImageGenerationBillingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    predict_time?: FloatFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ImageGenerationBillingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    predict_time?: FloatFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    organization_id?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceCreateInput = {
    amount_paid: number
    currency: string
    paid_at: Date | string
    pdf: string
    url: string
    id: string
    Organization: OrganizationCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    organization_id: number
    amount_paid: number
    currency: string
    paid_at: Date | string
    pdf: string
    url: string
    id: string
  }

  export type InvoiceUpdateInput = {
    amount_paid?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paid_at?: DateTimeFieldUpdateOperationsInput | Date | string
    pdf?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    Organization?: OrganizationUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    organization_id?: IntFieldUpdateOperationsInput | number
    amount_paid?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paid_at?: DateTimeFieldUpdateOperationsInput | Date | string
    pdf?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceCreateManyInput = {
    organization_id: number
    amount_paid: number
    currency: string
    paid_at: Date | string
    pdf: string
    url: string
    id: string
  }

  export type InvoiceUpdateManyMutationInput = {
    amount_paid?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paid_at?: DateTimeFieldUpdateOperationsInput | Date | string
    pdf?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    organization_id?: IntFieldUpdateOperationsInput | number
    amount_paid?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paid_at?: DateTimeFieldUpdateOperationsInput | Date | string
    pdf?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type LinkPageCreateInput = {
    created_at?: Date | string
    updated_at: Date | string
    description?: string | null
    title?: string | null
    links?: LinkPageCreatelinksInput | InputJsonValue[]
    Media?: MediaCreateNestedOneWithoutLinkPageInput
    Organization: OrganizationCreateNestedOneWithoutLinkPageInput
  }

  export type LinkPageUncheckedCreateInput = {
    id?: number
    organization_id: number
    created_at?: Date | string
    updated_at: Date | string
    description?: string | null
    media_id?: number | null
    title?: string | null
    links?: LinkPageCreatelinksInput | InputJsonValue[]
  }

  export type LinkPageUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    links?: LinkPageUpdatelinksInput | InputJsonValue[]
    Media?: MediaUpdateOneWithoutLinkPageNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutLinkPageNestedInput
  }

  export type LinkPageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    organization_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    media_id?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    links?: LinkPageUpdatelinksInput | InputJsonValue[]
  }

  export type LinkPageCreateManyInput = {
    id?: number
    organization_id: number
    created_at?: Date | string
    updated_at: Date | string
    description?: string | null
    media_id?: number | null
    title?: string | null
    links?: LinkPageCreatelinksInput | InputJsonValue[]
  }

  export type LinkPageUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    links?: LinkPageUpdatelinksInput | InputJsonValue[]
  }

  export type LinkPageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    organization_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    media_id?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    links?: LinkPageUpdatelinksInput | InputJsonValue[]
  }

  export type MediaCreateInput = {
    url: string
    alt_text?: string
    name?: string
    created_at?: Date | string
    updated_at: Date | string
    LinkPage?: LinkPageCreateNestedManyWithoutMediaInput
    Organization: OrganizationCreateNestedOneWithoutMediaInput
    Users?: UsersCreateNestedManyWithoutMediaInput
    author?: authorCreateNestedManyWithoutMediaInput
    org_details?: org_detailsCreateNestedOneWithoutMediaInput
    struct?: structCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateInput = {
    id?: number
    url: string
    alt_text?: string
    name?: string
    created_at?: Date | string
    organization_id: number
    updated_at: Date | string
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutMediaInput
    Users?: UsersUncheckedCreateNestedManyWithoutMediaInput
    author?: authorUncheckedCreateNestedManyWithoutMediaInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutMediaInput
    struct?: structUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    alt_text?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    LinkPage?: LinkPageUpdateManyWithoutMediaNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutMediaNestedInput
    Users?: UsersUpdateManyWithoutMediaNestedInput
    author?: authorUpdateManyWithoutMediaNestedInput
    org_details?: org_detailsUpdateOneWithoutMediaNestedInput
    struct?: structUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    alt_text?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    LinkPage?: LinkPageUncheckedUpdateManyWithoutMediaNestedInput
    Users?: UsersUncheckedUpdateManyWithoutMediaNestedInput
    author?: authorUncheckedUpdateManyWithoutMediaNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutMediaNestedInput
    struct?: structUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaCreateManyInput = {
    id?: number
    url: string
    alt_text?: string
    name?: string
    created_at?: Date | string
    organization_id: number
    updated_at: Date | string
  }

  export type MediaUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    alt_text?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    alt_text?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessagesCreateInput = {
    created_at?: Date | string
    updated_at: Date | string
    message: string
    first_name: string
    email: string
    phone_number?: string | null
    last_name?: string | null
    other_fields?: NullableJsonNullValueInput | InputJsonValue
    viewed?: boolean
    archived?: boolean
    Organization: OrganizationCreateNestedOneWithoutMessagesInput
  }

  export type MessagesUncheckedCreateInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    message: string
    first_name: string
    email: string
    phone_number?: string | null
    last_name?: string | null
    other_fields?: NullableJsonNullValueInput | InputJsonValue
    organization_id: number
    viewed?: boolean
    archived?: boolean
  }

  export type MessagesUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    other_fields?: NullableJsonNullValueInput | InputJsonValue
    viewed?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    Organization?: OrganizationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    other_fields?: NullableJsonNullValueInput | InputJsonValue
    organization_id?: IntFieldUpdateOperationsInput | number
    viewed?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessagesCreateManyInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    message: string
    first_name: string
    email: string
    phone_number?: string | null
    last_name?: string | null
    other_fields?: NullableJsonNullValueInput | InputJsonValue
    organization_id: number
    viewed?: boolean
    archived?: boolean
  }

  export type MessagesUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    other_fields?: NullableJsonNullValueInput | InputJsonValue
    viewed?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    other_fields?: NullableJsonNullValueInput | InputJsonValue
    organization_id?: IntFieldUpdateOperationsInput | number
    viewed?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrganizationCreateInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
  }

  export type OrganizationUpdateManyMutationInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PageCreateInput = {
    title: string
    slug: string
    created_at?: Date | string
    updated_at: Date | string
    published?: boolean
    archive?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    Organization: OrganizationCreateNestedOneWithoutPageInput
  }

  export type PageUncheckedCreateInput = {
    id?: number
    title: string
    slug: string
    created_at?: Date | string
    updated_at: Date | string
    published?: boolean
    archive?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    organization_id: number
  }

  export type PageUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    archive?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    Organization?: OrganizationUpdateOneRequiredWithoutPageNestedInput
  }

  export type PageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    archive?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    organization_id?: IntFieldUpdateOperationsInput | number
  }

  export type PageCreateManyInput = {
    id?: number
    title: string
    slug: string
    created_at?: Date | string
    updated_at: Date | string
    published?: boolean
    archive?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    organization_id: number
  }

  export type PageUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    archive?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    archive?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    organization_id?: IntFieldUpdateOperationsInput | number
  }

  export type RunCreateInput = {
    id: string
    created_at: Date | string
    assistant_id: string
    status: string
    started_at: Date | string
    expires_at?: Date | string | null
    cancelled_at?: Date | string | null
    failed_at?: Date | string | null
    completed_at?: Date | string | null
    last_error?: string | null
    model: string
    instructions?: string | null
    Thread: ThreadCreateNestedOneWithoutRunInput
    ThreadMessage?: ThreadMessageCreateNestedManyWithoutRunInput
    Usage?: UsageCreateNestedOneWithoutRunInput
  }

  export type RunUncheckedCreateInput = {
    id: string
    created_at: Date | string
    assistant_id: string
    thread_id: string
    status: string
    started_at: Date | string
    expires_at?: Date | string | null
    cancelled_at?: Date | string | null
    failed_at?: Date | string | null
    completed_at?: Date | string | null
    last_error?: string | null
    model: string
    instructions?: string | null
    ThreadMessage?: ThreadMessageUncheckedCreateNestedManyWithoutRunInput
    Usage?: UsageUncheckedCreateNestedOneWithoutRunInput
  }

  export type RunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assistant_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_error?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    Thread?: ThreadUpdateOneRequiredWithoutRunNestedInput
    ThreadMessage?: ThreadMessageUpdateManyWithoutRunNestedInput
    Usage?: UsageUpdateOneWithoutRunNestedInput
  }

  export type RunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assistant_id?: StringFieldUpdateOperationsInput | string
    thread_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_error?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    ThreadMessage?: ThreadMessageUncheckedUpdateManyWithoutRunNestedInput
    Usage?: UsageUncheckedUpdateOneWithoutRunNestedInput
  }

  export type RunCreateManyInput = {
    id: string
    created_at: Date | string
    assistant_id: string
    thread_id: string
    status: string
    started_at: Date | string
    expires_at?: Date | string | null
    cancelled_at?: Date | string | null
    failed_at?: Date | string | null
    completed_at?: Date | string | null
    last_error?: string | null
    model: string
    instructions?: string | null
  }

  export type RunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assistant_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_error?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assistant_id?: StringFieldUpdateOperationsInput | string
    thread_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_error?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionCreateInput = {
    stripe_subscription_id: string
    Organization: OrganizationCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: number
    organization_id: number
    stripe_subscription_id: string
  }

  export type SubscriptionUpdateInput = {
    stripe_subscription_id?: StringFieldUpdateOperationsInput | string
    Organization?: OrganizationUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    organization_id?: IntFieldUpdateOperationsInput | number
    stripe_subscription_id?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionCreateManyInput = {
    id?: number
    organization_id: number
    stripe_subscription_id: string
  }

  export type SubscriptionUpdateManyMutationInput = {
    stripe_subscription_id?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    organization_id?: IntFieldUpdateOperationsInput | number
    stripe_subscription_id?: StringFieldUpdateOperationsInput | string
  }

  export type TemplateCreateInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    Field?: FieldCreateNestedManyWithoutTemplateInput
    Collection: CollectionCreateNestedOneWithoutTemplateInput
    TemplateInstance?: TemplateInstanceCreateNestedManyWithoutTemplateInput
  }

  export type TemplateUncheckedCreateInput = {
    id?: number
    name: string
    collection_id: number
    created_at?: Date | string
    updated_at: Date | string
    Field?: FieldUncheckedCreateNestedManyWithoutTemplateInput
    TemplateInstance?: TemplateInstanceUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type TemplateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Field?: FieldUpdateManyWithoutTemplateNestedInput
    Collection?: CollectionUpdateOneRequiredWithoutTemplateNestedInput
    TemplateInstance?: TemplateInstanceUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    collection_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Field?: FieldUncheckedUpdateManyWithoutTemplateNestedInput
    TemplateInstance?: TemplateInstanceUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateCreateManyInput = {
    id?: number
    name: string
    collection_id: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type TemplateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    collection_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateInstanceCreateInput = {
    values: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    title: string
    ContentTemplateInstance?: ContentTemplateInstanceCreateNestedManyWithoutTemplateInstanceInput
    Template: TemplateCreateNestedOneWithoutTemplateInstanceInput
  }

  export type TemplateInstanceUncheckedCreateInput = {
    id?: number
    values: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    title: string
    templateId: number
    ContentTemplateInstance?: ContentTemplateInstanceUncheckedCreateNestedManyWithoutTemplateInstanceInput
  }

  export type TemplateInstanceUpdateInput = {
    values?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    ContentTemplateInstance?: ContentTemplateInstanceUpdateManyWithoutTemplateInstanceNestedInput
    Template?: TemplateUpdateOneRequiredWithoutTemplateInstanceNestedInput
  }

  export type TemplateInstanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    templateId?: IntFieldUpdateOperationsInput | number
    ContentTemplateInstance?: ContentTemplateInstanceUncheckedUpdateManyWithoutTemplateInstanceNestedInput
  }

  export type TemplateInstanceCreateManyInput = {
    id?: number
    values: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    title: string
    templateId: number
  }

  export type TemplateInstanceUpdateManyMutationInput = {
    values?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type TemplateInstanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    templateId?: IntFieldUpdateOperationsInput | number
  }

  export type ThreadCreateInput = {
    thread_id: string
    title?: string
    created_at?: Date | string
    updated_at: Date | string
    should_hide_thread?: boolean
    Run?: RunCreateNestedManyWithoutThreadInput
    Organization: OrganizationCreateNestedOneWithoutThreadInput
    ThreadMessage?: ThreadMessageCreateNestedManyWithoutThreadInput
  }

  export type ThreadUncheckedCreateInput = {
    thread_id: string
    title?: string
    created_at?: Date | string
    updated_at: Date | string
    organization_id: number
    should_hide_thread?: boolean
    Run?: RunUncheckedCreateNestedManyWithoutThreadInput
    ThreadMessage?: ThreadMessageUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ThreadUpdateInput = {
    thread_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    should_hide_thread?: BoolFieldUpdateOperationsInput | boolean
    Run?: RunUpdateManyWithoutThreadNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutThreadNestedInput
    ThreadMessage?: ThreadMessageUpdateManyWithoutThreadNestedInput
  }

  export type ThreadUncheckedUpdateInput = {
    thread_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization_id?: IntFieldUpdateOperationsInput | number
    should_hide_thread?: BoolFieldUpdateOperationsInput | boolean
    Run?: RunUncheckedUpdateManyWithoutThreadNestedInput
    ThreadMessage?: ThreadMessageUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type ThreadCreateManyInput = {
    thread_id: string
    title?: string
    created_at?: Date | string
    updated_at: Date | string
    organization_id: number
    should_hide_thread?: boolean
  }

  export type ThreadUpdateManyMutationInput = {
    thread_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    should_hide_thread?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ThreadUncheckedUpdateManyInput = {
    thread_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization_id?: IntFieldUpdateOperationsInput | number
    should_hide_thread?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ThreadMessageCreateInput = {
    id: string
    created_at: Date | string
    role: string
    content: string
    assistant_id?: string | null
    Run?: RunCreateNestedOneWithoutThreadMessageInput
    Thread: ThreadCreateNestedOneWithoutThreadMessageInput
  }

  export type ThreadMessageUncheckedCreateInput = {
    id: string
    created_at: Date | string
    thread_id: string
    role: string
    content: string
    assistant_id?: string | null
    run_id?: string | null
  }

  export type ThreadMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    assistant_id?: NullableStringFieldUpdateOperationsInput | string | null
    Run?: RunUpdateOneWithoutThreadMessageNestedInput
    Thread?: ThreadUpdateOneRequiredWithoutThreadMessageNestedInput
  }

  export type ThreadMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    thread_id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    assistant_id?: NullableStringFieldUpdateOperationsInput | string | null
    run_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ThreadMessageCreateManyInput = {
    id: string
    created_at: Date | string
    thread_id: string
    role: string
    content: string
    assistant_id?: string | null
    run_id?: string | null
  }

  export type ThreadMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    assistant_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ThreadMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    thread_id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    assistant_id?: NullableStringFieldUpdateOperationsInput | string | null
    run_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsageCreateInput = {
    prompt_tokens: number
    completion_tokens: number
    total_tokens: number
    created_at?: Date | string
    Organization?: OrganizationCreateNestedOneWithoutUsageInput
    Run: RunCreateNestedOneWithoutUsageInput
  }

  export type UsageUncheckedCreateInput = {
    run_id: string
    prompt_tokens: number
    completion_tokens: number
    total_tokens: number
    organization_id?: number | null
    created_at?: Date | string
  }

  export type UsageUpdateInput = {
    prompt_tokens?: IntFieldUpdateOperationsInput | number
    completion_tokens?: IntFieldUpdateOperationsInput | number
    total_tokens?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Organization?: OrganizationUpdateOneWithoutUsageNestedInput
    Run?: RunUpdateOneRequiredWithoutUsageNestedInput
  }

  export type UsageUncheckedUpdateInput = {
    run_id?: StringFieldUpdateOperationsInput | string
    prompt_tokens?: IntFieldUpdateOperationsInput | number
    completion_tokens?: IntFieldUpdateOperationsInput | number
    total_tokens?: IntFieldUpdateOperationsInput | number
    organization_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageCreateManyInput = {
    run_id: string
    prompt_tokens: number
    completion_tokens: number
    total_tokens: number
    organization_id?: number | null
    created_at?: Date | string
  }

  export type UsageUpdateManyMutationInput = {
    prompt_tokens?: IntFieldUpdateOperationsInput | number
    completion_tokens?: IntFieldUpdateOperationsInput | number
    total_tokens?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageUncheckedUpdateManyInput = {
    run_id?: StringFieldUpdateOperationsInput | string
    prompt_tokens?: IntFieldUpdateOperationsInput | number
    completion_tokens?: IntFieldUpdateOperationsInput | number
    total_tokens?: IntFieldUpdateOperationsInput | number
    organization_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOrganizationCreateInput = {
    role?: string
    created_at?: Date | string
    Organization: OrganizationCreateNestedOneWithoutUserOrganizationInput
    Users: UsersCreateNestedOneWithoutUserOrganizationInput
  }

  export type UserOrganizationUncheckedCreateInput = {
    user_id: number
    organization_id: number
    role?: string
    created_at?: Date | string
  }

  export type UserOrganizationUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Organization?: OrganizationUpdateOneRequiredWithoutUserOrganizationNestedInput
    Users?: UsersUpdateOneRequiredWithoutUserOrganizationNestedInput
  }

  export type UserOrganizationUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    organization_id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOrganizationCreateManyInput = {
    user_id: number
    organization_id: number
    role?: string
    created_at?: Date | string
  }

  export type UserOrganizationUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOrganizationUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    organization_id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersCreateInput = {
    email: string
    username: string
    password: string
    security_pin?: string | null
    created_at?: Date | string
    updated_at: Date | string
    role?: string
    UserOrganization?: UserOrganizationCreateNestedManyWithoutUsersInput
    Media?: MediaCreateNestedOneWithoutUsersInput
    Organization: OrganizationCreateNestedOneWithoutUsersInput
  }

  export type UsersUncheckedCreateInput = {
    id?: number
    email: string
    username: string
    password: string
    security_pin?: string | null
    created_at?: Date | string
    organization_id: number
    updated_at: Date | string
    role?: string
    media_id?: number | null
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    security_pin?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    UserOrganization?: UserOrganizationUpdateManyWithoutUsersNestedInput
    Media?: MediaUpdateOneWithoutUsersNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    security_pin?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    media_id?: NullableIntFieldUpdateOperationsInput | number | null
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateManyInput = {
    id?: number
    email: string
    username: string
    password: string
    security_pin?: string | null
    created_at?: Date | string
    organization_id: number
    updated_at: Date | string
    role?: string
    media_id?: number | null
  }

  export type UsersUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    security_pin?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    security_pin?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    media_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type authorCreateInput = {
    created_at?: Date | string
    updated_at: Date | string
    name: string
    description: string
    slug: string
    Content?: ContentCreateNestedManyWithoutAuthorInput
    Media: MediaCreateNestedOneWithoutAuthorInput
    Organization: OrganizationCreateNestedOneWithoutAuthorInput
  }

  export type authorUncheckedCreateInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    name: string
    description: string
    organization_id: number
    media_id: number
    slug: string
    Content?: ContentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type authorUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    Content?: ContentUpdateManyWithoutAuthorNestedInput
    Media?: MediaUpdateOneRequiredWithoutAuthorNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutAuthorNestedInput
  }

  export type authorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    media_id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    Content?: ContentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type authorCreateManyInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    name: string
    description: string
    organization_id: number
    media_id: number
    slug: string
  }

  export type authorUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type authorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    media_id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type form_fieldCreateInput = {
    name: string
    required?: boolean
    created_at?: Date | string
    updated_at: Date | string
    type: $Enums.field_type
    default_value?: string | null
    help?: string | null
    order?: number
    description?: string | null
    label: string
    placeholder?: string | null
    regex?: string | null
    options?: form_fieldCreateoptionsInput | InputJsonValue[]
    Collection?: CollectionCreateNestedOneWithoutForm_fieldInput
    Organization: OrganizationCreateNestedOneWithoutForm_fieldInput
    struct?: structCreateNestedOneWithoutForm_fieldInput
  }

  export type form_fieldUncheckedCreateInput = {
    id?: number
    name: string
    required?: boolean
    created_at?: Date | string
    updated_at: Date | string
    type: $Enums.field_type
    default_value?: string | null
    help?: string | null
    order?: number
    description?: string | null
    label: string
    placeholder?: string | null
    regex?: string | null
    organization_id: number
    collection_id?: number | null
    options?: form_fieldCreateoptionsInput | InputJsonValue[]
    struct_id?: number | null
  }

  export type form_fieldUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfield_typeFieldUpdateOperationsInput | $Enums.field_type
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    help?: NullableStringFieldUpdateOperationsInput | string | null
    order?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    regex?: NullableStringFieldUpdateOperationsInput | string | null
    options?: form_fieldUpdateoptionsInput | InputJsonValue[]
    Collection?: CollectionUpdateOneWithoutForm_fieldNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutForm_fieldNestedInput
    struct?: structUpdateOneWithoutForm_fieldNestedInput
  }

  export type form_fieldUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfield_typeFieldUpdateOperationsInput | $Enums.field_type
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    help?: NullableStringFieldUpdateOperationsInput | string | null
    order?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    regex?: NullableStringFieldUpdateOperationsInput | string | null
    organization_id?: IntFieldUpdateOperationsInput | number
    collection_id?: NullableIntFieldUpdateOperationsInput | number | null
    options?: form_fieldUpdateoptionsInput | InputJsonValue[]
    struct_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type form_fieldCreateManyInput = {
    id?: number
    name: string
    required?: boolean
    created_at?: Date | string
    updated_at: Date | string
    type: $Enums.field_type
    default_value?: string | null
    help?: string | null
    order?: number
    description?: string | null
    label: string
    placeholder?: string | null
    regex?: string | null
    organization_id: number
    collection_id?: number | null
    options?: form_fieldCreateoptionsInput | InputJsonValue[]
    struct_id?: number | null
  }

  export type form_fieldUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfield_typeFieldUpdateOperationsInput | $Enums.field_type
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    help?: NullableStringFieldUpdateOperationsInput | string | null
    order?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    regex?: NullableStringFieldUpdateOperationsInput | string | null
    options?: form_fieldUpdateoptionsInput | InputJsonValue[]
  }

  export type form_fieldUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfield_typeFieldUpdateOperationsInput | $Enums.field_type
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    help?: NullableStringFieldUpdateOperationsInput | string | null
    order?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    regex?: NullableStringFieldUpdateOperationsInput | string | null
    organization_id?: IntFieldUpdateOperationsInput | number
    collection_id?: NullableIntFieldUpdateOperationsInput | number | null
    options?: form_fieldUpdateoptionsInput | InputJsonValue[]
    struct_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type org_detailsCreateInput = {
    gtag?: string | null
    url?: string | null
    company_name?: string | null
    phone?: string | null
    email?: string | null
    street_address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    socials?: org_detailsCreatesocialsInput | string[]
    company_description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    Media?: MediaCreateNestedOneWithoutOrg_detailsInput
    Organization: OrganizationCreateNestedOneWithoutOrg_detailsInput
  }

  export type org_detailsUncheckedCreateInput = {
    gtag?: string | null
    url?: string | null
    company_name?: string | null
    phone?: string | null
    email?: string | null
    street_address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    socials?: org_detailsCreatesocialsInput | string[]
    company_description?: string | null
    created_at?: Date | string
    id?: number
    media_id?: number | null
    organization_id: number
    updated_at: Date | string
  }

  export type org_detailsUpdateInput = {
    gtag?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: org_detailsUpdatesocialsInput | string[]
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Media?: MediaUpdateOneWithoutOrg_detailsNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutOrg_detailsNestedInput
  }

  export type org_detailsUncheckedUpdateInput = {
    gtag?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: org_detailsUpdatesocialsInput | string[]
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    media_id?: NullableIntFieldUpdateOperationsInput | number | null
    organization_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type org_detailsCreateManyInput = {
    gtag?: string | null
    url?: string | null
    company_name?: string | null
    phone?: string | null
    email?: string | null
    street_address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    socials?: org_detailsCreatesocialsInput | string[]
    company_description?: string | null
    created_at?: Date | string
    id?: number
    media_id?: number | null
    organization_id: number
    updated_at: Date | string
  }

  export type org_detailsUpdateManyMutationInput = {
    gtag?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: org_detailsUpdatesocialsInput | string[]
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type org_detailsUncheckedUpdateManyInput = {
    gtag?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: org_detailsUpdatesocialsInput | string[]
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    media_id?: NullableIntFieldUpdateOperationsInput | number | null
    organization_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type structCreateInput = {
    created_at?: Date | string
    updated_at: Date | string
    name: string
    group: string
    cms?: boolean
    description?: string | null
    form_field?: form_fieldCreateNestedManyWithoutStructInput
    Media?: MediaCreateNestedOneWithoutStructInput
    Organization: OrganizationCreateNestedOneWithoutStructInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutStructInput
  }

  export type structUncheckedCreateInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    name: string
    group: string
    organization_id: number
    cms?: boolean
    description?: string | null
    media_id?: number | null
    form_field?: form_fieldUncheckedCreateNestedManyWithoutStructInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutStructInput
  }

  export type structUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    cms?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    form_field?: form_fieldUpdateManyWithoutStructNestedInput
    Media?: MediaUpdateOneWithoutStructNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutStructNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutStructNestedInput
  }

  export type structUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    cms?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    media_id?: NullableIntFieldUpdateOperationsInput | number | null
    form_field?: form_fieldUncheckedUpdateManyWithoutStructNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutStructNestedInput
  }

  export type structCreateManyInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    name: string
    group: string
    organization_id: number
    cms?: boolean
    description?: string | null
    media_id?: number | null
  }

  export type structUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    cms?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type structUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    cms?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    media_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type struct_setCreateInput = {
    name: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
    icon: string
    pinned?: boolean
    Organization: OrganizationCreateNestedOneWithoutStruct_setInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutStruct_setInput
  }

  export type struct_setUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
    organization_id: number
    icon: string
    pinned?: boolean
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutStruct_setInput
  }

  export type struct_setUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    Organization?: OrganizationUpdateOneRequiredWithoutStruct_setNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutStruct_setNestedInput
  }

  export type struct_setUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization_id?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutStruct_setNestedInput
  }

  export type struct_setCreateManyInput = {
    id?: number
    name: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
    organization_id: number
    icon: string
    pinned?: boolean
  }

  export type struct_setUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type struct_setUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization_id?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type struct_set_instanceCreateInput = {
    created_at?: Date | string
    updated_at: Date | string
    instance_data: JsonNullValueInput | InputJsonValue
    key: string
    Organization: OrganizationCreateNestedOneWithoutStruct_set_instanceInput
    struct: structCreateNestedOneWithoutStruct_set_instanceInput
    struct_set: struct_setCreateNestedOneWithoutStruct_set_instanceInput
  }

  export type struct_set_instanceUncheckedCreateInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    instance_data: JsonNullValueInput | InputJsonValue
    organization_id: number
    struct_set_id: number
    struct_id: number
    key: string
  }

  export type struct_set_instanceUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_data?: JsonNullValueInput | InputJsonValue
    key?: StringFieldUpdateOperationsInput | string
    Organization?: OrganizationUpdateOneRequiredWithoutStruct_set_instanceNestedInput
    struct?: structUpdateOneRequiredWithoutStruct_set_instanceNestedInput
    struct_set?: struct_setUpdateOneRequiredWithoutStruct_set_instanceNestedInput
  }

  export type struct_set_instanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_data?: JsonNullValueInput | InputJsonValue
    organization_id?: IntFieldUpdateOperationsInput | number
    struct_set_id?: IntFieldUpdateOperationsInput | number
    struct_id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
  }

  export type struct_set_instanceCreateManyInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    instance_data: JsonNullValueInput | InputJsonValue
    organization_id: number
    struct_set_id: number
    struct_id: number
    key: string
  }

  export type struct_set_instanceUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_data?: JsonNullValueInput | InputJsonValue
    key?: StringFieldUpdateOperationsInput | string
  }

  export type struct_set_instanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_data?: JsonNullValueInput | InputJsonValue
    organization_id?: IntFieldUpdateOperationsInput | number
    struct_set_id?: IntFieldUpdateOperationsInput | number
    struct_id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CollectionScalarRelationFilter = {
    is?: CollectionWhereInput
    isNot?: CollectionWhereInput
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type ContentListRelationFilter = {
    every?: ContentWhereInput
    some?: ContentWhereInput
    none?: ContentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategorySlugOrganization_idCompoundUniqueInput = {
    slug: string
    organization_id: number
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organization_id?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parent_id?: SortOrder
    collection_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    short_name?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    parent_id?: SortOrder
    collection_id?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organization_id?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parent_id?: SortOrder
    collection_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    short_name?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organization_id?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parent_id?: SortOrder
    collection_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    short_name?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    parent_id?: SortOrder
    collection_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FieldListRelationFilter = {
    every?: FieldWhereInput
    some?: FieldWhereInput
    none?: FieldWhereInput
  }

  export type TemplateListRelationFilter = {
    every?: TemplateWhereInput
    some?: TemplateWhereInput
    none?: TemplateWhereInput
  }

  export type Form_fieldListRelationFilter = {
    every?: form_fieldWhereInput
    some?: form_fieldWhereInput
    none?: form_fieldWhereInput
  }

  export type FieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type form_fieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollectionNameOrganization_idCompoundUniqueInput = {
    name: string
    organization_id: number
  }

  export type CollectionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organization_id?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    icon?: SortOrder
    page_content?: SortOrder
    enable_author?: SortOrder
    enable_comments?: SortOrder
    enable_featured_posts?: SortOrder
    enable_rating?: SortOrder
    path_prefix?: SortOrder
    title?: SortOrder
  }

  export type CollectionAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
  }

  export type CollectionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organization_id?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    icon?: SortOrder
    page_content?: SortOrder
    enable_author?: SortOrder
    enable_comments?: SortOrder
    enable_featured_posts?: SortOrder
    enable_rating?: SortOrder
    path_prefix?: SortOrder
    title?: SortOrder
  }

  export type CollectionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organization_id?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    icon?: SortOrder
    page_content?: SortOrder
    enable_author?: SortOrder
    enable_comments?: SortOrder
    enable_featured_posts?: SortOrder
    enable_rating?: SortOrder
    path_prefix?: SortOrder
    title?: SortOrder
  }

  export type CollectionSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ContentScalarRelationFilter = {
    is?: ContentWhereInput
    isNot?: ContentWhereInput
  }

  export type CommentNullableScalarRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    author?: SortOrder
    content_id?: SortOrder
    parent_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    approved?: SortOrder
    organization_id?: SortOrder
    email?: SortOrder
    image_url?: SortOrder
    rating?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    content_id?: SortOrder
    parent_id?: SortOrder
    organization_id?: SortOrder
    rating?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    author?: SortOrder
    content_id?: SortOrder
    parent_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    approved?: SortOrder
    organization_id?: SortOrder
    email?: SortOrder
    image_url?: SortOrder
    rating?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    author?: SortOrder
    content_id?: SortOrder
    parent_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    approved?: SortOrder
    organization_id?: SortOrder
    email?: SortOrder
    image_url?: SortOrder
    rating?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    content_id?: SortOrder
    parent_id?: SortOrder
    organization_id?: SortOrder
    rating?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type CompletionUsageCountOrderByAggregateInput = {
    created_at?: SortOrder
    prompt_tokens?: SortOrder
    completion_tokens?: SortOrder
    total_tokens?: SortOrder
    prompt_tokens_cost?: SortOrder
    completion_tokens_cost?: SortOrder
    total_tokens_cost?: SortOrder
    prompt_tokens_price?: SortOrder
    completion_tokens_price?: SortOrder
    total_tokens_price?: SortOrder
    id?: SortOrder
    organization_id?: SortOrder
  }

  export type CompletionUsageAvgOrderByAggregateInput = {
    prompt_tokens?: SortOrder
    completion_tokens?: SortOrder
    total_tokens?: SortOrder
    prompt_tokens_cost?: SortOrder
    completion_tokens_cost?: SortOrder
    total_tokens_cost?: SortOrder
    prompt_tokens_price?: SortOrder
    completion_tokens_price?: SortOrder
    total_tokens_price?: SortOrder
    id?: SortOrder
    organization_id?: SortOrder
  }

  export type CompletionUsageMaxOrderByAggregateInput = {
    created_at?: SortOrder
    prompt_tokens?: SortOrder
    completion_tokens?: SortOrder
    total_tokens?: SortOrder
    prompt_tokens_cost?: SortOrder
    completion_tokens_cost?: SortOrder
    total_tokens_cost?: SortOrder
    prompt_tokens_price?: SortOrder
    completion_tokens_price?: SortOrder
    total_tokens_price?: SortOrder
    id?: SortOrder
    organization_id?: SortOrder
  }

  export type CompletionUsageMinOrderByAggregateInput = {
    created_at?: SortOrder
    prompt_tokens?: SortOrder
    completion_tokens?: SortOrder
    total_tokens?: SortOrder
    prompt_tokens_cost?: SortOrder
    completion_tokens_cost?: SortOrder
    total_tokens_cost?: SortOrder
    prompt_tokens_price?: SortOrder
    completion_tokens_price?: SortOrder
    total_tokens_price?: SortOrder
    id?: SortOrder
    organization_id?: SortOrder
  }

  export type CompletionUsageSumOrderByAggregateInput = {
    prompt_tokens?: SortOrder
    completion_tokens?: SortOrder
    total_tokens?: SortOrder
    prompt_tokens_cost?: SortOrder
    completion_tokens_cost?: SortOrder
    total_tokens_cost?: SortOrder
    prompt_tokens_price?: SortOrder
    completion_tokens_price?: SortOrder
    total_tokens_price?: SortOrder
    id?: SortOrder
    organization_id?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AuthorNullableScalarRelationFilter = {
    is?: authorWhereInput | null
    isNot?: authorWhereInput | null
  }

  export type OrganizationNullableScalarRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type ContentTemplateInstanceListRelationFilter = {
    every?: ContentTemplateInstanceWhereInput
    some?: ContentTemplateInstanceWhereInput
    none?: ContentTemplateInstanceWhereInput
  }

  export type ContentTemplateInstanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentSlugOrganization_idCompoundUniqueInput = {
    slug: string
    organization_id: number
  }

  export type ContentCountOrderByAggregateInput = {
    id?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    blocks?: SortOrder
    html?: SortOrder
    archive?: SortOrder
    collection_id?: SortOrder
    description?: SortOrder
    draft?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    comments_enabled?: SortOrder
    organization_id?: SortOrder
    author_id?: SortOrder
    featured?: SortOrder
    content_category?: SortOrder
  }

  export type ContentAvgOrderByAggregateInput = {
    id?: SortOrder
    collection_id?: SortOrder
    organization_id?: SortOrder
    author_id?: SortOrder
  }

  export type ContentMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    html?: SortOrder
    archive?: SortOrder
    collection_id?: SortOrder
    description?: SortOrder
    draft?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    comments_enabled?: SortOrder
    organization_id?: SortOrder
    author_id?: SortOrder
    featured?: SortOrder
  }

  export type ContentMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    html?: SortOrder
    archive?: SortOrder
    collection_id?: SortOrder
    description?: SortOrder
    draft?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    comments_enabled?: SortOrder
    organization_id?: SortOrder
    author_id?: SortOrder
    featured?: SortOrder
  }

  export type ContentSumOrderByAggregateInput = {
    id?: SortOrder
    collection_id?: SortOrder
    organization_id?: SortOrder
    author_id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type TemplateInstanceScalarRelationFilter = {
    is?: TemplateInstanceWhereInput
    isNot?: TemplateInstanceWhereInput
  }

  export type ContentTemplateInstanceCountOrderByAggregateInput = {
    id?: SortOrder
    content_id?: SortOrder
    template_instance_id?: SortOrder
  }

  export type ContentTemplateInstanceAvgOrderByAggregateInput = {
    id?: SortOrder
    content_id?: SortOrder
    template_instance_id?: SortOrder
  }

  export type ContentTemplateInstanceMaxOrderByAggregateInput = {
    id?: SortOrder
    content_id?: SortOrder
    template_instance_id?: SortOrder
  }

  export type ContentTemplateInstanceMinOrderByAggregateInput = {
    id?: SortOrder
    content_id?: SortOrder
    template_instance_id?: SortOrder
  }

  export type ContentTemplateInstanceSumOrderByAggregateInput = {
    id?: SortOrder
    content_id?: SortOrder
    template_instance_id?: SortOrder
  }

  export type CollectionNullableScalarRelationFilter = {
    is?: CollectionWhereInput | null
    isNot?: CollectionWhereInput | null
  }

  export type TemplateNullableScalarRelationFilter = {
    is?: TemplateWhereInput | null
    isNot?: TemplateWhereInput | null
  }

  export type FieldNameCollection_idCompoundUniqueInput = {
    name: string
    collection_id: number
  }

  export type FieldNameTemplate_idCompoundUniqueInput = {
    name: string
    template_id: number
  }

  export type FieldCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    required?: SortOrder
    options?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    template_id?: SortOrder
    collection_id?: SortOrder
  }

  export type FieldAvgOrderByAggregateInput = {
    id?: SortOrder
    template_id?: SortOrder
    collection_id?: SortOrder
  }

  export type FieldMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    required?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    template_id?: SortOrder
    collection_id?: SortOrder
  }

  export type FieldMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    required?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    template_id?: SortOrder
    collection_id?: SortOrder
  }

  export type FieldSumOrderByAggregateInput = {
    id?: SortOrder
    template_id?: SortOrder
    collection_id?: SortOrder
  }

  export type ImageGenerationBillingCountOrderByAggregateInput = {
    id?: SortOrder
    completed_at?: SortOrder
    started_at?: SortOrder
    created_at?: SortOrder
    predict_time?: SortOrder
    model?: SortOrder
    status?: SortOrder
    cost?: SortOrder
    price?: SortOrder
    organization_id?: SortOrder
  }

  export type ImageGenerationBillingAvgOrderByAggregateInput = {
    predict_time?: SortOrder
    cost?: SortOrder
    price?: SortOrder
    organization_id?: SortOrder
  }

  export type ImageGenerationBillingMaxOrderByAggregateInput = {
    id?: SortOrder
    completed_at?: SortOrder
    started_at?: SortOrder
    created_at?: SortOrder
    predict_time?: SortOrder
    model?: SortOrder
    status?: SortOrder
    cost?: SortOrder
    price?: SortOrder
    organization_id?: SortOrder
  }

  export type ImageGenerationBillingMinOrderByAggregateInput = {
    id?: SortOrder
    completed_at?: SortOrder
    started_at?: SortOrder
    created_at?: SortOrder
    predict_time?: SortOrder
    model?: SortOrder
    status?: SortOrder
    cost?: SortOrder
    price?: SortOrder
    organization_id?: SortOrder
  }

  export type ImageGenerationBillingSumOrderByAggregateInput = {
    predict_time?: SortOrder
    cost?: SortOrder
    price?: SortOrder
    organization_id?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    organization_id?: SortOrder
    amount_paid?: SortOrder
    currency?: SortOrder
    paid_at?: SortOrder
    pdf?: SortOrder
    url?: SortOrder
    id?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    organization_id?: SortOrder
    amount_paid?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    organization_id?: SortOrder
    amount_paid?: SortOrder
    currency?: SortOrder
    paid_at?: SortOrder
    pdf?: SortOrder
    url?: SortOrder
    id?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    organization_id?: SortOrder
    amount_paid?: SortOrder
    currency?: SortOrder
    paid_at?: SortOrder
    pdf?: SortOrder
    url?: SortOrder
    id?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    organization_id?: SortOrder
    amount_paid?: SortOrder
  }
  export type JsonNullableListFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableListFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableListFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableListFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel> | null
    has?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    hasEvery?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    hasSome?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type MediaNullableScalarRelationFilter = {
    is?: MediaWhereInput | null
    isNot?: MediaWhereInput | null
  }

  export type LinkPageCountOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    description?: SortOrder
    media_id?: SortOrder
    title?: SortOrder
    links?: SortOrder
  }

  export type LinkPageAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    media_id?: SortOrder
  }

  export type LinkPageMaxOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    description?: SortOrder
    media_id?: SortOrder
    title?: SortOrder
  }

  export type LinkPageMinOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    description?: SortOrder
    media_id?: SortOrder
    title?: SortOrder
  }

  export type LinkPageSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    media_id?: SortOrder
  }

  export type LinkPageListRelationFilter = {
    every?: LinkPageWhereInput
    some?: LinkPageWhereInput
    none?: LinkPageWhereInput
  }

  export type UsersListRelationFilter = {
    every?: UsersWhereInput
    some?: UsersWhereInput
    none?: UsersWhereInput
  }

  export type AuthorListRelationFilter = {
    every?: authorWhereInput
    some?: authorWhereInput
    none?: authorWhereInput
  }

  export type Org_detailsNullableScalarRelationFilter = {
    is?: org_detailsWhereInput | null
    isNot?: org_detailsWhereInput | null
  }

  export type StructListRelationFilter = {
    every?: structWhereInput
    some?: structWhereInput
    none?: structWhereInput
  }

  export type LinkPageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type authorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type structOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    alt_text?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    organization_id?: SortOrder
    updated_at?: SortOrder
  }

  export type MediaAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    alt_text?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    organization_id?: SortOrder
    updated_at?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    alt_text?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    organization_id?: SortOrder
    updated_at?: SortOrder
  }

  export type MediaSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MessagesCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    message?: SortOrder
    first_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    last_name?: SortOrder
    other_fields?: SortOrder
    organization_id?: SortOrder
    viewed?: SortOrder
    archived?: SortOrder
  }

  export type MessagesAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
  }

  export type MessagesMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    message?: SortOrder
    first_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    last_name?: SortOrder
    organization_id?: SortOrder
    viewed?: SortOrder
    archived?: SortOrder
  }

  export type MessagesMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    message?: SortOrder
    first_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    last_name?: SortOrder
    organization_id?: SortOrder
    viewed?: SortOrder
    archived?: SortOrder
  }

  export type MessagesSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type CollectionListRelationFilter = {
    every?: CollectionWhereInput
    some?: CollectionWhereInput
    none?: CollectionWhereInput
  }

  export type CompletionUsageListRelationFilter = {
    every?: CompletionUsageWhereInput
    some?: CompletionUsageWhereInput
    none?: CompletionUsageWhereInput
  }

  export type ImageGenerationBillingListRelationFilter = {
    every?: ImageGenerationBillingWhereInput
    some?: ImageGenerationBillingWhereInput
    none?: ImageGenerationBillingWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type MediaListRelationFilter = {
    every?: MediaWhereInput
    some?: MediaWhereInput
    none?: MediaWhereInput
  }

  export type MessagesListRelationFilter = {
    every?: MessagesWhereInput
    some?: MessagesWhereInput
    none?: MessagesWhereInput
  }

  export type PageListRelationFilter = {
    every?: PageWhereInput
    some?: PageWhereInput
    none?: PageWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type ThreadListRelationFilter = {
    every?: ThreadWhereInput
    some?: ThreadWhereInput
    none?: ThreadWhereInput
  }

  export type UsageListRelationFilter = {
    every?: UsageWhereInput
    some?: UsageWhereInput
    none?: UsageWhereInput
  }

  export type UserOrganizationListRelationFilter = {
    every?: UserOrganizationWhereInput
    some?: UserOrganizationWhereInput
    none?: UserOrganizationWhereInput
  }

  export type Struct_setListRelationFilter = {
    every?: struct_setWhereInput
    some?: struct_setWhereInput
    none?: struct_setWhereInput
  }

  export type Struct_set_instanceListRelationFilter = {
    every?: struct_set_instanceWhereInput
    some?: struct_set_instanceWhereInput
    none?: struct_set_instanceWhereInput
  }

  export type CollectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompletionUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImageGenerationBillingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ThreadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrganizationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type struct_setOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type struct_set_instanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    company_name?: SortOrder
    address?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    company_description?: SortOrder
    domain?: SortOrder
    logo?: SortOrder
    token?: SortOrder
    stripe_customer_id?: SortOrder
    stripe_price_id?: SortOrder
    stripe_is_subscribed?: SortOrder
    ai_subscription_id?: SortOrder
    notify_by_email?: SortOrder
    notify_by_sms?: SortOrder
    slack_webhook_url?: SortOrder
    city?: SortOrder
    postal_code?: SortOrder
    state?: SortOrder
    street_address?: SortOrder
  }

  export type OrganizationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    company_name?: SortOrder
    address?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    company_description?: SortOrder
    domain?: SortOrder
    logo?: SortOrder
    token?: SortOrder
    stripe_customer_id?: SortOrder
    stripe_price_id?: SortOrder
    stripe_is_subscribed?: SortOrder
    ai_subscription_id?: SortOrder
    notify_by_email?: SortOrder
    notify_by_sms?: SortOrder
    slack_webhook_url?: SortOrder
    city?: SortOrder
    postal_code?: SortOrder
    state?: SortOrder
    street_address?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    company_name?: SortOrder
    address?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    company_description?: SortOrder
    domain?: SortOrder
    logo?: SortOrder
    token?: SortOrder
    stripe_customer_id?: SortOrder
    stripe_price_id?: SortOrder
    stripe_is_subscribed?: SortOrder
    ai_subscription_id?: SortOrder
    notify_by_email?: SortOrder
    notify_by_sms?: SortOrder
    slack_webhook_url?: SortOrder
    city?: SortOrder
    postal_code?: SortOrder
    state?: SortOrder
    street_address?: SortOrder
  }

  export type OrganizationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PageCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    published?: SortOrder
    archive?: SortOrder
    data?: SortOrder
    organization_id?: SortOrder
  }

  export type PageAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
  }

  export type PageMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    published?: SortOrder
    archive?: SortOrder
    organization_id?: SortOrder
  }

  export type PageMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    published?: SortOrder
    archive?: SortOrder
    organization_id?: SortOrder
  }

  export type PageSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ThreadScalarRelationFilter = {
    is?: ThreadWhereInput
    isNot?: ThreadWhereInput
  }

  export type ThreadMessageListRelationFilter = {
    every?: ThreadMessageWhereInput
    some?: ThreadMessageWhereInput
    none?: ThreadMessageWhereInput
  }

  export type UsageNullableScalarRelationFilter = {
    is?: UsageWhereInput | null
    isNot?: UsageWhereInput | null
  }

  export type ThreadMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RunCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    assistant_id?: SortOrder
    thread_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    expires_at?: SortOrder
    cancelled_at?: SortOrder
    failed_at?: SortOrder
    completed_at?: SortOrder
    last_error?: SortOrder
    model?: SortOrder
    instructions?: SortOrder
  }

  export type RunMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    assistant_id?: SortOrder
    thread_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    expires_at?: SortOrder
    cancelled_at?: SortOrder
    failed_at?: SortOrder
    completed_at?: SortOrder
    last_error?: SortOrder
    model?: SortOrder
    instructions?: SortOrder
  }

  export type RunMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    assistant_id?: SortOrder
    thread_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    expires_at?: SortOrder
    cancelled_at?: SortOrder
    failed_at?: SortOrder
    completed_at?: SortOrder
    last_error?: SortOrder
    model?: SortOrder
    instructions?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    stripe_subscription_id?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    stripe_subscription_id?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    stripe_subscription_id?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
  }

  export type TemplateInstanceListRelationFilter = {
    every?: TemplateInstanceWhereInput
    some?: TemplateInstanceWhereInput
    none?: TemplateInstanceWhereInput
  }

  export type TemplateInstanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    collection_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TemplateAvgOrderByAggregateInput = {
    id?: SortOrder
    collection_id?: SortOrder
  }

  export type TemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    collection_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    collection_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TemplateSumOrderByAggregateInput = {
    id?: SortOrder
    collection_id?: SortOrder
  }

  export type TemplateScalarRelationFilter = {
    is?: TemplateWhereInput
    isNot?: TemplateWhereInput
  }

  export type TemplateInstanceCountOrderByAggregateInput = {
    id?: SortOrder
    values?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    title?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateInstanceAvgOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateInstanceMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    title?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateInstanceMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    title?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateInstanceSumOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
  }

  export type RunListRelationFilter = {
    every?: RunWhereInput
    some?: RunWhereInput
    none?: RunWhereInput
  }

  export type RunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ThreadCountOrderByAggregateInput = {
    thread_id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organization_id?: SortOrder
    should_hide_thread?: SortOrder
  }

  export type ThreadAvgOrderByAggregateInput = {
    organization_id?: SortOrder
  }

  export type ThreadMaxOrderByAggregateInput = {
    thread_id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organization_id?: SortOrder
    should_hide_thread?: SortOrder
  }

  export type ThreadMinOrderByAggregateInput = {
    thread_id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organization_id?: SortOrder
    should_hide_thread?: SortOrder
  }

  export type ThreadSumOrderByAggregateInput = {
    organization_id?: SortOrder
  }

  export type RunNullableScalarRelationFilter = {
    is?: RunWhereInput | null
    isNot?: RunWhereInput | null
  }

  export type ThreadMessageCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    thread_id?: SortOrder
    role?: SortOrder
    content?: SortOrder
    assistant_id?: SortOrder
    run_id?: SortOrder
  }

  export type ThreadMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    thread_id?: SortOrder
    role?: SortOrder
    content?: SortOrder
    assistant_id?: SortOrder
    run_id?: SortOrder
  }

  export type ThreadMessageMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    thread_id?: SortOrder
    role?: SortOrder
    content?: SortOrder
    assistant_id?: SortOrder
    run_id?: SortOrder
  }

  export type RunScalarRelationFilter = {
    is?: RunWhereInput
    isNot?: RunWhereInput
  }

  export type UsageCountOrderByAggregateInput = {
    run_id?: SortOrder
    prompt_tokens?: SortOrder
    completion_tokens?: SortOrder
    total_tokens?: SortOrder
    organization_id?: SortOrder
    created_at?: SortOrder
  }

  export type UsageAvgOrderByAggregateInput = {
    prompt_tokens?: SortOrder
    completion_tokens?: SortOrder
    total_tokens?: SortOrder
    organization_id?: SortOrder
  }

  export type UsageMaxOrderByAggregateInput = {
    run_id?: SortOrder
    prompt_tokens?: SortOrder
    completion_tokens?: SortOrder
    total_tokens?: SortOrder
    organization_id?: SortOrder
    created_at?: SortOrder
  }

  export type UsageMinOrderByAggregateInput = {
    run_id?: SortOrder
    prompt_tokens?: SortOrder
    completion_tokens?: SortOrder
    total_tokens?: SortOrder
    organization_id?: SortOrder
    created_at?: SortOrder
  }

  export type UsageSumOrderByAggregateInput = {
    prompt_tokens?: SortOrder
    completion_tokens?: SortOrder
    total_tokens?: SortOrder
    organization_id?: SortOrder
  }

  export type UsersScalarRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type UserOrganizationUser_idOrganization_idCompoundUniqueInput = {
    user_id: number
    organization_id: number
  }

  export type UserOrganizationCountOrderByAggregateInput = {
    user_id?: SortOrder
    organization_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type UserOrganizationAvgOrderByAggregateInput = {
    user_id?: SortOrder
    organization_id?: SortOrder
  }

  export type UserOrganizationMaxOrderByAggregateInput = {
    user_id?: SortOrder
    organization_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type UserOrganizationMinOrderByAggregateInput = {
    user_id?: SortOrder
    organization_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type UserOrganizationSumOrderByAggregateInput = {
    user_id?: SortOrder
    organization_id?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    security_pin?: SortOrder
    created_at?: SortOrder
    organization_id?: SortOrder
    updated_at?: SortOrder
    role?: SortOrder
    media_id?: SortOrder
  }

  export type UsersAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    media_id?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    security_pin?: SortOrder
    created_at?: SortOrder
    organization_id?: SortOrder
    updated_at?: SortOrder
    role?: SortOrder
    media_id?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    security_pin?: SortOrder
    created_at?: SortOrder
    organization_id?: SortOrder
    updated_at?: SortOrder
    role?: SortOrder
    media_id?: SortOrder
  }

  export type UsersSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    media_id?: SortOrder
  }

  export type MediaScalarRelationFilter = {
    is?: MediaWhereInput
    isNot?: MediaWhereInput
  }

  export type authorSlugOrganization_idCompoundUniqueInput = {
    slug: string
    organization_id: number
  }

  export type authorCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
    organization_id?: SortOrder
    media_id?: SortOrder
    slug?: SortOrder
  }

  export type authorAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    media_id?: SortOrder
  }

  export type authorMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
    organization_id?: SortOrder
    media_id?: SortOrder
    slug?: SortOrder
  }

  export type authorMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
    organization_id?: SortOrder
    media_id?: SortOrder
    slug?: SortOrder
  }

  export type authorSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    media_id?: SortOrder
  }

  export type Enumfield_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.field_type | Enumfield_typeFieldRefInput<$PrismaModel>
    in?: $Enums.field_type[] | ListEnumfield_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.field_type[] | ListEnumfield_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumfield_typeFilter<$PrismaModel> | $Enums.field_type
  }

  export type StructNullableScalarRelationFilter = {
    is?: structWhereInput | null
    isNot?: structWhereInput | null
  }

  export type form_fieldNameCollection_idCompoundUniqueInput = {
    name: string
    collection_id: number
  }

  export type form_fieldCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    required?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    type?: SortOrder
    default_value?: SortOrder
    help?: SortOrder
    order?: SortOrder
    description?: SortOrder
    label?: SortOrder
    placeholder?: SortOrder
    regex?: SortOrder
    organization_id?: SortOrder
    collection_id?: SortOrder
    options?: SortOrder
    struct_id?: SortOrder
  }

  export type form_fieldAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    organization_id?: SortOrder
    collection_id?: SortOrder
    struct_id?: SortOrder
  }

  export type form_fieldMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    required?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    type?: SortOrder
    default_value?: SortOrder
    help?: SortOrder
    order?: SortOrder
    description?: SortOrder
    label?: SortOrder
    placeholder?: SortOrder
    regex?: SortOrder
    organization_id?: SortOrder
    collection_id?: SortOrder
    struct_id?: SortOrder
  }

  export type form_fieldMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    required?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    type?: SortOrder
    default_value?: SortOrder
    help?: SortOrder
    order?: SortOrder
    description?: SortOrder
    label?: SortOrder
    placeholder?: SortOrder
    regex?: SortOrder
    organization_id?: SortOrder
    collection_id?: SortOrder
    struct_id?: SortOrder
  }

  export type form_fieldSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    organization_id?: SortOrder
    collection_id?: SortOrder
    struct_id?: SortOrder
  }

  export type Enumfield_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.field_type | Enumfield_typeFieldRefInput<$PrismaModel>
    in?: $Enums.field_type[] | ListEnumfield_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.field_type[] | ListEnumfield_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumfield_typeWithAggregatesFilter<$PrismaModel> | $Enums.field_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfield_typeFilter<$PrismaModel>
    _max?: NestedEnumfield_typeFilter<$PrismaModel>
  }

  export type org_detailsCountOrderByAggregateInput = {
    gtag?: SortOrder
    url?: SortOrder
    company_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    street_address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    socials?: SortOrder
    company_description?: SortOrder
    created_at?: SortOrder
    id?: SortOrder
    media_id?: SortOrder
    organization_id?: SortOrder
    updated_at?: SortOrder
  }

  export type org_detailsAvgOrderByAggregateInput = {
    id?: SortOrder
    media_id?: SortOrder
    organization_id?: SortOrder
  }

  export type org_detailsMaxOrderByAggregateInput = {
    gtag?: SortOrder
    url?: SortOrder
    company_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    street_address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    company_description?: SortOrder
    created_at?: SortOrder
    id?: SortOrder
    media_id?: SortOrder
    organization_id?: SortOrder
    updated_at?: SortOrder
  }

  export type org_detailsMinOrderByAggregateInput = {
    gtag?: SortOrder
    url?: SortOrder
    company_name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    street_address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    company_description?: SortOrder
    created_at?: SortOrder
    id?: SortOrder
    media_id?: SortOrder
    organization_id?: SortOrder
    updated_at?: SortOrder
  }

  export type org_detailsSumOrderByAggregateInput = {
    id?: SortOrder
    media_id?: SortOrder
    organization_id?: SortOrder
  }

  export type structCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    group?: SortOrder
    organization_id?: SortOrder
    cms?: SortOrder
    description?: SortOrder
    media_id?: SortOrder
  }

  export type structAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    media_id?: SortOrder
  }

  export type structMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    group?: SortOrder
    organization_id?: SortOrder
    cms?: SortOrder
    description?: SortOrder
    media_id?: SortOrder
  }

  export type structMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    group?: SortOrder
    organization_id?: SortOrder
    cms?: SortOrder
    description?: SortOrder
    media_id?: SortOrder
  }

  export type structSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    media_id?: SortOrder
  }

  export type struct_setCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organization_id?: SortOrder
    icon?: SortOrder
    pinned?: SortOrder
  }

  export type struct_setAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
  }

  export type struct_setMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organization_id?: SortOrder
    icon?: SortOrder
    pinned?: SortOrder
  }

  export type struct_setMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organization_id?: SortOrder
    icon?: SortOrder
    pinned?: SortOrder
  }

  export type struct_setSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
  }

  export type StructScalarRelationFilter = {
    is?: structWhereInput
    isNot?: structWhereInput
  }

  export type Struct_setScalarRelationFilter = {
    is?: struct_setWhereInput
    isNot?: struct_setWhereInput
  }

  export type struct_set_instanceKeyStruct_set_idCompoundUniqueInput = {
    key: string
    struct_set_id: number
  }

  export type struct_set_instanceCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    instance_data?: SortOrder
    organization_id?: SortOrder
    struct_set_id?: SortOrder
    struct_id?: SortOrder
    key?: SortOrder
  }

  export type struct_set_instanceAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    struct_set_id?: SortOrder
    struct_id?: SortOrder
  }

  export type struct_set_instanceMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organization_id?: SortOrder
    struct_set_id?: SortOrder
    struct_id?: SortOrder
    key?: SortOrder
  }

  export type struct_set_instanceMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organization_id?: SortOrder
    struct_set_id?: SortOrder
    struct_id?: SortOrder
    key?: SortOrder
  }

  export type struct_set_instanceSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    struct_set_id?: SortOrder
    struct_id?: SortOrder
  }

  export type CollectionCreateNestedOneWithoutCategoryInput = {
    create?: XOR<CollectionCreateWithoutCategoryInput, CollectionUncheckedCreateWithoutCategoryInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutCategoryInput
    connect?: CollectionWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutCategoryInput = {
    create?: XOR<OrganizationCreateWithoutCategoryInput, OrganizationUncheckedCreateWithoutCategoryInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCategoryInput
    connect?: OrganizationWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutOther_CategoryInput = {
    create?: XOR<CategoryCreateWithoutOther_CategoryInput, CategoryUncheckedCreateWithoutOther_CategoryInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutOther_CategoryInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CategoryCreateWithoutCategoryInput, CategoryUncheckedCreateWithoutCategoryInput> | CategoryCreateWithoutCategoryInput[] | CategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutCategoryInput | CategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: CategoryCreateManyCategoryInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ContentCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ContentCreateWithoutCategoryInput, ContentUncheckedCreateWithoutCategoryInput> | ContentCreateWithoutCategoryInput[] | ContentUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutCategoryInput | ContentCreateOrConnectWithoutCategoryInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CategoryCreateWithoutCategoryInput, CategoryUncheckedCreateWithoutCategoryInput> | CategoryCreateWithoutCategoryInput[] | CategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutCategoryInput | CategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: CategoryCreateManyCategoryInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ContentUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ContentCreateWithoutCategoryInput, ContentUncheckedCreateWithoutCategoryInput> | ContentCreateWithoutCategoryInput[] | ContentUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutCategoryInput | ContentCreateOrConnectWithoutCategoryInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CollectionUpdateOneRequiredWithoutCategoryNestedInput = {
    create?: XOR<CollectionCreateWithoutCategoryInput, CollectionUncheckedCreateWithoutCategoryInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutCategoryInput
    upsert?: CollectionUpsertWithoutCategoryInput
    connect?: CollectionWhereUniqueInput
    update?: XOR<XOR<CollectionUpdateToOneWithWhereWithoutCategoryInput, CollectionUpdateWithoutCategoryInput>, CollectionUncheckedUpdateWithoutCategoryInput>
  }

  export type OrganizationUpdateOneRequiredWithoutCategoryNestedInput = {
    create?: XOR<OrganizationCreateWithoutCategoryInput, OrganizationUncheckedCreateWithoutCategoryInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCategoryInput
    upsert?: OrganizationUpsertWithoutCategoryInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutCategoryInput, OrganizationUpdateWithoutCategoryInput>, OrganizationUncheckedUpdateWithoutCategoryInput>
  }

  export type CategoryUpdateOneWithoutOther_CategoryNestedInput = {
    create?: XOR<CategoryCreateWithoutOther_CategoryInput, CategoryUncheckedCreateWithoutOther_CategoryInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutOther_CategoryInput
    upsert?: CategoryUpsertWithoutOther_CategoryInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutOther_CategoryInput, CategoryUpdateWithoutOther_CategoryInput>, CategoryUncheckedUpdateWithoutOther_CategoryInput>
  }

  export type CategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CategoryCreateWithoutCategoryInput, CategoryUncheckedCreateWithoutCategoryInput> | CategoryCreateWithoutCategoryInput[] | CategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutCategoryInput | CategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutCategoryInput | CategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CategoryCreateManyCategoryInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutCategoryInput | CategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutCategoryInput | CategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ContentUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ContentCreateWithoutCategoryInput, ContentUncheckedCreateWithoutCategoryInput> | ContentCreateWithoutCategoryInput[] | ContentUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutCategoryInput | ContentCreateOrConnectWithoutCategoryInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutCategoryInput | ContentUpsertWithWhereUniqueWithoutCategoryInput[]
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutCategoryInput | ContentUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutCategoryInput | ContentUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CategoryCreateWithoutCategoryInput, CategoryUncheckedCreateWithoutCategoryInput> | CategoryCreateWithoutCategoryInput[] | CategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutCategoryInput | CategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutCategoryInput | CategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CategoryCreateManyCategoryInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutCategoryInput | CategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutCategoryInput | CategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ContentUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ContentCreateWithoutCategoryInput, ContentUncheckedCreateWithoutCategoryInput> | ContentCreateWithoutCategoryInput[] | ContentUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutCategoryInput | ContentCreateOrConnectWithoutCategoryInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutCategoryInput | ContentUpsertWithWhereUniqueWithoutCategoryInput[]
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutCategoryInput | ContentUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutCategoryInput | ContentUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type CategoryCreateNestedManyWithoutCollectionInput = {
    create?: XOR<CategoryCreateWithoutCollectionInput, CategoryUncheckedCreateWithoutCollectionInput> | CategoryCreateWithoutCollectionInput[] | CategoryUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutCollectionInput | CategoryCreateOrConnectWithoutCollectionInput[]
    createMany?: CategoryCreateManyCollectionInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type OrganizationCreateNestedOneWithoutCollectionInput = {
    create?: XOR<OrganizationCreateWithoutCollectionInput, OrganizationUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCollectionInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ContentCreateNestedManyWithoutCollectionInput = {
    create?: XOR<ContentCreateWithoutCollectionInput, ContentUncheckedCreateWithoutCollectionInput> | ContentCreateWithoutCollectionInput[] | ContentUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutCollectionInput | ContentCreateOrConnectWithoutCollectionInput[]
    createMany?: ContentCreateManyCollectionInputEnvelope
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type FieldCreateNestedManyWithoutCollectionInput = {
    create?: XOR<FieldCreateWithoutCollectionInput, FieldUncheckedCreateWithoutCollectionInput> | FieldCreateWithoutCollectionInput[] | FieldUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: FieldCreateOrConnectWithoutCollectionInput | FieldCreateOrConnectWithoutCollectionInput[]
    createMany?: FieldCreateManyCollectionInputEnvelope
    connect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
  }

  export type TemplateCreateNestedManyWithoutCollectionInput = {
    create?: XOR<TemplateCreateWithoutCollectionInput, TemplateUncheckedCreateWithoutCollectionInput> | TemplateCreateWithoutCollectionInput[] | TemplateUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutCollectionInput | TemplateCreateOrConnectWithoutCollectionInput[]
    createMany?: TemplateCreateManyCollectionInputEnvelope
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
  }

  export type form_fieldCreateNestedManyWithoutCollectionInput = {
    create?: XOR<form_fieldCreateWithoutCollectionInput, form_fieldUncheckedCreateWithoutCollectionInput> | form_fieldCreateWithoutCollectionInput[] | form_fieldUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: form_fieldCreateOrConnectWithoutCollectionInput | form_fieldCreateOrConnectWithoutCollectionInput[]
    createMany?: form_fieldCreateManyCollectionInputEnvelope
    connect?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<CategoryCreateWithoutCollectionInput, CategoryUncheckedCreateWithoutCollectionInput> | CategoryCreateWithoutCollectionInput[] | CategoryUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutCollectionInput | CategoryCreateOrConnectWithoutCollectionInput[]
    createMany?: CategoryCreateManyCollectionInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ContentUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<ContentCreateWithoutCollectionInput, ContentUncheckedCreateWithoutCollectionInput> | ContentCreateWithoutCollectionInput[] | ContentUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutCollectionInput | ContentCreateOrConnectWithoutCollectionInput[]
    createMany?: ContentCreateManyCollectionInputEnvelope
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type FieldUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<FieldCreateWithoutCollectionInput, FieldUncheckedCreateWithoutCollectionInput> | FieldCreateWithoutCollectionInput[] | FieldUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: FieldCreateOrConnectWithoutCollectionInput | FieldCreateOrConnectWithoutCollectionInput[]
    createMany?: FieldCreateManyCollectionInputEnvelope
    connect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
  }

  export type TemplateUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<TemplateCreateWithoutCollectionInput, TemplateUncheckedCreateWithoutCollectionInput> | TemplateCreateWithoutCollectionInput[] | TemplateUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutCollectionInput | TemplateCreateOrConnectWithoutCollectionInput[]
    createMany?: TemplateCreateManyCollectionInputEnvelope
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
  }

  export type form_fieldUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<form_fieldCreateWithoutCollectionInput, form_fieldUncheckedCreateWithoutCollectionInput> | form_fieldCreateWithoutCollectionInput[] | form_fieldUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: form_fieldCreateOrConnectWithoutCollectionInput | form_fieldCreateOrConnectWithoutCollectionInput[]
    createMany?: form_fieldCreateManyCollectionInputEnvelope
    connect?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CategoryUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<CategoryCreateWithoutCollectionInput, CategoryUncheckedCreateWithoutCollectionInput> | CategoryCreateWithoutCollectionInput[] | CategoryUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutCollectionInput | CategoryCreateOrConnectWithoutCollectionInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutCollectionInput | CategoryUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: CategoryCreateManyCollectionInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutCollectionInput | CategoryUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutCollectionInput | CategoryUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutCollectionNestedInput = {
    create?: XOR<OrganizationCreateWithoutCollectionInput, OrganizationUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCollectionInput
    upsert?: OrganizationUpsertWithoutCollectionInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutCollectionInput, OrganizationUpdateWithoutCollectionInput>, OrganizationUncheckedUpdateWithoutCollectionInput>
  }

  export type ContentUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<ContentCreateWithoutCollectionInput, ContentUncheckedCreateWithoutCollectionInput> | ContentCreateWithoutCollectionInput[] | ContentUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutCollectionInput | ContentCreateOrConnectWithoutCollectionInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutCollectionInput | ContentUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: ContentCreateManyCollectionInputEnvelope
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutCollectionInput | ContentUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutCollectionInput | ContentUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type FieldUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<FieldCreateWithoutCollectionInput, FieldUncheckedCreateWithoutCollectionInput> | FieldCreateWithoutCollectionInput[] | FieldUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: FieldCreateOrConnectWithoutCollectionInput | FieldCreateOrConnectWithoutCollectionInput[]
    upsert?: FieldUpsertWithWhereUniqueWithoutCollectionInput | FieldUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: FieldCreateManyCollectionInputEnvelope
    set?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    disconnect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    delete?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    connect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    update?: FieldUpdateWithWhereUniqueWithoutCollectionInput | FieldUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: FieldUpdateManyWithWhereWithoutCollectionInput | FieldUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: FieldScalarWhereInput | FieldScalarWhereInput[]
  }

  export type TemplateUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<TemplateCreateWithoutCollectionInput, TemplateUncheckedCreateWithoutCollectionInput> | TemplateCreateWithoutCollectionInput[] | TemplateUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutCollectionInput | TemplateCreateOrConnectWithoutCollectionInput[]
    upsert?: TemplateUpsertWithWhereUniqueWithoutCollectionInput | TemplateUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: TemplateCreateManyCollectionInputEnvelope
    set?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    disconnect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    delete?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    update?: TemplateUpdateWithWhereUniqueWithoutCollectionInput | TemplateUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: TemplateUpdateManyWithWhereWithoutCollectionInput | TemplateUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
  }

  export type form_fieldUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<form_fieldCreateWithoutCollectionInput, form_fieldUncheckedCreateWithoutCollectionInput> | form_fieldCreateWithoutCollectionInput[] | form_fieldUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: form_fieldCreateOrConnectWithoutCollectionInput | form_fieldCreateOrConnectWithoutCollectionInput[]
    upsert?: form_fieldUpsertWithWhereUniqueWithoutCollectionInput | form_fieldUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: form_fieldCreateManyCollectionInputEnvelope
    set?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    disconnect?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    delete?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    connect?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    update?: form_fieldUpdateWithWhereUniqueWithoutCollectionInput | form_fieldUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: form_fieldUpdateManyWithWhereWithoutCollectionInput | form_fieldUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: form_fieldScalarWhereInput | form_fieldScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<CategoryCreateWithoutCollectionInput, CategoryUncheckedCreateWithoutCollectionInput> | CategoryCreateWithoutCollectionInput[] | CategoryUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutCollectionInput | CategoryCreateOrConnectWithoutCollectionInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutCollectionInput | CategoryUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: CategoryCreateManyCollectionInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutCollectionInput | CategoryUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutCollectionInput | CategoryUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ContentUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<ContentCreateWithoutCollectionInput, ContentUncheckedCreateWithoutCollectionInput> | ContentCreateWithoutCollectionInput[] | ContentUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutCollectionInput | ContentCreateOrConnectWithoutCollectionInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutCollectionInput | ContentUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: ContentCreateManyCollectionInputEnvelope
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutCollectionInput | ContentUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutCollectionInput | ContentUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type FieldUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<FieldCreateWithoutCollectionInput, FieldUncheckedCreateWithoutCollectionInput> | FieldCreateWithoutCollectionInput[] | FieldUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: FieldCreateOrConnectWithoutCollectionInput | FieldCreateOrConnectWithoutCollectionInput[]
    upsert?: FieldUpsertWithWhereUniqueWithoutCollectionInput | FieldUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: FieldCreateManyCollectionInputEnvelope
    set?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    disconnect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    delete?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    connect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    update?: FieldUpdateWithWhereUniqueWithoutCollectionInput | FieldUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: FieldUpdateManyWithWhereWithoutCollectionInput | FieldUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: FieldScalarWhereInput | FieldScalarWhereInput[]
  }

  export type TemplateUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<TemplateCreateWithoutCollectionInput, TemplateUncheckedCreateWithoutCollectionInput> | TemplateCreateWithoutCollectionInput[] | TemplateUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutCollectionInput | TemplateCreateOrConnectWithoutCollectionInput[]
    upsert?: TemplateUpsertWithWhereUniqueWithoutCollectionInput | TemplateUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: TemplateCreateManyCollectionInputEnvelope
    set?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    disconnect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    delete?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    update?: TemplateUpdateWithWhereUniqueWithoutCollectionInput | TemplateUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: TemplateUpdateManyWithWhereWithoutCollectionInput | TemplateUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
  }

  export type form_fieldUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<form_fieldCreateWithoutCollectionInput, form_fieldUncheckedCreateWithoutCollectionInput> | form_fieldCreateWithoutCollectionInput[] | form_fieldUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: form_fieldCreateOrConnectWithoutCollectionInput | form_fieldCreateOrConnectWithoutCollectionInput[]
    upsert?: form_fieldUpsertWithWhereUniqueWithoutCollectionInput | form_fieldUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: form_fieldCreateManyCollectionInputEnvelope
    set?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    disconnect?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    delete?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    connect?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    update?: form_fieldUpdateWithWhereUniqueWithoutCollectionInput | form_fieldUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: form_fieldUpdateManyWithWhereWithoutCollectionInput | form_fieldUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: form_fieldScalarWhereInput | form_fieldScalarWhereInput[]
  }

  export type ContentCreateNestedOneWithoutCommentInput = {
    create?: XOR<ContentCreateWithoutCommentInput, ContentUncheckedCreateWithoutCommentInput>
    connectOrCreate?: ContentCreateOrConnectWithoutCommentInput
    connect?: ContentWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutCommentInput = {
    create?: XOR<OrganizationCreateWithoutCommentInput, OrganizationUncheckedCreateWithoutCommentInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCommentInput
    connect?: OrganizationWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutOther_CommentInput = {
    create?: XOR<CommentCreateWithoutOther_CommentInput, CommentUncheckedCreateWithoutOther_CommentInput>
    connectOrCreate?: CommentCreateOrConnectWithoutOther_CommentInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentCreateWithoutCommentInput, CommentUncheckedCreateWithoutCommentInput> | CommentCreateWithoutCommentInput[] | CommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCommentInput | CommentCreateOrConnectWithoutCommentInput[]
    createMany?: CommentCreateManyCommentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentCreateWithoutCommentInput, CommentUncheckedCreateWithoutCommentInput> | CommentCreateWithoutCommentInput[] | CommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCommentInput | CommentCreateOrConnectWithoutCommentInput[]
    createMany?: CommentCreateManyCommentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ContentUpdateOneRequiredWithoutCommentNestedInput = {
    create?: XOR<ContentCreateWithoutCommentInput, ContentUncheckedCreateWithoutCommentInput>
    connectOrCreate?: ContentCreateOrConnectWithoutCommentInput
    upsert?: ContentUpsertWithoutCommentInput
    connect?: ContentWhereUniqueInput
    update?: XOR<XOR<ContentUpdateToOneWithWhereWithoutCommentInput, ContentUpdateWithoutCommentInput>, ContentUncheckedUpdateWithoutCommentInput>
  }

  export type OrganizationUpdateOneRequiredWithoutCommentNestedInput = {
    create?: XOR<OrganizationCreateWithoutCommentInput, OrganizationUncheckedCreateWithoutCommentInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCommentInput
    upsert?: OrganizationUpsertWithoutCommentInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutCommentInput, OrganizationUpdateWithoutCommentInput>, OrganizationUncheckedUpdateWithoutCommentInput>
  }

  export type CommentUpdateOneWithoutOther_CommentNestedInput = {
    create?: XOR<CommentCreateWithoutOther_CommentInput, CommentUncheckedCreateWithoutOther_CommentInput>
    connectOrCreate?: CommentCreateOrConnectWithoutOther_CommentInput
    upsert?: CommentUpsertWithoutOther_CommentInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutOther_CommentInput, CommentUpdateWithoutOther_CommentInput>, CommentUncheckedUpdateWithoutOther_CommentInput>
  }

  export type CommentUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentCreateWithoutCommentInput, CommentUncheckedCreateWithoutCommentInput> | CommentCreateWithoutCommentInput[] | CommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCommentInput | CommentCreateOrConnectWithoutCommentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutCommentInput | CommentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentCreateManyCommentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutCommentInput | CommentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutCommentInput | CommentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentCreateWithoutCommentInput, CommentUncheckedCreateWithoutCommentInput> | CommentCreateWithoutCommentInput[] | CommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCommentInput | CommentCreateOrConnectWithoutCommentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutCommentInput | CommentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentCreateManyCommentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutCommentInput | CommentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutCommentInput | CommentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutCompletionUsageInput = {
    create?: XOR<OrganizationCreateWithoutCompletionUsageInput, OrganizationUncheckedCreateWithoutCompletionUsageInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCompletionUsageInput
    connect?: OrganizationWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrganizationUpdateOneRequiredWithoutCompletionUsageNestedInput = {
    create?: XOR<OrganizationCreateWithoutCompletionUsageInput, OrganizationUncheckedCreateWithoutCompletionUsageInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCompletionUsageInput
    upsert?: OrganizationUpsertWithoutCompletionUsageInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutCompletionUsageInput, OrganizationUpdateWithoutCompletionUsageInput>, OrganizationUncheckedUpdateWithoutCompletionUsageInput>
  }

  export type ContentCreatecontent_categoryInput = {
    set: string[]
  }

  export type CommentCreateNestedManyWithoutContentInput = {
    create?: XOR<CommentCreateWithoutContentInput, CommentUncheckedCreateWithoutContentInput> | CommentCreateWithoutContentInput[] | CommentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutContentInput | CommentCreateOrConnectWithoutContentInput[]
    createMany?: CommentCreateManyContentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type authorCreateNestedOneWithoutContentInput = {
    create?: XOR<authorCreateWithoutContentInput, authorUncheckedCreateWithoutContentInput>
    connectOrCreate?: authorCreateOrConnectWithoutContentInput
    connect?: authorWhereUniqueInput
  }

  export type CollectionCreateNestedOneWithoutContentInput = {
    create?: XOR<CollectionCreateWithoutContentInput, CollectionUncheckedCreateWithoutContentInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutContentInput
    connect?: CollectionWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutContentInput = {
    create?: XOR<OrganizationCreateWithoutContentInput, OrganizationUncheckedCreateWithoutContentInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutContentInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ContentTemplateInstanceCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentTemplateInstanceCreateWithoutContentInput, ContentTemplateInstanceUncheckedCreateWithoutContentInput> | ContentTemplateInstanceCreateWithoutContentInput[] | ContentTemplateInstanceUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentTemplateInstanceCreateOrConnectWithoutContentInput | ContentTemplateInstanceCreateOrConnectWithoutContentInput[]
    createMany?: ContentTemplateInstanceCreateManyContentInputEnvelope
    connect?: ContentTemplateInstanceWhereUniqueInput | ContentTemplateInstanceWhereUniqueInput[]
  }

  export type CategoryCreateNestedManyWithoutContentInput = {
    create?: XOR<CategoryCreateWithoutContentInput, CategoryUncheckedCreateWithoutContentInput> | CategoryCreateWithoutContentInput[] | CategoryUncheckedCreateWithoutContentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutContentInput | CategoryCreateOrConnectWithoutContentInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<CommentCreateWithoutContentInput, CommentUncheckedCreateWithoutContentInput> | CommentCreateWithoutContentInput[] | CommentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutContentInput | CommentCreateOrConnectWithoutContentInput[]
    createMany?: CommentCreateManyContentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ContentTemplateInstanceUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentTemplateInstanceCreateWithoutContentInput, ContentTemplateInstanceUncheckedCreateWithoutContentInput> | ContentTemplateInstanceCreateWithoutContentInput[] | ContentTemplateInstanceUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentTemplateInstanceCreateOrConnectWithoutContentInput | ContentTemplateInstanceCreateOrConnectWithoutContentInput[]
    createMany?: ContentTemplateInstanceCreateManyContentInputEnvelope
    connect?: ContentTemplateInstanceWhereUniqueInput | ContentTemplateInstanceWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<CategoryCreateWithoutContentInput, CategoryUncheckedCreateWithoutContentInput> | CategoryCreateWithoutContentInput[] | CategoryUncheckedCreateWithoutContentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutContentInput | CategoryCreateOrConnectWithoutContentInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ContentUpdatecontent_categoryInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CommentUpdateManyWithoutContentNestedInput = {
    create?: XOR<CommentCreateWithoutContentInput, CommentUncheckedCreateWithoutContentInput> | CommentCreateWithoutContentInput[] | CommentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutContentInput | CommentCreateOrConnectWithoutContentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutContentInput | CommentUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: CommentCreateManyContentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutContentInput | CommentUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutContentInput | CommentUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type authorUpdateOneWithoutContentNestedInput = {
    create?: XOR<authorCreateWithoutContentInput, authorUncheckedCreateWithoutContentInput>
    connectOrCreate?: authorCreateOrConnectWithoutContentInput
    upsert?: authorUpsertWithoutContentInput
    disconnect?: authorWhereInput | boolean
    delete?: authorWhereInput | boolean
    connect?: authorWhereUniqueInput
    update?: XOR<XOR<authorUpdateToOneWithWhereWithoutContentInput, authorUpdateWithoutContentInput>, authorUncheckedUpdateWithoutContentInput>
  }

  export type CollectionUpdateOneRequiredWithoutContentNestedInput = {
    create?: XOR<CollectionCreateWithoutContentInput, CollectionUncheckedCreateWithoutContentInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutContentInput
    upsert?: CollectionUpsertWithoutContentInput
    connect?: CollectionWhereUniqueInput
    update?: XOR<XOR<CollectionUpdateToOneWithWhereWithoutContentInput, CollectionUpdateWithoutContentInput>, CollectionUncheckedUpdateWithoutContentInput>
  }

  export type OrganizationUpdateOneWithoutContentNestedInput = {
    create?: XOR<OrganizationCreateWithoutContentInput, OrganizationUncheckedCreateWithoutContentInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutContentInput
    upsert?: OrganizationUpsertWithoutContentInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutContentInput, OrganizationUpdateWithoutContentInput>, OrganizationUncheckedUpdateWithoutContentInput>
  }

  export type ContentTemplateInstanceUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentTemplateInstanceCreateWithoutContentInput, ContentTemplateInstanceUncheckedCreateWithoutContentInput> | ContentTemplateInstanceCreateWithoutContentInput[] | ContentTemplateInstanceUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentTemplateInstanceCreateOrConnectWithoutContentInput | ContentTemplateInstanceCreateOrConnectWithoutContentInput[]
    upsert?: ContentTemplateInstanceUpsertWithWhereUniqueWithoutContentInput | ContentTemplateInstanceUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentTemplateInstanceCreateManyContentInputEnvelope
    set?: ContentTemplateInstanceWhereUniqueInput | ContentTemplateInstanceWhereUniqueInput[]
    disconnect?: ContentTemplateInstanceWhereUniqueInput | ContentTemplateInstanceWhereUniqueInput[]
    delete?: ContentTemplateInstanceWhereUniqueInput | ContentTemplateInstanceWhereUniqueInput[]
    connect?: ContentTemplateInstanceWhereUniqueInput | ContentTemplateInstanceWhereUniqueInput[]
    update?: ContentTemplateInstanceUpdateWithWhereUniqueWithoutContentInput | ContentTemplateInstanceUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentTemplateInstanceUpdateManyWithWhereWithoutContentInput | ContentTemplateInstanceUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentTemplateInstanceScalarWhereInput | ContentTemplateInstanceScalarWhereInput[]
  }

  export type CategoryUpdateManyWithoutContentNestedInput = {
    create?: XOR<CategoryCreateWithoutContentInput, CategoryUncheckedCreateWithoutContentInput> | CategoryCreateWithoutContentInput[] | CategoryUncheckedCreateWithoutContentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutContentInput | CategoryCreateOrConnectWithoutContentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutContentInput | CategoryUpsertWithWhereUniqueWithoutContentInput[]
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutContentInput | CategoryUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutContentInput | CategoryUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<CommentCreateWithoutContentInput, CommentUncheckedCreateWithoutContentInput> | CommentCreateWithoutContentInput[] | CommentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutContentInput | CommentCreateOrConnectWithoutContentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutContentInput | CommentUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: CommentCreateManyContentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutContentInput | CommentUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutContentInput | CommentUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ContentTemplateInstanceUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentTemplateInstanceCreateWithoutContentInput, ContentTemplateInstanceUncheckedCreateWithoutContentInput> | ContentTemplateInstanceCreateWithoutContentInput[] | ContentTemplateInstanceUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentTemplateInstanceCreateOrConnectWithoutContentInput | ContentTemplateInstanceCreateOrConnectWithoutContentInput[]
    upsert?: ContentTemplateInstanceUpsertWithWhereUniqueWithoutContentInput | ContentTemplateInstanceUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentTemplateInstanceCreateManyContentInputEnvelope
    set?: ContentTemplateInstanceWhereUniqueInput | ContentTemplateInstanceWhereUniqueInput[]
    disconnect?: ContentTemplateInstanceWhereUniqueInput | ContentTemplateInstanceWhereUniqueInput[]
    delete?: ContentTemplateInstanceWhereUniqueInput | ContentTemplateInstanceWhereUniqueInput[]
    connect?: ContentTemplateInstanceWhereUniqueInput | ContentTemplateInstanceWhereUniqueInput[]
    update?: ContentTemplateInstanceUpdateWithWhereUniqueWithoutContentInput | ContentTemplateInstanceUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentTemplateInstanceUpdateManyWithWhereWithoutContentInput | ContentTemplateInstanceUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentTemplateInstanceScalarWhereInput | ContentTemplateInstanceScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<CategoryCreateWithoutContentInput, CategoryUncheckedCreateWithoutContentInput> | CategoryCreateWithoutContentInput[] | CategoryUncheckedCreateWithoutContentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutContentInput | CategoryCreateOrConnectWithoutContentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutContentInput | CategoryUpsertWithWhereUniqueWithoutContentInput[]
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutContentInput | CategoryUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutContentInput | CategoryUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ContentCreateNestedOneWithoutContentTemplateInstanceInput = {
    create?: XOR<ContentCreateWithoutContentTemplateInstanceInput, ContentUncheckedCreateWithoutContentTemplateInstanceInput>
    connectOrCreate?: ContentCreateOrConnectWithoutContentTemplateInstanceInput
    connect?: ContentWhereUniqueInput
  }

  export type TemplateInstanceCreateNestedOneWithoutContentTemplateInstanceInput = {
    create?: XOR<TemplateInstanceCreateWithoutContentTemplateInstanceInput, TemplateInstanceUncheckedCreateWithoutContentTemplateInstanceInput>
    connectOrCreate?: TemplateInstanceCreateOrConnectWithoutContentTemplateInstanceInput
    connect?: TemplateInstanceWhereUniqueInput
  }

  export type ContentUpdateOneRequiredWithoutContentTemplateInstanceNestedInput = {
    create?: XOR<ContentCreateWithoutContentTemplateInstanceInput, ContentUncheckedCreateWithoutContentTemplateInstanceInput>
    connectOrCreate?: ContentCreateOrConnectWithoutContentTemplateInstanceInput
    upsert?: ContentUpsertWithoutContentTemplateInstanceInput
    connect?: ContentWhereUniqueInput
    update?: XOR<XOR<ContentUpdateToOneWithWhereWithoutContentTemplateInstanceInput, ContentUpdateWithoutContentTemplateInstanceInput>, ContentUncheckedUpdateWithoutContentTemplateInstanceInput>
  }

  export type TemplateInstanceUpdateOneRequiredWithoutContentTemplateInstanceNestedInput = {
    create?: XOR<TemplateInstanceCreateWithoutContentTemplateInstanceInput, TemplateInstanceUncheckedCreateWithoutContentTemplateInstanceInput>
    connectOrCreate?: TemplateInstanceCreateOrConnectWithoutContentTemplateInstanceInput
    upsert?: TemplateInstanceUpsertWithoutContentTemplateInstanceInput
    connect?: TemplateInstanceWhereUniqueInput
    update?: XOR<XOR<TemplateInstanceUpdateToOneWithWhereWithoutContentTemplateInstanceInput, TemplateInstanceUpdateWithoutContentTemplateInstanceInput>, TemplateInstanceUncheckedUpdateWithoutContentTemplateInstanceInput>
  }

  export type FieldCreateoptionsInput = {
    set: string[]
  }

  export type CollectionCreateNestedOneWithoutFieldInput = {
    create?: XOR<CollectionCreateWithoutFieldInput, CollectionUncheckedCreateWithoutFieldInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutFieldInput
    connect?: CollectionWhereUniqueInput
  }

  export type TemplateCreateNestedOneWithoutFieldInput = {
    create?: XOR<TemplateCreateWithoutFieldInput, TemplateUncheckedCreateWithoutFieldInput>
    connectOrCreate?: TemplateCreateOrConnectWithoutFieldInput
    connect?: TemplateWhereUniqueInput
  }

  export type FieldUpdateoptionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CollectionUpdateOneWithoutFieldNestedInput = {
    create?: XOR<CollectionCreateWithoutFieldInput, CollectionUncheckedCreateWithoutFieldInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutFieldInput
    upsert?: CollectionUpsertWithoutFieldInput
    disconnect?: CollectionWhereInput | boolean
    delete?: CollectionWhereInput | boolean
    connect?: CollectionWhereUniqueInput
    update?: XOR<XOR<CollectionUpdateToOneWithWhereWithoutFieldInput, CollectionUpdateWithoutFieldInput>, CollectionUncheckedUpdateWithoutFieldInput>
  }

  export type TemplateUpdateOneWithoutFieldNestedInput = {
    create?: XOR<TemplateCreateWithoutFieldInput, TemplateUncheckedCreateWithoutFieldInput>
    connectOrCreate?: TemplateCreateOrConnectWithoutFieldInput
    upsert?: TemplateUpsertWithoutFieldInput
    disconnect?: TemplateWhereInput | boolean
    delete?: TemplateWhereInput | boolean
    connect?: TemplateWhereUniqueInput
    update?: XOR<XOR<TemplateUpdateToOneWithWhereWithoutFieldInput, TemplateUpdateWithoutFieldInput>, TemplateUncheckedUpdateWithoutFieldInput>
  }

  export type OrganizationCreateNestedOneWithoutImageGenerationBillingInput = {
    create?: XOR<OrganizationCreateWithoutImageGenerationBillingInput, OrganizationUncheckedCreateWithoutImageGenerationBillingInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutImageGenerationBillingInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutImageGenerationBillingNestedInput = {
    create?: XOR<OrganizationCreateWithoutImageGenerationBillingInput, OrganizationUncheckedCreateWithoutImageGenerationBillingInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutImageGenerationBillingInput
    upsert?: OrganizationUpsertWithoutImageGenerationBillingInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutImageGenerationBillingInput, OrganizationUpdateWithoutImageGenerationBillingInput>, OrganizationUncheckedUpdateWithoutImageGenerationBillingInput>
  }

  export type OrganizationCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<OrganizationCreateWithoutInvoiceInput, OrganizationUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvoiceInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<OrganizationCreateWithoutInvoiceInput, OrganizationUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvoiceInput
    upsert?: OrganizationUpsertWithoutInvoiceInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutInvoiceInput, OrganizationUpdateWithoutInvoiceInput>, OrganizationUncheckedUpdateWithoutInvoiceInput>
  }

  export type LinkPageCreatelinksInput = {
    set: InputJsonValue[]
  }

  export type MediaCreateNestedOneWithoutLinkPageInput = {
    create?: XOR<MediaCreateWithoutLinkPageInput, MediaUncheckedCreateWithoutLinkPageInput>
    connectOrCreate?: MediaCreateOrConnectWithoutLinkPageInput
    connect?: MediaWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutLinkPageInput = {
    create?: XOR<OrganizationCreateWithoutLinkPageInput, OrganizationUncheckedCreateWithoutLinkPageInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutLinkPageInput
    connect?: OrganizationWhereUniqueInput
  }

  export type LinkPageUpdatelinksInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type MediaUpdateOneWithoutLinkPageNestedInput = {
    create?: XOR<MediaCreateWithoutLinkPageInput, MediaUncheckedCreateWithoutLinkPageInput>
    connectOrCreate?: MediaCreateOrConnectWithoutLinkPageInput
    upsert?: MediaUpsertWithoutLinkPageInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutLinkPageInput, MediaUpdateWithoutLinkPageInput>, MediaUncheckedUpdateWithoutLinkPageInput>
  }

  export type OrganizationUpdateOneRequiredWithoutLinkPageNestedInput = {
    create?: XOR<OrganizationCreateWithoutLinkPageInput, OrganizationUncheckedCreateWithoutLinkPageInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutLinkPageInput
    upsert?: OrganizationUpsertWithoutLinkPageInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutLinkPageInput, OrganizationUpdateWithoutLinkPageInput>, OrganizationUncheckedUpdateWithoutLinkPageInput>
  }

  export type LinkPageCreateNestedManyWithoutMediaInput = {
    create?: XOR<LinkPageCreateWithoutMediaInput, LinkPageUncheckedCreateWithoutMediaInput> | LinkPageCreateWithoutMediaInput[] | LinkPageUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: LinkPageCreateOrConnectWithoutMediaInput | LinkPageCreateOrConnectWithoutMediaInput[]
    createMany?: LinkPageCreateManyMediaInputEnvelope
    connect?: LinkPageWhereUniqueInput | LinkPageWhereUniqueInput[]
  }

  export type OrganizationCreateNestedOneWithoutMediaInput = {
    create?: XOR<OrganizationCreateWithoutMediaInput, OrganizationUncheckedCreateWithoutMediaInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMediaInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UsersCreateNestedManyWithoutMediaInput = {
    create?: XOR<UsersCreateWithoutMediaInput, UsersUncheckedCreateWithoutMediaInput> | UsersCreateWithoutMediaInput[] | UsersUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutMediaInput | UsersCreateOrConnectWithoutMediaInput[]
    createMany?: UsersCreateManyMediaInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type authorCreateNestedManyWithoutMediaInput = {
    create?: XOR<authorCreateWithoutMediaInput, authorUncheckedCreateWithoutMediaInput> | authorCreateWithoutMediaInput[] | authorUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: authorCreateOrConnectWithoutMediaInput | authorCreateOrConnectWithoutMediaInput[]
    createMany?: authorCreateManyMediaInputEnvelope
    connect?: authorWhereUniqueInput | authorWhereUniqueInput[]
  }

  export type org_detailsCreateNestedOneWithoutMediaInput = {
    create?: XOR<org_detailsCreateWithoutMediaInput, org_detailsUncheckedCreateWithoutMediaInput>
    connectOrCreate?: org_detailsCreateOrConnectWithoutMediaInput
    connect?: org_detailsWhereUniqueInput
  }

  export type structCreateNestedManyWithoutMediaInput = {
    create?: XOR<structCreateWithoutMediaInput, structUncheckedCreateWithoutMediaInput> | structCreateWithoutMediaInput[] | structUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: structCreateOrConnectWithoutMediaInput | structCreateOrConnectWithoutMediaInput[]
    createMany?: structCreateManyMediaInputEnvelope
    connect?: structWhereUniqueInput | structWhereUniqueInput[]
  }

  export type LinkPageUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<LinkPageCreateWithoutMediaInput, LinkPageUncheckedCreateWithoutMediaInput> | LinkPageCreateWithoutMediaInput[] | LinkPageUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: LinkPageCreateOrConnectWithoutMediaInput | LinkPageCreateOrConnectWithoutMediaInput[]
    createMany?: LinkPageCreateManyMediaInputEnvelope
    connect?: LinkPageWhereUniqueInput | LinkPageWhereUniqueInput[]
  }

  export type UsersUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<UsersCreateWithoutMediaInput, UsersUncheckedCreateWithoutMediaInput> | UsersCreateWithoutMediaInput[] | UsersUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutMediaInput | UsersCreateOrConnectWithoutMediaInput[]
    createMany?: UsersCreateManyMediaInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type authorUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<authorCreateWithoutMediaInput, authorUncheckedCreateWithoutMediaInput> | authorCreateWithoutMediaInput[] | authorUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: authorCreateOrConnectWithoutMediaInput | authorCreateOrConnectWithoutMediaInput[]
    createMany?: authorCreateManyMediaInputEnvelope
    connect?: authorWhereUniqueInput | authorWhereUniqueInput[]
  }

  export type org_detailsUncheckedCreateNestedOneWithoutMediaInput = {
    create?: XOR<org_detailsCreateWithoutMediaInput, org_detailsUncheckedCreateWithoutMediaInput>
    connectOrCreate?: org_detailsCreateOrConnectWithoutMediaInput
    connect?: org_detailsWhereUniqueInput
  }

  export type structUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<structCreateWithoutMediaInput, structUncheckedCreateWithoutMediaInput> | structCreateWithoutMediaInput[] | structUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: structCreateOrConnectWithoutMediaInput | structCreateOrConnectWithoutMediaInput[]
    createMany?: structCreateManyMediaInputEnvelope
    connect?: structWhereUniqueInput | structWhereUniqueInput[]
  }

  export type LinkPageUpdateManyWithoutMediaNestedInput = {
    create?: XOR<LinkPageCreateWithoutMediaInput, LinkPageUncheckedCreateWithoutMediaInput> | LinkPageCreateWithoutMediaInput[] | LinkPageUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: LinkPageCreateOrConnectWithoutMediaInput | LinkPageCreateOrConnectWithoutMediaInput[]
    upsert?: LinkPageUpsertWithWhereUniqueWithoutMediaInput | LinkPageUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: LinkPageCreateManyMediaInputEnvelope
    set?: LinkPageWhereUniqueInput | LinkPageWhereUniqueInput[]
    disconnect?: LinkPageWhereUniqueInput | LinkPageWhereUniqueInput[]
    delete?: LinkPageWhereUniqueInput | LinkPageWhereUniqueInput[]
    connect?: LinkPageWhereUniqueInput | LinkPageWhereUniqueInput[]
    update?: LinkPageUpdateWithWhereUniqueWithoutMediaInput | LinkPageUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: LinkPageUpdateManyWithWhereWithoutMediaInput | LinkPageUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: LinkPageScalarWhereInput | LinkPageScalarWhereInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<OrganizationCreateWithoutMediaInput, OrganizationUncheckedCreateWithoutMediaInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMediaInput
    upsert?: OrganizationUpsertWithoutMediaInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutMediaInput, OrganizationUpdateWithoutMediaInput>, OrganizationUncheckedUpdateWithoutMediaInput>
  }

  export type UsersUpdateManyWithoutMediaNestedInput = {
    create?: XOR<UsersCreateWithoutMediaInput, UsersUncheckedCreateWithoutMediaInput> | UsersCreateWithoutMediaInput[] | UsersUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutMediaInput | UsersCreateOrConnectWithoutMediaInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutMediaInput | UsersUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: UsersCreateManyMediaInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutMediaInput | UsersUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutMediaInput | UsersUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type authorUpdateManyWithoutMediaNestedInput = {
    create?: XOR<authorCreateWithoutMediaInput, authorUncheckedCreateWithoutMediaInput> | authorCreateWithoutMediaInput[] | authorUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: authorCreateOrConnectWithoutMediaInput | authorCreateOrConnectWithoutMediaInput[]
    upsert?: authorUpsertWithWhereUniqueWithoutMediaInput | authorUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: authorCreateManyMediaInputEnvelope
    set?: authorWhereUniqueInput | authorWhereUniqueInput[]
    disconnect?: authorWhereUniqueInput | authorWhereUniqueInput[]
    delete?: authorWhereUniqueInput | authorWhereUniqueInput[]
    connect?: authorWhereUniqueInput | authorWhereUniqueInput[]
    update?: authorUpdateWithWhereUniqueWithoutMediaInput | authorUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: authorUpdateManyWithWhereWithoutMediaInput | authorUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: authorScalarWhereInput | authorScalarWhereInput[]
  }

  export type org_detailsUpdateOneWithoutMediaNestedInput = {
    create?: XOR<org_detailsCreateWithoutMediaInput, org_detailsUncheckedCreateWithoutMediaInput>
    connectOrCreate?: org_detailsCreateOrConnectWithoutMediaInput
    upsert?: org_detailsUpsertWithoutMediaInput
    disconnect?: org_detailsWhereInput | boolean
    delete?: org_detailsWhereInput | boolean
    connect?: org_detailsWhereUniqueInput
    update?: XOR<XOR<org_detailsUpdateToOneWithWhereWithoutMediaInput, org_detailsUpdateWithoutMediaInput>, org_detailsUncheckedUpdateWithoutMediaInput>
  }

  export type structUpdateManyWithoutMediaNestedInput = {
    create?: XOR<structCreateWithoutMediaInput, structUncheckedCreateWithoutMediaInput> | structCreateWithoutMediaInput[] | structUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: structCreateOrConnectWithoutMediaInput | structCreateOrConnectWithoutMediaInput[]
    upsert?: structUpsertWithWhereUniqueWithoutMediaInput | structUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: structCreateManyMediaInputEnvelope
    set?: structWhereUniqueInput | structWhereUniqueInput[]
    disconnect?: structWhereUniqueInput | structWhereUniqueInput[]
    delete?: structWhereUniqueInput | structWhereUniqueInput[]
    connect?: structWhereUniqueInput | structWhereUniqueInput[]
    update?: structUpdateWithWhereUniqueWithoutMediaInput | structUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: structUpdateManyWithWhereWithoutMediaInput | structUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: structScalarWhereInput | structScalarWhereInput[]
  }

  export type LinkPageUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<LinkPageCreateWithoutMediaInput, LinkPageUncheckedCreateWithoutMediaInput> | LinkPageCreateWithoutMediaInput[] | LinkPageUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: LinkPageCreateOrConnectWithoutMediaInput | LinkPageCreateOrConnectWithoutMediaInput[]
    upsert?: LinkPageUpsertWithWhereUniqueWithoutMediaInput | LinkPageUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: LinkPageCreateManyMediaInputEnvelope
    set?: LinkPageWhereUniqueInput | LinkPageWhereUniqueInput[]
    disconnect?: LinkPageWhereUniqueInput | LinkPageWhereUniqueInput[]
    delete?: LinkPageWhereUniqueInput | LinkPageWhereUniqueInput[]
    connect?: LinkPageWhereUniqueInput | LinkPageWhereUniqueInput[]
    update?: LinkPageUpdateWithWhereUniqueWithoutMediaInput | LinkPageUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: LinkPageUpdateManyWithWhereWithoutMediaInput | LinkPageUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: LinkPageScalarWhereInput | LinkPageScalarWhereInput[]
  }

  export type UsersUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<UsersCreateWithoutMediaInput, UsersUncheckedCreateWithoutMediaInput> | UsersCreateWithoutMediaInput[] | UsersUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutMediaInput | UsersCreateOrConnectWithoutMediaInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutMediaInput | UsersUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: UsersCreateManyMediaInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutMediaInput | UsersUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutMediaInput | UsersUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type authorUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<authorCreateWithoutMediaInput, authorUncheckedCreateWithoutMediaInput> | authorCreateWithoutMediaInput[] | authorUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: authorCreateOrConnectWithoutMediaInput | authorCreateOrConnectWithoutMediaInput[]
    upsert?: authorUpsertWithWhereUniqueWithoutMediaInput | authorUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: authorCreateManyMediaInputEnvelope
    set?: authorWhereUniqueInput | authorWhereUniqueInput[]
    disconnect?: authorWhereUniqueInput | authorWhereUniqueInput[]
    delete?: authorWhereUniqueInput | authorWhereUniqueInput[]
    connect?: authorWhereUniqueInput | authorWhereUniqueInput[]
    update?: authorUpdateWithWhereUniqueWithoutMediaInput | authorUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: authorUpdateManyWithWhereWithoutMediaInput | authorUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: authorScalarWhereInput | authorScalarWhereInput[]
  }

  export type org_detailsUncheckedUpdateOneWithoutMediaNestedInput = {
    create?: XOR<org_detailsCreateWithoutMediaInput, org_detailsUncheckedCreateWithoutMediaInput>
    connectOrCreate?: org_detailsCreateOrConnectWithoutMediaInput
    upsert?: org_detailsUpsertWithoutMediaInput
    disconnect?: org_detailsWhereInput | boolean
    delete?: org_detailsWhereInput | boolean
    connect?: org_detailsWhereUniqueInput
    update?: XOR<XOR<org_detailsUpdateToOneWithWhereWithoutMediaInput, org_detailsUpdateWithoutMediaInput>, org_detailsUncheckedUpdateWithoutMediaInput>
  }

  export type structUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<structCreateWithoutMediaInput, structUncheckedCreateWithoutMediaInput> | structCreateWithoutMediaInput[] | structUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: structCreateOrConnectWithoutMediaInput | structCreateOrConnectWithoutMediaInput[]
    upsert?: structUpsertWithWhereUniqueWithoutMediaInput | structUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: structCreateManyMediaInputEnvelope
    set?: structWhereUniqueInput | structWhereUniqueInput[]
    disconnect?: structWhereUniqueInput | structWhereUniqueInput[]
    delete?: structWhereUniqueInput | structWhereUniqueInput[]
    connect?: structWhereUniqueInput | structWhereUniqueInput[]
    update?: structUpdateWithWhereUniqueWithoutMediaInput | structUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: structUpdateManyWithWhereWithoutMediaInput | structUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: structScalarWhereInput | structScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<OrganizationCreateWithoutMessagesInput, OrganizationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMessagesInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<OrganizationCreateWithoutMessagesInput, OrganizationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMessagesInput
    upsert?: OrganizationUpsertWithoutMessagesInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutMessagesInput, OrganizationUpdateWithoutMessagesInput>, OrganizationUncheckedUpdateWithoutMessagesInput>
  }

  export type CategoryCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<CategoryCreateWithoutOrganizationInput, CategoryUncheckedCreateWithoutOrganizationInput> | CategoryCreateWithoutOrganizationInput[] | CategoryUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutOrganizationInput | CategoryCreateOrConnectWithoutOrganizationInput[]
    createMany?: CategoryCreateManyOrganizationInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type CollectionCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<CollectionCreateWithoutOrganizationInput, CollectionUncheckedCreateWithoutOrganizationInput> | CollectionCreateWithoutOrganizationInput[] | CollectionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutOrganizationInput | CollectionCreateOrConnectWithoutOrganizationInput[]
    createMany?: CollectionCreateManyOrganizationInputEnvelope
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<CommentCreateWithoutOrganizationInput, CommentUncheckedCreateWithoutOrganizationInput> | CommentCreateWithoutOrganizationInput[] | CommentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutOrganizationInput | CommentCreateOrConnectWithoutOrganizationInput[]
    createMany?: CommentCreateManyOrganizationInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CompletionUsageCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<CompletionUsageCreateWithoutOrganizationInput, CompletionUsageUncheckedCreateWithoutOrganizationInput> | CompletionUsageCreateWithoutOrganizationInput[] | CompletionUsageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CompletionUsageCreateOrConnectWithoutOrganizationInput | CompletionUsageCreateOrConnectWithoutOrganizationInput[]
    createMany?: CompletionUsageCreateManyOrganizationInputEnvelope
    connect?: CompletionUsageWhereUniqueInput | CompletionUsageWhereUniqueInput[]
  }

  export type ContentCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ContentCreateWithoutOrganizationInput, ContentUncheckedCreateWithoutOrganizationInput> | ContentCreateWithoutOrganizationInput[] | ContentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutOrganizationInput | ContentCreateOrConnectWithoutOrganizationInput[]
    createMany?: ContentCreateManyOrganizationInputEnvelope
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type ImageGenerationBillingCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ImageGenerationBillingCreateWithoutOrganizationInput, ImageGenerationBillingUncheckedCreateWithoutOrganizationInput> | ImageGenerationBillingCreateWithoutOrganizationInput[] | ImageGenerationBillingUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ImageGenerationBillingCreateOrConnectWithoutOrganizationInput | ImageGenerationBillingCreateOrConnectWithoutOrganizationInput[]
    createMany?: ImageGenerationBillingCreateManyOrganizationInputEnvelope
    connect?: ImageGenerationBillingWhereUniqueInput | ImageGenerationBillingWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<InvoiceCreateWithoutOrganizationInput, InvoiceUncheckedCreateWithoutOrganizationInput> | InvoiceCreateWithoutOrganizationInput[] | InvoiceUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrganizationInput | InvoiceCreateOrConnectWithoutOrganizationInput[]
    createMany?: InvoiceCreateManyOrganizationInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LinkPageCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<LinkPageCreateWithoutOrganizationInput, LinkPageUncheckedCreateWithoutOrganizationInput> | LinkPageCreateWithoutOrganizationInput[] | LinkPageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LinkPageCreateOrConnectWithoutOrganizationInput | LinkPageCreateOrConnectWithoutOrganizationInput[]
    createMany?: LinkPageCreateManyOrganizationInputEnvelope
    connect?: LinkPageWhereUniqueInput | LinkPageWhereUniqueInput[]
  }

  export type MediaCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MediaCreateWithoutOrganizationInput, MediaUncheckedCreateWithoutOrganizationInput> | MediaCreateWithoutOrganizationInput[] | MediaUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutOrganizationInput | MediaCreateOrConnectWithoutOrganizationInput[]
    createMany?: MediaCreateManyOrganizationInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type MessagesCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MessagesCreateWithoutOrganizationInput, MessagesUncheckedCreateWithoutOrganizationInput> | MessagesCreateWithoutOrganizationInput[] | MessagesUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutOrganizationInput | MessagesCreateOrConnectWithoutOrganizationInput[]
    createMany?: MessagesCreateManyOrganizationInputEnvelope
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
  }

  export type PageCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<PageCreateWithoutOrganizationInput, PageUncheckedCreateWithoutOrganizationInput> | PageCreateWithoutOrganizationInput[] | PageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PageCreateOrConnectWithoutOrganizationInput | PageCreateOrConnectWithoutOrganizationInput[]
    createMany?: PageCreateManyOrganizationInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SubscriptionCreateWithoutOrganizationInput, SubscriptionUncheckedCreateWithoutOrganizationInput> | SubscriptionCreateWithoutOrganizationInput[] | SubscriptionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutOrganizationInput | SubscriptionCreateOrConnectWithoutOrganizationInput[]
    createMany?: SubscriptionCreateManyOrganizationInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type ThreadCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ThreadCreateWithoutOrganizationInput, ThreadUncheckedCreateWithoutOrganizationInput> | ThreadCreateWithoutOrganizationInput[] | ThreadUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ThreadCreateOrConnectWithoutOrganizationInput | ThreadCreateOrConnectWithoutOrganizationInput[]
    createMany?: ThreadCreateManyOrganizationInputEnvelope
    connect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
  }

  export type UsageCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UsageCreateWithoutOrganizationInput, UsageUncheckedCreateWithoutOrganizationInput> | UsageCreateWithoutOrganizationInput[] | UsageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UsageCreateOrConnectWithoutOrganizationInput | UsageCreateOrConnectWithoutOrganizationInput[]
    createMany?: UsageCreateManyOrganizationInputEnvelope
    connect?: UsageWhereUniqueInput | UsageWhereUniqueInput[]
  }

  export type UserOrganizationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserOrganizationCreateWithoutOrganizationInput, UserOrganizationUncheckedCreateWithoutOrganizationInput> | UserOrganizationCreateWithoutOrganizationInput[] | UserOrganizationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserOrganizationCreateOrConnectWithoutOrganizationInput | UserOrganizationCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserOrganizationCreateManyOrganizationInputEnvelope
    connect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
  }

  export type UsersCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UsersCreateWithoutOrganizationInput, UsersUncheckedCreateWithoutOrganizationInput> | UsersCreateWithoutOrganizationInput[] | UsersUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutOrganizationInput | UsersCreateOrConnectWithoutOrganizationInput[]
    createMany?: UsersCreateManyOrganizationInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type authorCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<authorCreateWithoutOrganizationInput, authorUncheckedCreateWithoutOrganizationInput> | authorCreateWithoutOrganizationInput[] | authorUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: authorCreateOrConnectWithoutOrganizationInput | authorCreateOrConnectWithoutOrganizationInput[]
    createMany?: authorCreateManyOrganizationInputEnvelope
    connect?: authorWhereUniqueInput | authorWhereUniqueInput[]
  }

  export type form_fieldCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<form_fieldCreateWithoutOrganizationInput, form_fieldUncheckedCreateWithoutOrganizationInput> | form_fieldCreateWithoutOrganizationInput[] | form_fieldUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: form_fieldCreateOrConnectWithoutOrganizationInput | form_fieldCreateOrConnectWithoutOrganizationInput[]
    createMany?: form_fieldCreateManyOrganizationInputEnvelope
    connect?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
  }

  export type org_detailsCreateNestedOneWithoutOrganizationInput = {
    create?: XOR<org_detailsCreateWithoutOrganizationInput, org_detailsUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: org_detailsCreateOrConnectWithoutOrganizationInput
    connect?: org_detailsWhereUniqueInput
  }

  export type structCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<structCreateWithoutOrganizationInput, structUncheckedCreateWithoutOrganizationInput> | structCreateWithoutOrganizationInput[] | structUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: structCreateOrConnectWithoutOrganizationInput | structCreateOrConnectWithoutOrganizationInput[]
    createMany?: structCreateManyOrganizationInputEnvelope
    connect?: structWhereUniqueInput | structWhereUniqueInput[]
  }

  export type struct_setCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<struct_setCreateWithoutOrganizationInput, struct_setUncheckedCreateWithoutOrganizationInput> | struct_setCreateWithoutOrganizationInput[] | struct_setUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: struct_setCreateOrConnectWithoutOrganizationInput | struct_setCreateOrConnectWithoutOrganizationInput[]
    createMany?: struct_setCreateManyOrganizationInputEnvelope
    connect?: struct_setWhereUniqueInput | struct_setWhereUniqueInput[]
  }

  export type struct_set_instanceCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<struct_set_instanceCreateWithoutOrganizationInput, struct_set_instanceUncheckedCreateWithoutOrganizationInput> | struct_set_instanceCreateWithoutOrganizationInput[] | struct_set_instanceUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: struct_set_instanceCreateOrConnectWithoutOrganizationInput | struct_set_instanceCreateOrConnectWithoutOrganizationInput[]
    createMany?: struct_set_instanceCreateManyOrganizationInputEnvelope
    connect?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<CategoryCreateWithoutOrganizationInput, CategoryUncheckedCreateWithoutOrganizationInput> | CategoryCreateWithoutOrganizationInput[] | CategoryUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutOrganizationInput | CategoryCreateOrConnectWithoutOrganizationInput[]
    createMany?: CategoryCreateManyOrganizationInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type CollectionUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<CollectionCreateWithoutOrganizationInput, CollectionUncheckedCreateWithoutOrganizationInput> | CollectionCreateWithoutOrganizationInput[] | CollectionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutOrganizationInput | CollectionCreateOrConnectWithoutOrganizationInput[]
    createMany?: CollectionCreateManyOrganizationInputEnvelope
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<CommentCreateWithoutOrganizationInput, CommentUncheckedCreateWithoutOrganizationInput> | CommentCreateWithoutOrganizationInput[] | CommentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutOrganizationInput | CommentCreateOrConnectWithoutOrganizationInput[]
    createMany?: CommentCreateManyOrganizationInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<CompletionUsageCreateWithoutOrganizationInput, CompletionUsageUncheckedCreateWithoutOrganizationInput> | CompletionUsageCreateWithoutOrganizationInput[] | CompletionUsageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CompletionUsageCreateOrConnectWithoutOrganizationInput | CompletionUsageCreateOrConnectWithoutOrganizationInput[]
    createMany?: CompletionUsageCreateManyOrganizationInputEnvelope
    connect?: CompletionUsageWhereUniqueInput | CompletionUsageWhereUniqueInput[]
  }

  export type ContentUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ContentCreateWithoutOrganizationInput, ContentUncheckedCreateWithoutOrganizationInput> | ContentCreateWithoutOrganizationInput[] | ContentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutOrganizationInput | ContentCreateOrConnectWithoutOrganizationInput[]
    createMany?: ContentCreateManyOrganizationInputEnvelope
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ImageGenerationBillingCreateWithoutOrganizationInput, ImageGenerationBillingUncheckedCreateWithoutOrganizationInput> | ImageGenerationBillingCreateWithoutOrganizationInput[] | ImageGenerationBillingUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ImageGenerationBillingCreateOrConnectWithoutOrganizationInput | ImageGenerationBillingCreateOrConnectWithoutOrganizationInput[]
    createMany?: ImageGenerationBillingCreateManyOrganizationInputEnvelope
    connect?: ImageGenerationBillingWhereUniqueInput | ImageGenerationBillingWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<InvoiceCreateWithoutOrganizationInput, InvoiceUncheckedCreateWithoutOrganizationInput> | InvoiceCreateWithoutOrganizationInput[] | InvoiceUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrganizationInput | InvoiceCreateOrConnectWithoutOrganizationInput[]
    createMany?: InvoiceCreateManyOrganizationInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LinkPageUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<LinkPageCreateWithoutOrganizationInput, LinkPageUncheckedCreateWithoutOrganizationInput> | LinkPageCreateWithoutOrganizationInput[] | LinkPageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LinkPageCreateOrConnectWithoutOrganizationInput | LinkPageCreateOrConnectWithoutOrganizationInput[]
    createMany?: LinkPageCreateManyOrganizationInputEnvelope
    connect?: LinkPageWhereUniqueInput | LinkPageWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MediaCreateWithoutOrganizationInput, MediaUncheckedCreateWithoutOrganizationInput> | MediaCreateWithoutOrganizationInput[] | MediaUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutOrganizationInput | MediaCreateOrConnectWithoutOrganizationInput[]
    createMany?: MediaCreateManyOrganizationInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type MessagesUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MessagesCreateWithoutOrganizationInput, MessagesUncheckedCreateWithoutOrganizationInput> | MessagesCreateWithoutOrganizationInput[] | MessagesUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutOrganizationInput | MessagesCreateOrConnectWithoutOrganizationInput[]
    createMany?: MessagesCreateManyOrganizationInputEnvelope
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
  }

  export type PageUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<PageCreateWithoutOrganizationInput, PageUncheckedCreateWithoutOrganizationInput> | PageCreateWithoutOrganizationInput[] | PageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PageCreateOrConnectWithoutOrganizationInput | PageCreateOrConnectWithoutOrganizationInput[]
    createMany?: PageCreateManyOrganizationInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SubscriptionCreateWithoutOrganizationInput, SubscriptionUncheckedCreateWithoutOrganizationInput> | SubscriptionCreateWithoutOrganizationInput[] | SubscriptionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutOrganizationInput | SubscriptionCreateOrConnectWithoutOrganizationInput[]
    createMany?: SubscriptionCreateManyOrganizationInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type ThreadUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ThreadCreateWithoutOrganizationInput, ThreadUncheckedCreateWithoutOrganizationInput> | ThreadCreateWithoutOrganizationInput[] | ThreadUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ThreadCreateOrConnectWithoutOrganizationInput | ThreadCreateOrConnectWithoutOrganizationInput[]
    createMany?: ThreadCreateManyOrganizationInputEnvelope
    connect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
  }

  export type UsageUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UsageCreateWithoutOrganizationInput, UsageUncheckedCreateWithoutOrganizationInput> | UsageCreateWithoutOrganizationInput[] | UsageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UsageCreateOrConnectWithoutOrganizationInput | UsageCreateOrConnectWithoutOrganizationInput[]
    createMany?: UsageCreateManyOrganizationInputEnvelope
    connect?: UsageWhereUniqueInput | UsageWhereUniqueInput[]
  }

  export type UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserOrganizationCreateWithoutOrganizationInput, UserOrganizationUncheckedCreateWithoutOrganizationInput> | UserOrganizationCreateWithoutOrganizationInput[] | UserOrganizationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserOrganizationCreateOrConnectWithoutOrganizationInput | UserOrganizationCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserOrganizationCreateManyOrganizationInputEnvelope
    connect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
  }

  export type UsersUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UsersCreateWithoutOrganizationInput, UsersUncheckedCreateWithoutOrganizationInput> | UsersCreateWithoutOrganizationInput[] | UsersUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutOrganizationInput | UsersCreateOrConnectWithoutOrganizationInput[]
    createMany?: UsersCreateManyOrganizationInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type authorUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<authorCreateWithoutOrganizationInput, authorUncheckedCreateWithoutOrganizationInput> | authorCreateWithoutOrganizationInput[] | authorUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: authorCreateOrConnectWithoutOrganizationInput | authorCreateOrConnectWithoutOrganizationInput[]
    createMany?: authorCreateManyOrganizationInputEnvelope
    connect?: authorWhereUniqueInput | authorWhereUniqueInput[]
  }

  export type form_fieldUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<form_fieldCreateWithoutOrganizationInput, form_fieldUncheckedCreateWithoutOrganizationInput> | form_fieldCreateWithoutOrganizationInput[] | form_fieldUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: form_fieldCreateOrConnectWithoutOrganizationInput | form_fieldCreateOrConnectWithoutOrganizationInput[]
    createMany?: form_fieldCreateManyOrganizationInputEnvelope
    connect?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
  }

  export type org_detailsUncheckedCreateNestedOneWithoutOrganizationInput = {
    create?: XOR<org_detailsCreateWithoutOrganizationInput, org_detailsUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: org_detailsCreateOrConnectWithoutOrganizationInput
    connect?: org_detailsWhereUniqueInput
  }

  export type structUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<structCreateWithoutOrganizationInput, structUncheckedCreateWithoutOrganizationInput> | structCreateWithoutOrganizationInput[] | structUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: structCreateOrConnectWithoutOrganizationInput | structCreateOrConnectWithoutOrganizationInput[]
    createMany?: structCreateManyOrganizationInputEnvelope
    connect?: structWhereUniqueInput | structWhereUniqueInput[]
  }

  export type struct_setUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<struct_setCreateWithoutOrganizationInput, struct_setUncheckedCreateWithoutOrganizationInput> | struct_setCreateWithoutOrganizationInput[] | struct_setUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: struct_setCreateOrConnectWithoutOrganizationInput | struct_setCreateOrConnectWithoutOrganizationInput[]
    createMany?: struct_setCreateManyOrganizationInputEnvelope
    connect?: struct_setWhereUniqueInput | struct_setWhereUniqueInput[]
  }

  export type struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<struct_set_instanceCreateWithoutOrganizationInput, struct_set_instanceUncheckedCreateWithoutOrganizationInput> | struct_set_instanceCreateWithoutOrganizationInput[] | struct_set_instanceUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: struct_set_instanceCreateOrConnectWithoutOrganizationInput | struct_set_instanceCreateOrConnectWithoutOrganizationInput[]
    createMany?: struct_set_instanceCreateManyOrganizationInputEnvelope
    connect?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
  }

  export type CategoryUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<CategoryCreateWithoutOrganizationInput, CategoryUncheckedCreateWithoutOrganizationInput> | CategoryCreateWithoutOrganizationInput[] | CategoryUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutOrganizationInput | CategoryCreateOrConnectWithoutOrganizationInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutOrganizationInput | CategoryUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: CategoryCreateManyOrganizationInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutOrganizationInput | CategoryUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutOrganizationInput | CategoryUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type CollectionUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<CollectionCreateWithoutOrganizationInput, CollectionUncheckedCreateWithoutOrganizationInput> | CollectionCreateWithoutOrganizationInput[] | CollectionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutOrganizationInput | CollectionCreateOrConnectWithoutOrganizationInput[]
    upsert?: CollectionUpsertWithWhereUniqueWithoutOrganizationInput | CollectionUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: CollectionCreateManyOrganizationInputEnvelope
    set?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    disconnect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    delete?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    update?: CollectionUpdateWithWhereUniqueWithoutOrganizationInput | CollectionUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: CollectionUpdateManyWithWhereWithoutOrganizationInput | CollectionUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: CollectionScalarWhereInput | CollectionScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<CommentCreateWithoutOrganizationInput, CommentUncheckedCreateWithoutOrganizationInput> | CommentCreateWithoutOrganizationInput[] | CommentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutOrganizationInput | CommentCreateOrConnectWithoutOrganizationInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutOrganizationInput | CommentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: CommentCreateManyOrganizationInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutOrganizationInput | CommentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutOrganizationInput | CommentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CompletionUsageUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<CompletionUsageCreateWithoutOrganizationInput, CompletionUsageUncheckedCreateWithoutOrganizationInput> | CompletionUsageCreateWithoutOrganizationInput[] | CompletionUsageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CompletionUsageCreateOrConnectWithoutOrganizationInput | CompletionUsageCreateOrConnectWithoutOrganizationInput[]
    upsert?: CompletionUsageUpsertWithWhereUniqueWithoutOrganizationInput | CompletionUsageUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: CompletionUsageCreateManyOrganizationInputEnvelope
    set?: CompletionUsageWhereUniqueInput | CompletionUsageWhereUniqueInput[]
    disconnect?: CompletionUsageWhereUniqueInput | CompletionUsageWhereUniqueInput[]
    delete?: CompletionUsageWhereUniqueInput | CompletionUsageWhereUniqueInput[]
    connect?: CompletionUsageWhereUniqueInput | CompletionUsageWhereUniqueInput[]
    update?: CompletionUsageUpdateWithWhereUniqueWithoutOrganizationInput | CompletionUsageUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: CompletionUsageUpdateManyWithWhereWithoutOrganizationInput | CompletionUsageUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: CompletionUsageScalarWhereInput | CompletionUsageScalarWhereInput[]
  }

  export type ContentUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ContentCreateWithoutOrganizationInput, ContentUncheckedCreateWithoutOrganizationInput> | ContentCreateWithoutOrganizationInput[] | ContentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutOrganizationInput | ContentCreateOrConnectWithoutOrganizationInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutOrganizationInput | ContentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ContentCreateManyOrganizationInputEnvelope
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutOrganizationInput | ContentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutOrganizationInput | ContentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ImageGenerationBillingCreateWithoutOrganizationInput, ImageGenerationBillingUncheckedCreateWithoutOrganizationInput> | ImageGenerationBillingCreateWithoutOrganizationInput[] | ImageGenerationBillingUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ImageGenerationBillingCreateOrConnectWithoutOrganizationInput | ImageGenerationBillingCreateOrConnectWithoutOrganizationInput[]
    upsert?: ImageGenerationBillingUpsertWithWhereUniqueWithoutOrganizationInput | ImageGenerationBillingUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ImageGenerationBillingCreateManyOrganizationInputEnvelope
    set?: ImageGenerationBillingWhereUniqueInput | ImageGenerationBillingWhereUniqueInput[]
    disconnect?: ImageGenerationBillingWhereUniqueInput | ImageGenerationBillingWhereUniqueInput[]
    delete?: ImageGenerationBillingWhereUniqueInput | ImageGenerationBillingWhereUniqueInput[]
    connect?: ImageGenerationBillingWhereUniqueInput | ImageGenerationBillingWhereUniqueInput[]
    update?: ImageGenerationBillingUpdateWithWhereUniqueWithoutOrganizationInput | ImageGenerationBillingUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ImageGenerationBillingUpdateManyWithWhereWithoutOrganizationInput | ImageGenerationBillingUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ImageGenerationBillingScalarWhereInput | ImageGenerationBillingScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrganizationInput, InvoiceUncheckedCreateWithoutOrganizationInput> | InvoiceCreateWithoutOrganizationInput[] | InvoiceUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrganizationInput | InvoiceCreateOrConnectWithoutOrganizationInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutOrganizationInput | InvoiceUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: InvoiceCreateManyOrganizationInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutOrganizationInput | InvoiceUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutOrganizationInput | InvoiceUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LinkPageUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<LinkPageCreateWithoutOrganizationInput, LinkPageUncheckedCreateWithoutOrganizationInput> | LinkPageCreateWithoutOrganizationInput[] | LinkPageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LinkPageCreateOrConnectWithoutOrganizationInput | LinkPageCreateOrConnectWithoutOrganizationInput[]
    upsert?: LinkPageUpsertWithWhereUniqueWithoutOrganizationInput | LinkPageUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: LinkPageCreateManyOrganizationInputEnvelope
    set?: LinkPageWhereUniqueInput | LinkPageWhereUniqueInput[]
    disconnect?: LinkPageWhereUniqueInput | LinkPageWhereUniqueInput[]
    delete?: LinkPageWhereUniqueInput | LinkPageWhereUniqueInput[]
    connect?: LinkPageWhereUniqueInput | LinkPageWhereUniqueInput[]
    update?: LinkPageUpdateWithWhereUniqueWithoutOrganizationInput | LinkPageUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: LinkPageUpdateManyWithWhereWithoutOrganizationInput | LinkPageUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: LinkPageScalarWhereInput | LinkPageScalarWhereInput[]
  }

  export type MediaUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MediaCreateWithoutOrganizationInput, MediaUncheckedCreateWithoutOrganizationInput> | MediaCreateWithoutOrganizationInput[] | MediaUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutOrganizationInput | MediaCreateOrConnectWithoutOrganizationInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutOrganizationInput | MediaUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MediaCreateManyOrganizationInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutOrganizationInput | MediaUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutOrganizationInput | MediaUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type MessagesUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MessagesCreateWithoutOrganizationInput, MessagesUncheckedCreateWithoutOrganizationInput> | MessagesCreateWithoutOrganizationInput[] | MessagesUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutOrganizationInput | MessagesCreateOrConnectWithoutOrganizationInput[]
    upsert?: MessagesUpsertWithWhereUniqueWithoutOrganizationInput | MessagesUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MessagesCreateManyOrganizationInputEnvelope
    set?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    disconnect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    delete?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    update?: MessagesUpdateWithWhereUniqueWithoutOrganizationInput | MessagesUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MessagesUpdateManyWithWhereWithoutOrganizationInput | MessagesUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
  }

  export type PageUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<PageCreateWithoutOrganizationInput, PageUncheckedCreateWithoutOrganizationInput> | PageCreateWithoutOrganizationInput[] | PageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PageCreateOrConnectWithoutOrganizationInput | PageCreateOrConnectWithoutOrganizationInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutOrganizationInput | PageUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: PageCreateManyOrganizationInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutOrganizationInput | PageUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: PageUpdateManyWithWhereWithoutOrganizationInput | PageUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SubscriptionCreateWithoutOrganizationInput, SubscriptionUncheckedCreateWithoutOrganizationInput> | SubscriptionCreateWithoutOrganizationInput[] | SubscriptionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutOrganizationInput | SubscriptionCreateOrConnectWithoutOrganizationInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutOrganizationInput | SubscriptionUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SubscriptionCreateManyOrganizationInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutOrganizationInput | SubscriptionUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutOrganizationInput | SubscriptionUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type ThreadUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ThreadCreateWithoutOrganizationInput, ThreadUncheckedCreateWithoutOrganizationInput> | ThreadCreateWithoutOrganizationInput[] | ThreadUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ThreadCreateOrConnectWithoutOrganizationInput | ThreadCreateOrConnectWithoutOrganizationInput[]
    upsert?: ThreadUpsertWithWhereUniqueWithoutOrganizationInput | ThreadUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ThreadCreateManyOrganizationInputEnvelope
    set?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    disconnect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    delete?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    connect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    update?: ThreadUpdateWithWhereUniqueWithoutOrganizationInput | ThreadUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ThreadUpdateManyWithWhereWithoutOrganizationInput | ThreadUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ThreadScalarWhereInput | ThreadScalarWhereInput[]
  }

  export type UsageUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UsageCreateWithoutOrganizationInput, UsageUncheckedCreateWithoutOrganizationInput> | UsageCreateWithoutOrganizationInput[] | UsageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UsageCreateOrConnectWithoutOrganizationInput | UsageCreateOrConnectWithoutOrganizationInput[]
    upsert?: UsageUpsertWithWhereUniqueWithoutOrganizationInput | UsageUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UsageCreateManyOrganizationInputEnvelope
    set?: UsageWhereUniqueInput | UsageWhereUniqueInput[]
    disconnect?: UsageWhereUniqueInput | UsageWhereUniqueInput[]
    delete?: UsageWhereUniqueInput | UsageWhereUniqueInput[]
    connect?: UsageWhereUniqueInput | UsageWhereUniqueInput[]
    update?: UsageUpdateWithWhereUniqueWithoutOrganizationInput | UsageUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UsageUpdateManyWithWhereWithoutOrganizationInput | UsageUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UsageScalarWhereInput | UsageScalarWhereInput[]
  }

  export type UserOrganizationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserOrganizationCreateWithoutOrganizationInput, UserOrganizationUncheckedCreateWithoutOrganizationInput> | UserOrganizationCreateWithoutOrganizationInput[] | UserOrganizationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserOrganizationCreateOrConnectWithoutOrganizationInput | UserOrganizationCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserOrganizationUpsertWithWhereUniqueWithoutOrganizationInput | UserOrganizationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserOrganizationCreateManyOrganizationInputEnvelope
    set?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    disconnect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    delete?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    connect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    update?: UserOrganizationUpdateWithWhereUniqueWithoutOrganizationInput | UserOrganizationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserOrganizationUpdateManyWithWhereWithoutOrganizationInput | UserOrganizationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserOrganizationScalarWhereInput | UserOrganizationScalarWhereInput[]
  }

  export type UsersUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UsersCreateWithoutOrganizationInput, UsersUncheckedCreateWithoutOrganizationInput> | UsersCreateWithoutOrganizationInput[] | UsersUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutOrganizationInput | UsersCreateOrConnectWithoutOrganizationInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutOrganizationInput | UsersUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UsersCreateManyOrganizationInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutOrganizationInput | UsersUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutOrganizationInput | UsersUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type authorUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<authorCreateWithoutOrganizationInput, authorUncheckedCreateWithoutOrganizationInput> | authorCreateWithoutOrganizationInput[] | authorUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: authorCreateOrConnectWithoutOrganizationInput | authorCreateOrConnectWithoutOrganizationInput[]
    upsert?: authorUpsertWithWhereUniqueWithoutOrganizationInput | authorUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: authorCreateManyOrganizationInputEnvelope
    set?: authorWhereUniqueInput | authorWhereUniqueInput[]
    disconnect?: authorWhereUniqueInput | authorWhereUniqueInput[]
    delete?: authorWhereUniqueInput | authorWhereUniqueInput[]
    connect?: authorWhereUniqueInput | authorWhereUniqueInput[]
    update?: authorUpdateWithWhereUniqueWithoutOrganizationInput | authorUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: authorUpdateManyWithWhereWithoutOrganizationInput | authorUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: authorScalarWhereInput | authorScalarWhereInput[]
  }

  export type form_fieldUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<form_fieldCreateWithoutOrganizationInput, form_fieldUncheckedCreateWithoutOrganizationInput> | form_fieldCreateWithoutOrganizationInput[] | form_fieldUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: form_fieldCreateOrConnectWithoutOrganizationInput | form_fieldCreateOrConnectWithoutOrganizationInput[]
    upsert?: form_fieldUpsertWithWhereUniqueWithoutOrganizationInput | form_fieldUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: form_fieldCreateManyOrganizationInputEnvelope
    set?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    disconnect?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    delete?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    connect?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    update?: form_fieldUpdateWithWhereUniqueWithoutOrganizationInput | form_fieldUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: form_fieldUpdateManyWithWhereWithoutOrganizationInput | form_fieldUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: form_fieldScalarWhereInput | form_fieldScalarWhereInput[]
  }

  export type org_detailsUpdateOneWithoutOrganizationNestedInput = {
    create?: XOR<org_detailsCreateWithoutOrganizationInput, org_detailsUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: org_detailsCreateOrConnectWithoutOrganizationInput
    upsert?: org_detailsUpsertWithoutOrganizationInput
    disconnect?: org_detailsWhereInput | boolean
    delete?: org_detailsWhereInput | boolean
    connect?: org_detailsWhereUniqueInput
    update?: XOR<XOR<org_detailsUpdateToOneWithWhereWithoutOrganizationInput, org_detailsUpdateWithoutOrganizationInput>, org_detailsUncheckedUpdateWithoutOrganizationInput>
  }

  export type structUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<structCreateWithoutOrganizationInput, structUncheckedCreateWithoutOrganizationInput> | structCreateWithoutOrganizationInput[] | structUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: structCreateOrConnectWithoutOrganizationInput | structCreateOrConnectWithoutOrganizationInput[]
    upsert?: structUpsertWithWhereUniqueWithoutOrganizationInput | structUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: structCreateManyOrganizationInputEnvelope
    set?: structWhereUniqueInput | structWhereUniqueInput[]
    disconnect?: structWhereUniqueInput | structWhereUniqueInput[]
    delete?: structWhereUniqueInput | structWhereUniqueInput[]
    connect?: structWhereUniqueInput | structWhereUniqueInput[]
    update?: structUpdateWithWhereUniqueWithoutOrganizationInput | structUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: structUpdateManyWithWhereWithoutOrganizationInput | structUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: structScalarWhereInput | structScalarWhereInput[]
  }

  export type struct_setUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<struct_setCreateWithoutOrganizationInput, struct_setUncheckedCreateWithoutOrganizationInput> | struct_setCreateWithoutOrganizationInput[] | struct_setUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: struct_setCreateOrConnectWithoutOrganizationInput | struct_setCreateOrConnectWithoutOrganizationInput[]
    upsert?: struct_setUpsertWithWhereUniqueWithoutOrganizationInput | struct_setUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: struct_setCreateManyOrganizationInputEnvelope
    set?: struct_setWhereUniqueInput | struct_setWhereUniqueInput[]
    disconnect?: struct_setWhereUniqueInput | struct_setWhereUniqueInput[]
    delete?: struct_setWhereUniqueInput | struct_setWhereUniqueInput[]
    connect?: struct_setWhereUniqueInput | struct_setWhereUniqueInput[]
    update?: struct_setUpdateWithWhereUniqueWithoutOrganizationInput | struct_setUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: struct_setUpdateManyWithWhereWithoutOrganizationInput | struct_setUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: struct_setScalarWhereInput | struct_setScalarWhereInput[]
  }

  export type struct_set_instanceUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<struct_set_instanceCreateWithoutOrganizationInput, struct_set_instanceUncheckedCreateWithoutOrganizationInput> | struct_set_instanceCreateWithoutOrganizationInput[] | struct_set_instanceUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: struct_set_instanceCreateOrConnectWithoutOrganizationInput | struct_set_instanceCreateOrConnectWithoutOrganizationInput[]
    upsert?: struct_set_instanceUpsertWithWhereUniqueWithoutOrganizationInput | struct_set_instanceUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: struct_set_instanceCreateManyOrganizationInputEnvelope
    set?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    disconnect?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    delete?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    connect?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    update?: struct_set_instanceUpdateWithWhereUniqueWithoutOrganizationInput | struct_set_instanceUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: struct_set_instanceUpdateManyWithWhereWithoutOrganizationInput | struct_set_instanceUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: struct_set_instanceScalarWhereInput | struct_set_instanceScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<CategoryCreateWithoutOrganizationInput, CategoryUncheckedCreateWithoutOrganizationInput> | CategoryCreateWithoutOrganizationInput[] | CategoryUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutOrganizationInput | CategoryCreateOrConnectWithoutOrganizationInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutOrganizationInput | CategoryUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: CategoryCreateManyOrganizationInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutOrganizationInput | CategoryUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutOrganizationInput | CategoryUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type CollectionUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<CollectionCreateWithoutOrganizationInput, CollectionUncheckedCreateWithoutOrganizationInput> | CollectionCreateWithoutOrganizationInput[] | CollectionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutOrganizationInput | CollectionCreateOrConnectWithoutOrganizationInput[]
    upsert?: CollectionUpsertWithWhereUniqueWithoutOrganizationInput | CollectionUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: CollectionCreateManyOrganizationInputEnvelope
    set?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    disconnect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    delete?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    update?: CollectionUpdateWithWhereUniqueWithoutOrganizationInput | CollectionUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: CollectionUpdateManyWithWhereWithoutOrganizationInput | CollectionUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: CollectionScalarWhereInput | CollectionScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<CommentCreateWithoutOrganizationInput, CommentUncheckedCreateWithoutOrganizationInput> | CommentCreateWithoutOrganizationInput[] | CommentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutOrganizationInput | CommentCreateOrConnectWithoutOrganizationInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutOrganizationInput | CommentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: CommentCreateManyOrganizationInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutOrganizationInput | CommentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutOrganizationInput | CommentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<CompletionUsageCreateWithoutOrganizationInput, CompletionUsageUncheckedCreateWithoutOrganizationInput> | CompletionUsageCreateWithoutOrganizationInput[] | CompletionUsageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CompletionUsageCreateOrConnectWithoutOrganizationInput | CompletionUsageCreateOrConnectWithoutOrganizationInput[]
    upsert?: CompletionUsageUpsertWithWhereUniqueWithoutOrganizationInput | CompletionUsageUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: CompletionUsageCreateManyOrganizationInputEnvelope
    set?: CompletionUsageWhereUniqueInput | CompletionUsageWhereUniqueInput[]
    disconnect?: CompletionUsageWhereUniqueInput | CompletionUsageWhereUniqueInput[]
    delete?: CompletionUsageWhereUniqueInput | CompletionUsageWhereUniqueInput[]
    connect?: CompletionUsageWhereUniqueInput | CompletionUsageWhereUniqueInput[]
    update?: CompletionUsageUpdateWithWhereUniqueWithoutOrganizationInput | CompletionUsageUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: CompletionUsageUpdateManyWithWhereWithoutOrganizationInput | CompletionUsageUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: CompletionUsageScalarWhereInput | CompletionUsageScalarWhereInput[]
  }

  export type ContentUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ContentCreateWithoutOrganizationInput, ContentUncheckedCreateWithoutOrganizationInput> | ContentCreateWithoutOrganizationInput[] | ContentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutOrganizationInput | ContentCreateOrConnectWithoutOrganizationInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutOrganizationInput | ContentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ContentCreateManyOrganizationInputEnvelope
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutOrganizationInput | ContentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutOrganizationInput | ContentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ImageGenerationBillingCreateWithoutOrganizationInput, ImageGenerationBillingUncheckedCreateWithoutOrganizationInput> | ImageGenerationBillingCreateWithoutOrganizationInput[] | ImageGenerationBillingUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ImageGenerationBillingCreateOrConnectWithoutOrganizationInput | ImageGenerationBillingCreateOrConnectWithoutOrganizationInput[]
    upsert?: ImageGenerationBillingUpsertWithWhereUniqueWithoutOrganizationInput | ImageGenerationBillingUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ImageGenerationBillingCreateManyOrganizationInputEnvelope
    set?: ImageGenerationBillingWhereUniqueInput | ImageGenerationBillingWhereUniqueInput[]
    disconnect?: ImageGenerationBillingWhereUniqueInput | ImageGenerationBillingWhereUniqueInput[]
    delete?: ImageGenerationBillingWhereUniqueInput | ImageGenerationBillingWhereUniqueInput[]
    connect?: ImageGenerationBillingWhereUniqueInput | ImageGenerationBillingWhereUniqueInput[]
    update?: ImageGenerationBillingUpdateWithWhereUniqueWithoutOrganizationInput | ImageGenerationBillingUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ImageGenerationBillingUpdateManyWithWhereWithoutOrganizationInput | ImageGenerationBillingUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ImageGenerationBillingScalarWhereInput | ImageGenerationBillingScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrganizationInput, InvoiceUncheckedCreateWithoutOrganizationInput> | InvoiceCreateWithoutOrganizationInput[] | InvoiceUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrganizationInput | InvoiceCreateOrConnectWithoutOrganizationInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutOrganizationInput | InvoiceUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: InvoiceCreateManyOrganizationInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutOrganizationInput | InvoiceUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutOrganizationInput | InvoiceUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<LinkPageCreateWithoutOrganizationInput, LinkPageUncheckedCreateWithoutOrganizationInput> | LinkPageCreateWithoutOrganizationInput[] | LinkPageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LinkPageCreateOrConnectWithoutOrganizationInput | LinkPageCreateOrConnectWithoutOrganizationInput[]
    upsert?: LinkPageUpsertWithWhereUniqueWithoutOrganizationInput | LinkPageUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: LinkPageCreateManyOrganizationInputEnvelope
    set?: LinkPageWhereUniqueInput | LinkPageWhereUniqueInput[]
    disconnect?: LinkPageWhereUniqueInput | LinkPageWhereUniqueInput[]
    delete?: LinkPageWhereUniqueInput | LinkPageWhereUniqueInput[]
    connect?: LinkPageWhereUniqueInput | LinkPageWhereUniqueInput[]
    update?: LinkPageUpdateWithWhereUniqueWithoutOrganizationInput | LinkPageUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: LinkPageUpdateManyWithWhereWithoutOrganizationInput | LinkPageUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: LinkPageScalarWhereInput | LinkPageScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MediaCreateWithoutOrganizationInput, MediaUncheckedCreateWithoutOrganizationInput> | MediaCreateWithoutOrganizationInput[] | MediaUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutOrganizationInput | MediaCreateOrConnectWithoutOrganizationInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutOrganizationInput | MediaUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MediaCreateManyOrganizationInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutOrganizationInput | MediaUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutOrganizationInput | MediaUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type MessagesUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MessagesCreateWithoutOrganizationInput, MessagesUncheckedCreateWithoutOrganizationInput> | MessagesCreateWithoutOrganizationInput[] | MessagesUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutOrganizationInput | MessagesCreateOrConnectWithoutOrganizationInput[]
    upsert?: MessagesUpsertWithWhereUniqueWithoutOrganizationInput | MessagesUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MessagesCreateManyOrganizationInputEnvelope
    set?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    disconnect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    delete?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    update?: MessagesUpdateWithWhereUniqueWithoutOrganizationInput | MessagesUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MessagesUpdateManyWithWhereWithoutOrganizationInput | MessagesUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
  }

  export type PageUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<PageCreateWithoutOrganizationInput, PageUncheckedCreateWithoutOrganizationInput> | PageCreateWithoutOrganizationInput[] | PageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PageCreateOrConnectWithoutOrganizationInput | PageCreateOrConnectWithoutOrganizationInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutOrganizationInput | PageUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: PageCreateManyOrganizationInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutOrganizationInput | PageUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: PageUpdateManyWithWhereWithoutOrganizationInput | PageUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SubscriptionCreateWithoutOrganizationInput, SubscriptionUncheckedCreateWithoutOrganizationInput> | SubscriptionCreateWithoutOrganizationInput[] | SubscriptionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutOrganizationInput | SubscriptionCreateOrConnectWithoutOrganizationInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutOrganizationInput | SubscriptionUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SubscriptionCreateManyOrganizationInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutOrganizationInput | SubscriptionUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutOrganizationInput | SubscriptionUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type ThreadUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ThreadCreateWithoutOrganizationInput, ThreadUncheckedCreateWithoutOrganizationInput> | ThreadCreateWithoutOrganizationInput[] | ThreadUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ThreadCreateOrConnectWithoutOrganizationInput | ThreadCreateOrConnectWithoutOrganizationInput[]
    upsert?: ThreadUpsertWithWhereUniqueWithoutOrganizationInput | ThreadUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ThreadCreateManyOrganizationInputEnvelope
    set?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    disconnect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    delete?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    connect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    update?: ThreadUpdateWithWhereUniqueWithoutOrganizationInput | ThreadUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ThreadUpdateManyWithWhereWithoutOrganizationInput | ThreadUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ThreadScalarWhereInput | ThreadScalarWhereInput[]
  }

  export type UsageUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UsageCreateWithoutOrganizationInput, UsageUncheckedCreateWithoutOrganizationInput> | UsageCreateWithoutOrganizationInput[] | UsageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UsageCreateOrConnectWithoutOrganizationInput | UsageCreateOrConnectWithoutOrganizationInput[]
    upsert?: UsageUpsertWithWhereUniqueWithoutOrganizationInput | UsageUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UsageCreateManyOrganizationInputEnvelope
    set?: UsageWhereUniqueInput | UsageWhereUniqueInput[]
    disconnect?: UsageWhereUniqueInput | UsageWhereUniqueInput[]
    delete?: UsageWhereUniqueInput | UsageWhereUniqueInput[]
    connect?: UsageWhereUniqueInput | UsageWhereUniqueInput[]
    update?: UsageUpdateWithWhereUniqueWithoutOrganizationInput | UsageUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UsageUpdateManyWithWhereWithoutOrganizationInput | UsageUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UsageScalarWhereInput | UsageScalarWhereInput[]
  }

  export type UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserOrganizationCreateWithoutOrganizationInput, UserOrganizationUncheckedCreateWithoutOrganizationInput> | UserOrganizationCreateWithoutOrganizationInput[] | UserOrganizationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserOrganizationCreateOrConnectWithoutOrganizationInput | UserOrganizationCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserOrganizationUpsertWithWhereUniqueWithoutOrganizationInput | UserOrganizationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserOrganizationCreateManyOrganizationInputEnvelope
    set?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    disconnect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    delete?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    connect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    update?: UserOrganizationUpdateWithWhereUniqueWithoutOrganizationInput | UserOrganizationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserOrganizationUpdateManyWithWhereWithoutOrganizationInput | UserOrganizationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserOrganizationScalarWhereInput | UserOrganizationScalarWhereInput[]
  }

  export type UsersUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UsersCreateWithoutOrganizationInput, UsersUncheckedCreateWithoutOrganizationInput> | UsersCreateWithoutOrganizationInput[] | UsersUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutOrganizationInput | UsersCreateOrConnectWithoutOrganizationInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutOrganizationInput | UsersUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UsersCreateManyOrganizationInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutOrganizationInput | UsersUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutOrganizationInput | UsersUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type authorUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<authorCreateWithoutOrganizationInput, authorUncheckedCreateWithoutOrganizationInput> | authorCreateWithoutOrganizationInput[] | authorUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: authorCreateOrConnectWithoutOrganizationInput | authorCreateOrConnectWithoutOrganizationInput[]
    upsert?: authorUpsertWithWhereUniqueWithoutOrganizationInput | authorUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: authorCreateManyOrganizationInputEnvelope
    set?: authorWhereUniqueInput | authorWhereUniqueInput[]
    disconnect?: authorWhereUniqueInput | authorWhereUniqueInput[]
    delete?: authorWhereUniqueInput | authorWhereUniqueInput[]
    connect?: authorWhereUniqueInput | authorWhereUniqueInput[]
    update?: authorUpdateWithWhereUniqueWithoutOrganizationInput | authorUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: authorUpdateManyWithWhereWithoutOrganizationInput | authorUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: authorScalarWhereInput | authorScalarWhereInput[]
  }

  export type form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<form_fieldCreateWithoutOrganizationInput, form_fieldUncheckedCreateWithoutOrganizationInput> | form_fieldCreateWithoutOrganizationInput[] | form_fieldUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: form_fieldCreateOrConnectWithoutOrganizationInput | form_fieldCreateOrConnectWithoutOrganizationInput[]
    upsert?: form_fieldUpsertWithWhereUniqueWithoutOrganizationInput | form_fieldUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: form_fieldCreateManyOrganizationInputEnvelope
    set?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    disconnect?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    delete?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    connect?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    update?: form_fieldUpdateWithWhereUniqueWithoutOrganizationInput | form_fieldUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: form_fieldUpdateManyWithWhereWithoutOrganizationInput | form_fieldUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: form_fieldScalarWhereInput | form_fieldScalarWhereInput[]
  }

  export type org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput = {
    create?: XOR<org_detailsCreateWithoutOrganizationInput, org_detailsUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: org_detailsCreateOrConnectWithoutOrganizationInput
    upsert?: org_detailsUpsertWithoutOrganizationInput
    disconnect?: org_detailsWhereInput | boolean
    delete?: org_detailsWhereInput | boolean
    connect?: org_detailsWhereUniqueInput
    update?: XOR<XOR<org_detailsUpdateToOneWithWhereWithoutOrganizationInput, org_detailsUpdateWithoutOrganizationInput>, org_detailsUncheckedUpdateWithoutOrganizationInput>
  }

  export type structUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<structCreateWithoutOrganizationInput, structUncheckedCreateWithoutOrganizationInput> | structCreateWithoutOrganizationInput[] | structUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: structCreateOrConnectWithoutOrganizationInput | structCreateOrConnectWithoutOrganizationInput[]
    upsert?: structUpsertWithWhereUniqueWithoutOrganizationInput | structUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: structCreateManyOrganizationInputEnvelope
    set?: structWhereUniqueInput | structWhereUniqueInput[]
    disconnect?: structWhereUniqueInput | structWhereUniqueInput[]
    delete?: structWhereUniqueInput | structWhereUniqueInput[]
    connect?: structWhereUniqueInput | structWhereUniqueInput[]
    update?: structUpdateWithWhereUniqueWithoutOrganizationInput | structUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: structUpdateManyWithWhereWithoutOrganizationInput | structUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: structScalarWhereInput | structScalarWhereInput[]
  }

  export type struct_setUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<struct_setCreateWithoutOrganizationInput, struct_setUncheckedCreateWithoutOrganizationInput> | struct_setCreateWithoutOrganizationInput[] | struct_setUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: struct_setCreateOrConnectWithoutOrganizationInput | struct_setCreateOrConnectWithoutOrganizationInput[]
    upsert?: struct_setUpsertWithWhereUniqueWithoutOrganizationInput | struct_setUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: struct_setCreateManyOrganizationInputEnvelope
    set?: struct_setWhereUniqueInput | struct_setWhereUniqueInput[]
    disconnect?: struct_setWhereUniqueInput | struct_setWhereUniqueInput[]
    delete?: struct_setWhereUniqueInput | struct_setWhereUniqueInput[]
    connect?: struct_setWhereUniqueInput | struct_setWhereUniqueInput[]
    update?: struct_setUpdateWithWhereUniqueWithoutOrganizationInput | struct_setUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: struct_setUpdateManyWithWhereWithoutOrganizationInput | struct_setUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: struct_setScalarWhereInput | struct_setScalarWhereInput[]
  }

  export type struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<struct_set_instanceCreateWithoutOrganizationInput, struct_set_instanceUncheckedCreateWithoutOrganizationInput> | struct_set_instanceCreateWithoutOrganizationInput[] | struct_set_instanceUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: struct_set_instanceCreateOrConnectWithoutOrganizationInput | struct_set_instanceCreateOrConnectWithoutOrganizationInput[]
    upsert?: struct_set_instanceUpsertWithWhereUniqueWithoutOrganizationInput | struct_set_instanceUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: struct_set_instanceCreateManyOrganizationInputEnvelope
    set?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    disconnect?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    delete?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    connect?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    update?: struct_set_instanceUpdateWithWhereUniqueWithoutOrganizationInput | struct_set_instanceUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: struct_set_instanceUpdateManyWithWhereWithoutOrganizationInput | struct_set_instanceUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: struct_set_instanceScalarWhereInput | struct_set_instanceScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutPageInput = {
    create?: XOR<OrganizationCreateWithoutPageInput, OrganizationUncheckedCreateWithoutPageInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutPageInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutPageNestedInput = {
    create?: XOR<OrganizationCreateWithoutPageInput, OrganizationUncheckedCreateWithoutPageInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutPageInput
    upsert?: OrganizationUpsertWithoutPageInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutPageInput, OrganizationUpdateWithoutPageInput>, OrganizationUncheckedUpdateWithoutPageInput>
  }

  export type ThreadCreateNestedOneWithoutRunInput = {
    create?: XOR<ThreadCreateWithoutRunInput, ThreadUncheckedCreateWithoutRunInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutRunInput
    connect?: ThreadWhereUniqueInput
  }

  export type ThreadMessageCreateNestedManyWithoutRunInput = {
    create?: XOR<ThreadMessageCreateWithoutRunInput, ThreadMessageUncheckedCreateWithoutRunInput> | ThreadMessageCreateWithoutRunInput[] | ThreadMessageUncheckedCreateWithoutRunInput[]
    connectOrCreate?: ThreadMessageCreateOrConnectWithoutRunInput | ThreadMessageCreateOrConnectWithoutRunInput[]
    createMany?: ThreadMessageCreateManyRunInputEnvelope
    connect?: ThreadMessageWhereUniqueInput | ThreadMessageWhereUniqueInput[]
  }

  export type UsageCreateNestedOneWithoutRunInput = {
    create?: XOR<UsageCreateWithoutRunInput, UsageUncheckedCreateWithoutRunInput>
    connectOrCreate?: UsageCreateOrConnectWithoutRunInput
    connect?: UsageWhereUniqueInput
  }

  export type ThreadMessageUncheckedCreateNestedManyWithoutRunInput = {
    create?: XOR<ThreadMessageCreateWithoutRunInput, ThreadMessageUncheckedCreateWithoutRunInput> | ThreadMessageCreateWithoutRunInput[] | ThreadMessageUncheckedCreateWithoutRunInput[]
    connectOrCreate?: ThreadMessageCreateOrConnectWithoutRunInput | ThreadMessageCreateOrConnectWithoutRunInput[]
    createMany?: ThreadMessageCreateManyRunInputEnvelope
    connect?: ThreadMessageWhereUniqueInput | ThreadMessageWhereUniqueInput[]
  }

  export type UsageUncheckedCreateNestedOneWithoutRunInput = {
    create?: XOR<UsageCreateWithoutRunInput, UsageUncheckedCreateWithoutRunInput>
    connectOrCreate?: UsageCreateOrConnectWithoutRunInput
    connect?: UsageWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ThreadUpdateOneRequiredWithoutRunNestedInput = {
    create?: XOR<ThreadCreateWithoutRunInput, ThreadUncheckedCreateWithoutRunInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutRunInput
    upsert?: ThreadUpsertWithoutRunInput
    connect?: ThreadWhereUniqueInput
    update?: XOR<XOR<ThreadUpdateToOneWithWhereWithoutRunInput, ThreadUpdateWithoutRunInput>, ThreadUncheckedUpdateWithoutRunInput>
  }

  export type ThreadMessageUpdateManyWithoutRunNestedInput = {
    create?: XOR<ThreadMessageCreateWithoutRunInput, ThreadMessageUncheckedCreateWithoutRunInput> | ThreadMessageCreateWithoutRunInput[] | ThreadMessageUncheckedCreateWithoutRunInput[]
    connectOrCreate?: ThreadMessageCreateOrConnectWithoutRunInput | ThreadMessageCreateOrConnectWithoutRunInput[]
    upsert?: ThreadMessageUpsertWithWhereUniqueWithoutRunInput | ThreadMessageUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: ThreadMessageCreateManyRunInputEnvelope
    set?: ThreadMessageWhereUniqueInput | ThreadMessageWhereUniqueInput[]
    disconnect?: ThreadMessageWhereUniqueInput | ThreadMessageWhereUniqueInput[]
    delete?: ThreadMessageWhereUniqueInput | ThreadMessageWhereUniqueInput[]
    connect?: ThreadMessageWhereUniqueInput | ThreadMessageWhereUniqueInput[]
    update?: ThreadMessageUpdateWithWhereUniqueWithoutRunInput | ThreadMessageUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: ThreadMessageUpdateManyWithWhereWithoutRunInput | ThreadMessageUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: ThreadMessageScalarWhereInput | ThreadMessageScalarWhereInput[]
  }

  export type UsageUpdateOneWithoutRunNestedInput = {
    create?: XOR<UsageCreateWithoutRunInput, UsageUncheckedCreateWithoutRunInput>
    connectOrCreate?: UsageCreateOrConnectWithoutRunInput
    upsert?: UsageUpsertWithoutRunInput
    disconnect?: UsageWhereInput | boolean
    delete?: UsageWhereInput | boolean
    connect?: UsageWhereUniqueInput
    update?: XOR<XOR<UsageUpdateToOneWithWhereWithoutRunInput, UsageUpdateWithoutRunInput>, UsageUncheckedUpdateWithoutRunInput>
  }

  export type ThreadMessageUncheckedUpdateManyWithoutRunNestedInput = {
    create?: XOR<ThreadMessageCreateWithoutRunInput, ThreadMessageUncheckedCreateWithoutRunInput> | ThreadMessageCreateWithoutRunInput[] | ThreadMessageUncheckedCreateWithoutRunInput[]
    connectOrCreate?: ThreadMessageCreateOrConnectWithoutRunInput | ThreadMessageCreateOrConnectWithoutRunInput[]
    upsert?: ThreadMessageUpsertWithWhereUniqueWithoutRunInput | ThreadMessageUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: ThreadMessageCreateManyRunInputEnvelope
    set?: ThreadMessageWhereUniqueInput | ThreadMessageWhereUniqueInput[]
    disconnect?: ThreadMessageWhereUniqueInput | ThreadMessageWhereUniqueInput[]
    delete?: ThreadMessageWhereUniqueInput | ThreadMessageWhereUniqueInput[]
    connect?: ThreadMessageWhereUniqueInput | ThreadMessageWhereUniqueInput[]
    update?: ThreadMessageUpdateWithWhereUniqueWithoutRunInput | ThreadMessageUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: ThreadMessageUpdateManyWithWhereWithoutRunInput | ThreadMessageUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: ThreadMessageScalarWhereInput | ThreadMessageScalarWhereInput[]
  }

  export type UsageUncheckedUpdateOneWithoutRunNestedInput = {
    create?: XOR<UsageCreateWithoutRunInput, UsageUncheckedCreateWithoutRunInput>
    connectOrCreate?: UsageCreateOrConnectWithoutRunInput
    upsert?: UsageUpsertWithoutRunInput
    disconnect?: UsageWhereInput | boolean
    delete?: UsageWhereInput | boolean
    connect?: UsageWhereUniqueInput
    update?: XOR<XOR<UsageUpdateToOneWithWhereWithoutRunInput, UsageUpdateWithoutRunInput>, UsageUncheckedUpdateWithoutRunInput>
  }

  export type OrganizationCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<OrganizationCreateWithoutSubscriptionInput, OrganizationUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubscriptionInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<OrganizationCreateWithoutSubscriptionInput, OrganizationUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubscriptionInput
    upsert?: OrganizationUpsertWithoutSubscriptionInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutSubscriptionInput, OrganizationUpdateWithoutSubscriptionInput>, OrganizationUncheckedUpdateWithoutSubscriptionInput>
  }

  export type FieldCreateNestedManyWithoutTemplateInput = {
    create?: XOR<FieldCreateWithoutTemplateInput, FieldUncheckedCreateWithoutTemplateInput> | FieldCreateWithoutTemplateInput[] | FieldUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: FieldCreateOrConnectWithoutTemplateInput | FieldCreateOrConnectWithoutTemplateInput[]
    createMany?: FieldCreateManyTemplateInputEnvelope
    connect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
  }

  export type CollectionCreateNestedOneWithoutTemplateInput = {
    create?: XOR<CollectionCreateWithoutTemplateInput, CollectionUncheckedCreateWithoutTemplateInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutTemplateInput
    connect?: CollectionWhereUniqueInput
  }

  export type TemplateInstanceCreateNestedManyWithoutTemplateInput = {
    create?: XOR<TemplateInstanceCreateWithoutTemplateInput, TemplateInstanceUncheckedCreateWithoutTemplateInput> | TemplateInstanceCreateWithoutTemplateInput[] | TemplateInstanceUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplateInstanceCreateOrConnectWithoutTemplateInput | TemplateInstanceCreateOrConnectWithoutTemplateInput[]
    createMany?: TemplateInstanceCreateManyTemplateInputEnvelope
    connect?: TemplateInstanceWhereUniqueInput | TemplateInstanceWhereUniqueInput[]
  }

  export type FieldUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<FieldCreateWithoutTemplateInput, FieldUncheckedCreateWithoutTemplateInput> | FieldCreateWithoutTemplateInput[] | FieldUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: FieldCreateOrConnectWithoutTemplateInput | FieldCreateOrConnectWithoutTemplateInput[]
    createMany?: FieldCreateManyTemplateInputEnvelope
    connect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
  }

  export type TemplateInstanceUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<TemplateInstanceCreateWithoutTemplateInput, TemplateInstanceUncheckedCreateWithoutTemplateInput> | TemplateInstanceCreateWithoutTemplateInput[] | TemplateInstanceUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplateInstanceCreateOrConnectWithoutTemplateInput | TemplateInstanceCreateOrConnectWithoutTemplateInput[]
    createMany?: TemplateInstanceCreateManyTemplateInputEnvelope
    connect?: TemplateInstanceWhereUniqueInput | TemplateInstanceWhereUniqueInput[]
  }

  export type FieldUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<FieldCreateWithoutTemplateInput, FieldUncheckedCreateWithoutTemplateInput> | FieldCreateWithoutTemplateInput[] | FieldUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: FieldCreateOrConnectWithoutTemplateInput | FieldCreateOrConnectWithoutTemplateInput[]
    upsert?: FieldUpsertWithWhereUniqueWithoutTemplateInput | FieldUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: FieldCreateManyTemplateInputEnvelope
    set?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    disconnect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    delete?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    connect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    update?: FieldUpdateWithWhereUniqueWithoutTemplateInput | FieldUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: FieldUpdateManyWithWhereWithoutTemplateInput | FieldUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: FieldScalarWhereInput | FieldScalarWhereInput[]
  }

  export type CollectionUpdateOneRequiredWithoutTemplateNestedInput = {
    create?: XOR<CollectionCreateWithoutTemplateInput, CollectionUncheckedCreateWithoutTemplateInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutTemplateInput
    upsert?: CollectionUpsertWithoutTemplateInput
    connect?: CollectionWhereUniqueInput
    update?: XOR<XOR<CollectionUpdateToOneWithWhereWithoutTemplateInput, CollectionUpdateWithoutTemplateInput>, CollectionUncheckedUpdateWithoutTemplateInput>
  }

  export type TemplateInstanceUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<TemplateInstanceCreateWithoutTemplateInput, TemplateInstanceUncheckedCreateWithoutTemplateInput> | TemplateInstanceCreateWithoutTemplateInput[] | TemplateInstanceUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplateInstanceCreateOrConnectWithoutTemplateInput | TemplateInstanceCreateOrConnectWithoutTemplateInput[]
    upsert?: TemplateInstanceUpsertWithWhereUniqueWithoutTemplateInput | TemplateInstanceUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: TemplateInstanceCreateManyTemplateInputEnvelope
    set?: TemplateInstanceWhereUniqueInput | TemplateInstanceWhereUniqueInput[]
    disconnect?: TemplateInstanceWhereUniqueInput | TemplateInstanceWhereUniqueInput[]
    delete?: TemplateInstanceWhereUniqueInput | TemplateInstanceWhereUniqueInput[]
    connect?: TemplateInstanceWhereUniqueInput | TemplateInstanceWhereUniqueInput[]
    update?: TemplateInstanceUpdateWithWhereUniqueWithoutTemplateInput | TemplateInstanceUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: TemplateInstanceUpdateManyWithWhereWithoutTemplateInput | TemplateInstanceUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: TemplateInstanceScalarWhereInput | TemplateInstanceScalarWhereInput[]
  }

  export type FieldUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<FieldCreateWithoutTemplateInput, FieldUncheckedCreateWithoutTemplateInput> | FieldCreateWithoutTemplateInput[] | FieldUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: FieldCreateOrConnectWithoutTemplateInput | FieldCreateOrConnectWithoutTemplateInput[]
    upsert?: FieldUpsertWithWhereUniqueWithoutTemplateInput | FieldUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: FieldCreateManyTemplateInputEnvelope
    set?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    disconnect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    delete?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    connect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    update?: FieldUpdateWithWhereUniqueWithoutTemplateInput | FieldUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: FieldUpdateManyWithWhereWithoutTemplateInput | FieldUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: FieldScalarWhereInput | FieldScalarWhereInput[]
  }

  export type TemplateInstanceUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<TemplateInstanceCreateWithoutTemplateInput, TemplateInstanceUncheckedCreateWithoutTemplateInput> | TemplateInstanceCreateWithoutTemplateInput[] | TemplateInstanceUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplateInstanceCreateOrConnectWithoutTemplateInput | TemplateInstanceCreateOrConnectWithoutTemplateInput[]
    upsert?: TemplateInstanceUpsertWithWhereUniqueWithoutTemplateInput | TemplateInstanceUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: TemplateInstanceCreateManyTemplateInputEnvelope
    set?: TemplateInstanceWhereUniqueInput | TemplateInstanceWhereUniqueInput[]
    disconnect?: TemplateInstanceWhereUniqueInput | TemplateInstanceWhereUniqueInput[]
    delete?: TemplateInstanceWhereUniqueInput | TemplateInstanceWhereUniqueInput[]
    connect?: TemplateInstanceWhereUniqueInput | TemplateInstanceWhereUniqueInput[]
    update?: TemplateInstanceUpdateWithWhereUniqueWithoutTemplateInput | TemplateInstanceUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: TemplateInstanceUpdateManyWithWhereWithoutTemplateInput | TemplateInstanceUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: TemplateInstanceScalarWhereInput | TemplateInstanceScalarWhereInput[]
  }

  export type ContentTemplateInstanceCreateNestedManyWithoutTemplateInstanceInput = {
    create?: XOR<ContentTemplateInstanceCreateWithoutTemplateInstanceInput, ContentTemplateInstanceUncheckedCreateWithoutTemplateInstanceInput> | ContentTemplateInstanceCreateWithoutTemplateInstanceInput[] | ContentTemplateInstanceUncheckedCreateWithoutTemplateInstanceInput[]
    connectOrCreate?: ContentTemplateInstanceCreateOrConnectWithoutTemplateInstanceInput | ContentTemplateInstanceCreateOrConnectWithoutTemplateInstanceInput[]
    createMany?: ContentTemplateInstanceCreateManyTemplateInstanceInputEnvelope
    connect?: ContentTemplateInstanceWhereUniqueInput | ContentTemplateInstanceWhereUniqueInput[]
  }

  export type TemplateCreateNestedOneWithoutTemplateInstanceInput = {
    create?: XOR<TemplateCreateWithoutTemplateInstanceInput, TemplateUncheckedCreateWithoutTemplateInstanceInput>
    connectOrCreate?: TemplateCreateOrConnectWithoutTemplateInstanceInput
    connect?: TemplateWhereUniqueInput
  }

  export type ContentTemplateInstanceUncheckedCreateNestedManyWithoutTemplateInstanceInput = {
    create?: XOR<ContentTemplateInstanceCreateWithoutTemplateInstanceInput, ContentTemplateInstanceUncheckedCreateWithoutTemplateInstanceInput> | ContentTemplateInstanceCreateWithoutTemplateInstanceInput[] | ContentTemplateInstanceUncheckedCreateWithoutTemplateInstanceInput[]
    connectOrCreate?: ContentTemplateInstanceCreateOrConnectWithoutTemplateInstanceInput | ContentTemplateInstanceCreateOrConnectWithoutTemplateInstanceInput[]
    createMany?: ContentTemplateInstanceCreateManyTemplateInstanceInputEnvelope
    connect?: ContentTemplateInstanceWhereUniqueInput | ContentTemplateInstanceWhereUniqueInput[]
  }

  export type ContentTemplateInstanceUpdateManyWithoutTemplateInstanceNestedInput = {
    create?: XOR<ContentTemplateInstanceCreateWithoutTemplateInstanceInput, ContentTemplateInstanceUncheckedCreateWithoutTemplateInstanceInput> | ContentTemplateInstanceCreateWithoutTemplateInstanceInput[] | ContentTemplateInstanceUncheckedCreateWithoutTemplateInstanceInput[]
    connectOrCreate?: ContentTemplateInstanceCreateOrConnectWithoutTemplateInstanceInput | ContentTemplateInstanceCreateOrConnectWithoutTemplateInstanceInput[]
    upsert?: ContentTemplateInstanceUpsertWithWhereUniqueWithoutTemplateInstanceInput | ContentTemplateInstanceUpsertWithWhereUniqueWithoutTemplateInstanceInput[]
    createMany?: ContentTemplateInstanceCreateManyTemplateInstanceInputEnvelope
    set?: ContentTemplateInstanceWhereUniqueInput | ContentTemplateInstanceWhereUniqueInput[]
    disconnect?: ContentTemplateInstanceWhereUniqueInput | ContentTemplateInstanceWhereUniqueInput[]
    delete?: ContentTemplateInstanceWhereUniqueInput | ContentTemplateInstanceWhereUniqueInput[]
    connect?: ContentTemplateInstanceWhereUniqueInput | ContentTemplateInstanceWhereUniqueInput[]
    update?: ContentTemplateInstanceUpdateWithWhereUniqueWithoutTemplateInstanceInput | ContentTemplateInstanceUpdateWithWhereUniqueWithoutTemplateInstanceInput[]
    updateMany?: ContentTemplateInstanceUpdateManyWithWhereWithoutTemplateInstanceInput | ContentTemplateInstanceUpdateManyWithWhereWithoutTemplateInstanceInput[]
    deleteMany?: ContentTemplateInstanceScalarWhereInput | ContentTemplateInstanceScalarWhereInput[]
  }

  export type TemplateUpdateOneRequiredWithoutTemplateInstanceNestedInput = {
    create?: XOR<TemplateCreateWithoutTemplateInstanceInput, TemplateUncheckedCreateWithoutTemplateInstanceInput>
    connectOrCreate?: TemplateCreateOrConnectWithoutTemplateInstanceInput
    upsert?: TemplateUpsertWithoutTemplateInstanceInput
    connect?: TemplateWhereUniqueInput
    update?: XOR<XOR<TemplateUpdateToOneWithWhereWithoutTemplateInstanceInput, TemplateUpdateWithoutTemplateInstanceInput>, TemplateUncheckedUpdateWithoutTemplateInstanceInput>
  }

  export type ContentTemplateInstanceUncheckedUpdateManyWithoutTemplateInstanceNestedInput = {
    create?: XOR<ContentTemplateInstanceCreateWithoutTemplateInstanceInput, ContentTemplateInstanceUncheckedCreateWithoutTemplateInstanceInput> | ContentTemplateInstanceCreateWithoutTemplateInstanceInput[] | ContentTemplateInstanceUncheckedCreateWithoutTemplateInstanceInput[]
    connectOrCreate?: ContentTemplateInstanceCreateOrConnectWithoutTemplateInstanceInput | ContentTemplateInstanceCreateOrConnectWithoutTemplateInstanceInput[]
    upsert?: ContentTemplateInstanceUpsertWithWhereUniqueWithoutTemplateInstanceInput | ContentTemplateInstanceUpsertWithWhereUniqueWithoutTemplateInstanceInput[]
    createMany?: ContentTemplateInstanceCreateManyTemplateInstanceInputEnvelope
    set?: ContentTemplateInstanceWhereUniqueInput | ContentTemplateInstanceWhereUniqueInput[]
    disconnect?: ContentTemplateInstanceWhereUniqueInput | ContentTemplateInstanceWhereUniqueInput[]
    delete?: ContentTemplateInstanceWhereUniqueInput | ContentTemplateInstanceWhereUniqueInput[]
    connect?: ContentTemplateInstanceWhereUniqueInput | ContentTemplateInstanceWhereUniqueInput[]
    update?: ContentTemplateInstanceUpdateWithWhereUniqueWithoutTemplateInstanceInput | ContentTemplateInstanceUpdateWithWhereUniqueWithoutTemplateInstanceInput[]
    updateMany?: ContentTemplateInstanceUpdateManyWithWhereWithoutTemplateInstanceInput | ContentTemplateInstanceUpdateManyWithWhereWithoutTemplateInstanceInput[]
    deleteMany?: ContentTemplateInstanceScalarWhereInput | ContentTemplateInstanceScalarWhereInput[]
  }

  export type RunCreateNestedManyWithoutThreadInput = {
    create?: XOR<RunCreateWithoutThreadInput, RunUncheckedCreateWithoutThreadInput> | RunCreateWithoutThreadInput[] | RunUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: RunCreateOrConnectWithoutThreadInput | RunCreateOrConnectWithoutThreadInput[]
    createMany?: RunCreateManyThreadInputEnvelope
    connect?: RunWhereUniqueInput | RunWhereUniqueInput[]
  }

  export type OrganizationCreateNestedOneWithoutThreadInput = {
    create?: XOR<OrganizationCreateWithoutThreadInput, OrganizationUncheckedCreateWithoutThreadInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutThreadInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ThreadMessageCreateNestedManyWithoutThreadInput = {
    create?: XOR<ThreadMessageCreateWithoutThreadInput, ThreadMessageUncheckedCreateWithoutThreadInput> | ThreadMessageCreateWithoutThreadInput[] | ThreadMessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: ThreadMessageCreateOrConnectWithoutThreadInput | ThreadMessageCreateOrConnectWithoutThreadInput[]
    createMany?: ThreadMessageCreateManyThreadInputEnvelope
    connect?: ThreadMessageWhereUniqueInput | ThreadMessageWhereUniqueInput[]
  }

  export type RunUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<RunCreateWithoutThreadInput, RunUncheckedCreateWithoutThreadInput> | RunCreateWithoutThreadInput[] | RunUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: RunCreateOrConnectWithoutThreadInput | RunCreateOrConnectWithoutThreadInput[]
    createMany?: RunCreateManyThreadInputEnvelope
    connect?: RunWhereUniqueInput | RunWhereUniqueInput[]
  }

  export type ThreadMessageUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<ThreadMessageCreateWithoutThreadInput, ThreadMessageUncheckedCreateWithoutThreadInput> | ThreadMessageCreateWithoutThreadInput[] | ThreadMessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: ThreadMessageCreateOrConnectWithoutThreadInput | ThreadMessageCreateOrConnectWithoutThreadInput[]
    createMany?: ThreadMessageCreateManyThreadInputEnvelope
    connect?: ThreadMessageWhereUniqueInput | ThreadMessageWhereUniqueInput[]
  }

  export type RunUpdateManyWithoutThreadNestedInput = {
    create?: XOR<RunCreateWithoutThreadInput, RunUncheckedCreateWithoutThreadInput> | RunCreateWithoutThreadInput[] | RunUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: RunCreateOrConnectWithoutThreadInput | RunCreateOrConnectWithoutThreadInput[]
    upsert?: RunUpsertWithWhereUniqueWithoutThreadInput | RunUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: RunCreateManyThreadInputEnvelope
    set?: RunWhereUniqueInput | RunWhereUniqueInput[]
    disconnect?: RunWhereUniqueInput | RunWhereUniqueInput[]
    delete?: RunWhereUniqueInput | RunWhereUniqueInput[]
    connect?: RunWhereUniqueInput | RunWhereUniqueInput[]
    update?: RunUpdateWithWhereUniqueWithoutThreadInput | RunUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: RunUpdateManyWithWhereWithoutThreadInput | RunUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: RunScalarWhereInput | RunScalarWhereInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutThreadNestedInput = {
    create?: XOR<OrganizationCreateWithoutThreadInput, OrganizationUncheckedCreateWithoutThreadInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutThreadInput
    upsert?: OrganizationUpsertWithoutThreadInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutThreadInput, OrganizationUpdateWithoutThreadInput>, OrganizationUncheckedUpdateWithoutThreadInput>
  }

  export type ThreadMessageUpdateManyWithoutThreadNestedInput = {
    create?: XOR<ThreadMessageCreateWithoutThreadInput, ThreadMessageUncheckedCreateWithoutThreadInput> | ThreadMessageCreateWithoutThreadInput[] | ThreadMessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: ThreadMessageCreateOrConnectWithoutThreadInput | ThreadMessageCreateOrConnectWithoutThreadInput[]
    upsert?: ThreadMessageUpsertWithWhereUniqueWithoutThreadInput | ThreadMessageUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: ThreadMessageCreateManyThreadInputEnvelope
    set?: ThreadMessageWhereUniqueInput | ThreadMessageWhereUniqueInput[]
    disconnect?: ThreadMessageWhereUniqueInput | ThreadMessageWhereUniqueInput[]
    delete?: ThreadMessageWhereUniqueInput | ThreadMessageWhereUniqueInput[]
    connect?: ThreadMessageWhereUniqueInput | ThreadMessageWhereUniqueInput[]
    update?: ThreadMessageUpdateWithWhereUniqueWithoutThreadInput | ThreadMessageUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: ThreadMessageUpdateManyWithWhereWithoutThreadInput | ThreadMessageUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: ThreadMessageScalarWhereInput | ThreadMessageScalarWhereInput[]
  }

  export type RunUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<RunCreateWithoutThreadInput, RunUncheckedCreateWithoutThreadInput> | RunCreateWithoutThreadInput[] | RunUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: RunCreateOrConnectWithoutThreadInput | RunCreateOrConnectWithoutThreadInput[]
    upsert?: RunUpsertWithWhereUniqueWithoutThreadInput | RunUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: RunCreateManyThreadInputEnvelope
    set?: RunWhereUniqueInput | RunWhereUniqueInput[]
    disconnect?: RunWhereUniqueInput | RunWhereUniqueInput[]
    delete?: RunWhereUniqueInput | RunWhereUniqueInput[]
    connect?: RunWhereUniqueInput | RunWhereUniqueInput[]
    update?: RunUpdateWithWhereUniqueWithoutThreadInput | RunUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: RunUpdateManyWithWhereWithoutThreadInput | RunUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: RunScalarWhereInput | RunScalarWhereInput[]
  }

  export type ThreadMessageUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<ThreadMessageCreateWithoutThreadInput, ThreadMessageUncheckedCreateWithoutThreadInput> | ThreadMessageCreateWithoutThreadInput[] | ThreadMessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: ThreadMessageCreateOrConnectWithoutThreadInput | ThreadMessageCreateOrConnectWithoutThreadInput[]
    upsert?: ThreadMessageUpsertWithWhereUniqueWithoutThreadInput | ThreadMessageUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: ThreadMessageCreateManyThreadInputEnvelope
    set?: ThreadMessageWhereUniqueInput | ThreadMessageWhereUniqueInput[]
    disconnect?: ThreadMessageWhereUniqueInput | ThreadMessageWhereUniqueInput[]
    delete?: ThreadMessageWhereUniqueInput | ThreadMessageWhereUniqueInput[]
    connect?: ThreadMessageWhereUniqueInput | ThreadMessageWhereUniqueInput[]
    update?: ThreadMessageUpdateWithWhereUniqueWithoutThreadInput | ThreadMessageUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: ThreadMessageUpdateManyWithWhereWithoutThreadInput | ThreadMessageUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: ThreadMessageScalarWhereInput | ThreadMessageScalarWhereInput[]
  }

  export type RunCreateNestedOneWithoutThreadMessageInput = {
    create?: XOR<RunCreateWithoutThreadMessageInput, RunUncheckedCreateWithoutThreadMessageInput>
    connectOrCreate?: RunCreateOrConnectWithoutThreadMessageInput
    connect?: RunWhereUniqueInput
  }

  export type ThreadCreateNestedOneWithoutThreadMessageInput = {
    create?: XOR<ThreadCreateWithoutThreadMessageInput, ThreadUncheckedCreateWithoutThreadMessageInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutThreadMessageInput
    connect?: ThreadWhereUniqueInput
  }

  export type RunUpdateOneWithoutThreadMessageNestedInput = {
    create?: XOR<RunCreateWithoutThreadMessageInput, RunUncheckedCreateWithoutThreadMessageInput>
    connectOrCreate?: RunCreateOrConnectWithoutThreadMessageInput
    upsert?: RunUpsertWithoutThreadMessageInput
    disconnect?: RunWhereInput | boolean
    delete?: RunWhereInput | boolean
    connect?: RunWhereUniqueInput
    update?: XOR<XOR<RunUpdateToOneWithWhereWithoutThreadMessageInput, RunUpdateWithoutThreadMessageInput>, RunUncheckedUpdateWithoutThreadMessageInput>
  }

  export type ThreadUpdateOneRequiredWithoutThreadMessageNestedInput = {
    create?: XOR<ThreadCreateWithoutThreadMessageInput, ThreadUncheckedCreateWithoutThreadMessageInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutThreadMessageInput
    upsert?: ThreadUpsertWithoutThreadMessageInput
    connect?: ThreadWhereUniqueInput
    update?: XOR<XOR<ThreadUpdateToOneWithWhereWithoutThreadMessageInput, ThreadUpdateWithoutThreadMessageInput>, ThreadUncheckedUpdateWithoutThreadMessageInput>
  }

  export type OrganizationCreateNestedOneWithoutUsageInput = {
    create?: XOR<OrganizationCreateWithoutUsageInput, OrganizationUncheckedCreateWithoutUsageInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsageInput
    connect?: OrganizationWhereUniqueInput
  }

  export type RunCreateNestedOneWithoutUsageInput = {
    create?: XOR<RunCreateWithoutUsageInput, RunUncheckedCreateWithoutUsageInput>
    connectOrCreate?: RunCreateOrConnectWithoutUsageInput
    connect?: RunWhereUniqueInput
  }

  export type OrganizationUpdateOneWithoutUsageNestedInput = {
    create?: XOR<OrganizationCreateWithoutUsageInput, OrganizationUncheckedCreateWithoutUsageInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsageInput
    upsert?: OrganizationUpsertWithoutUsageInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUsageInput, OrganizationUpdateWithoutUsageInput>, OrganizationUncheckedUpdateWithoutUsageInput>
  }

  export type RunUpdateOneRequiredWithoutUsageNestedInput = {
    create?: XOR<RunCreateWithoutUsageInput, RunUncheckedCreateWithoutUsageInput>
    connectOrCreate?: RunCreateOrConnectWithoutUsageInput
    upsert?: RunUpsertWithoutUsageInput
    connect?: RunWhereUniqueInput
    update?: XOR<XOR<RunUpdateToOneWithWhereWithoutUsageInput, RunUpdateWithoutUsageInput>, RunUncheckedUpdateWithoutUsageInput>
  }

  export type OrganizationCreateNestedOneWithoutUserOrganizationInput = {
    create?: XOR<OrganizationCreateWithoutUserOrganizationInput, OrganizationUncheckedCreateWithoutUserOrganizationInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUserOrganizationInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutUserOrganizationInput = {
    create?: XOR<UsersCreateWithoutUserOrganizationInput, UsersUncheckedCreateWithoutUserOrganizationInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserOrganizationInput
    connect?: UsersWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutUserOrganizationNestedInput = {
    create?: XOR<OrganizationCreateWithoutUserOrganizationInput, OrganizationUncheckedCreateWithoutUserOrganizationInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUserOrganizationInput
    upsert?: OrganizationUpsertWithoutUserOrganizationInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUserOrganizationInput, OrganizationUpdateWithoutUserOrganizationInput>, OrganizationUncheckedUpdateWithoutUserOrganizationInput>
  }

  export type UsersUpdateOneRequiredWithoutUserOrganizationNestedInput = {
    create?: XOR<UsersCreateWithoutUserOrganizationInput, UsersUncheckedCreateWithoutUserOrganizationInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserOrganizationInput
    upsert?: UsersUpsertWithoutUserOrganizationInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUserOrganizationInput, UsersUpdateWithoutUserOrganizationInput>, UsersUncheckedUpdateWithoutUserOrganizationInput>
  }

  export type UserOrganizationCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserOrganizationCreateWithoutUsersInput, UserOrganizationUncheckedCreateWithoutUsersInput> | UserOrganizationCreateWithoutUsersInput[] | UserOrganizationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserOrganizationCreateOrConnectWithoutUsersInput | UserOrganizationCreateOrConnectWithoutUsersInput[]
    createMany?: UserOrganizationCreateManyUsersInputEnvelope
    connect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
  }

  export type MediaCreateNestedOneWithoutUsersInput = {
    create?: XOR<MediaCreateWithoutUsersInput, MediaUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MediaCreateOrConnectWithoutUsersInput
    connect?: MediaWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutUsersInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserOrganizationUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserOrganizationCreateWithoutUsersInput, UserOrganizationUncheckedCreateWithoutUsersInput> | UserOrganizationCreateWithoutUsersInput[] | UserOrganizationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserOrganizationCreateOrConnectWithoutUsersInput | UserOrganizationCreateOrConnectWithoutUsersInput[]
    createMany?: UserOrganizationCreateManyUsersInputEnvelope
    connect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
  }

  export type UserOrganizationUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserOrganizationCreateWithoutUsersInput, UserOrganizationUncheckedCreateWithoutUsersInput> | UserOrganizationCreateWithoutUsersInput[] | UserOrganizationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserOrganizationCreateOrConnectWithoutUsersInput | UserOrganizationCreateOrConnectWithoutUsersInput[]
    upsert?: UserOrganizationUpsertWithWhereUniqueWithoutUsersInput | UserOrganizationUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UserOrganizationCreateManyUsersInputEnvelope
    set?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    disconnect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    delete?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    connect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    update?: UserOrganizationUpdateWithWhereUniqueWithoutUsersInput | UserOrganizationUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserOrganizationUpdateManyWithWhereWithoutUsersInput | UserOrganizationUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserOrganizationScalarWhereInput | UserOrganizationScalarWhereInput[]
  }

  export type MediaUpdateOneWithoutUsersNestedInput = {
    create?: XOR<MediaCreateWithoutUsersInput, MediaUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MediaCreateOrConnectWithoutUsersInput
    upsert?: MediaUpsertWithoutUsersInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutUsersInput, MediaUpdateWithoutUsersInput>, MediaUncheckedUpdateWithoutUsersInput>
  }

  export type OrganizationUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    upsert?: OrganizationUpsertWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUsersInput, OrganizationUpdateWithoutUsersInput>, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type UserOrganizationUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserOrganizationCreateWithoutUsersInput, UserOrganizationUncheckedCreateWithoutUsersInput> | UserOrganizationCreateWithoutUsersInput[] | UserOrganizationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserOrganizationCreateOrConnectWithoutUsersInput | UserOrganizationCreateOrConnectWithoutUsersInput[]
    upsert?: UserOrganizationUpsertWithWhereUniqueWithoutUsersInput | UserOrganizationUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UserOrganizationCreateManyUsersInputEnvelope
    set?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    disconnect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    delete?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    connect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    update?: UserOrganizationUpdateWithWhereUniqueWithoutUsersInput | UserOrganizationUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserOrganizationUpdateManyWithWhereWithoutUsersInput | UserOrganizationUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserOrganizationScalarWhereInput | UserOrganizationScalarWhereInput[]
  }

  export type ContentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ContentCreateWithoutAuthorInput, ContentUncheckedCreateWithoutAuthorInput> | ContentCreateWithoutAuthorInput[] | ContentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutAuthorInput | ContentCreateOrConnectWithoutAuthorInput[]
    createMany?: ContentCreateManyAuthorInputEnvelope
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type MediaCreateNestedOneWithoutAuthorInput = {
    create?: XOR<MediaCreateWithoutAuthorInput, MediaUncheckedCreateWithoutAuthorInput>
    connectOrCreate?: MediaCreateOrConnectWithoutAuthorInput
    connect?: MediaWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutAuthorInput = {
    create?: XOR<OrganizationCreateWithoutAuthorInput, OrganizationUncheckedCreateWithoutAuthorInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAuthorInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ContentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ContentCreateWithoutAuthorInput, ContentUncheckedCreateWithoutAuthorInput> | ContentCreateWithoutAuthorInput[] | ContentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutAuthorInput | ContentCreateOrConnectWithoutAuthorInput[]
    createMany?: ContentCreateManyAuthorInputEnvelope
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type ContentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ContentCreateWithoutAuthorInput, ContentUncheckedCreateWithoutAuthorInput> | ContentCreateWithoutAuthorInput[] | ContentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutAuthorInput | ContentCreateOrConnectWithoutAuthorInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutAuthorInput | ContentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ContentCreateManyAuthorInputEnvelope
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutAuthorInput | ContentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutAuthorInput | ContentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type MediaUpdateOneRequiredWithoutAuthorNestedInput = {
    create?: XOR<MediaCreateWithoutAuthorInput, MediaUncheckedCreateWithoutAuthorInput>
    connectOrCreate?: MediaCreateOrConnectWithoutAuthorInput
    upsert?: MediaUpsertWithoutAuthorInput
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutAuthorInput, MediaUpdateWithoutAuthorInput>, MediaUncheckedUpdateWithoutAuthorInput>
  }

  export type OrganizationUpdateOneRequiredWithoutAuthorNestedInput = {
    create?: XOR<OrganizationCreateWithoutAuthorInput, OrganizationUncheckedCreateWithoutAuthorInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAuthorInput
    upsert?: OrganizationUpsertWithoutAuthorInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutAuthorInput, OrganizationUpdateWithoutAuthorInput>, OrganizationUncheckedUpdateWithoutAuthorInput>
  }

  export type ContentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ContentCreateWithoutAuthorInput, ContentUncheckedCreateWithoutAuthorInput> | ContentCreateWithoutAuthorInput[] | ContentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutAuthorInput | ContentCreateOrConnectWithoutAuthorInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutAuthorInput | ContentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ContentCreateManyAuthorInputEnvelope
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutAuthorInput | ContentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutAuthorInput | ContentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type form_fieldCreateoptionsInput = {
    set: InputJsonValue[]
  }

  export type CollectionCreateNestedOneWithoutForm_fieldInput = {
    create?: XOR<CollectionCreateWithoutForm_fieldInput, CollectionUncheckedCreateWithoutForm_fieldInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutForm_fieldInput
    connect?: CollectionWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutForm_fieldInput = {
    create?: XOR<OrganizationCreateWithoutForm_fieldInput, OrganizationUncheckedCreateWithoutForm_fieldInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutForm_fieldInput
    connect?: OrganizationWhereUniqueInput
  }

  export type structCreateNestedOneWithoutForm_fieldInput = {
    create?: XOR<structCreateWithoutForm_fieldInput, structUncheckedCreateWithoutForm_fieldInput>
    connectOrCreate?: structCreateOrConnectWithoutForm_fieldInput
    connect?: structWhereUniqueInput
  }

  export type Enumfield_typeFieldUpdateOperationsInput = {
    set?: $Enums.field_type
  }

  export type form_fieldUpdateoptionsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type CollectionUpdateOneWithoutForm_fieldNestedInput = {
    create?: XOR<CollectionCreateWithoutForm_fieldInput, CollectionUncheckedCreateWithoutForm_fieldInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutForm_fieldInput
    upsert?: CollectionUpsertWithoutForm_fieldInput
    disconnect?: CollectionWhereInput | boolean
    delete?: CollectionWhereInput | boolean
    connect?: CollectionWhereUniqueInput
    update?: XOR<XOR<CollectionUpdateToOneWithWhereWithoutForm_fieldInput, CollectionUpdateWithoutForm_fieldInput>, CollectionUncheckedUpdateWithoutForm_fieldInput>
  }

  export type OrganizationUpdateOneRequiredWithoutForm_fieldNestedInput = {
    create?: XOR<OrganizationCreateWithoutForm_fieldInput, OrganizationUncheckedCreateWithoutForm_fieldInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutForm_fieldInput
    upsert?: OrganizationUpsertWithoutForm_fieldInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutForm_fieldInput, OrganizationUpdateWithoutForm_fieldInput>, OrganizationUncheckedUpdateWithoutForm_fieldInput>
  }

  export type structUpdateOneWithoutForm_fieldNestedInput = {
    create?: XOR<structCreateWithoutForm_fieldInput, structUncheckedCreateWithoutForm_fieldInput>
    connectOrCreate?: structCreateOrConnectWithoutForm_fieldInput
    upsert?: structUpsertWithoutForm_fieldInput
    disconnect?: structWhereInput | boolean
    delete?: structWhereInput | boolean
    connect?: structWhereUniqueInput
    update?: XOR<XOR<structUpdateToOneWithWhereWithoutForm_fieldInput, structUpdateWithoutForm_fieldInput>, structUncheckedUpdateWithoutForm_fieldInput>
  }

  export type org_detailsCreatesocialsInput = {
    set: string[]
  }

  export type MediaCreateNestedOneWithoutOrg_detailsInput = {
    create?: XOR<MediaCreateWithoutOrg_detailsInput, MediaUncheckedCreateWithoutOrg_detailsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutOrg_detailsInput
    connect?: MediaWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutOrg_detailsInput = {
    create?: XOR<OrganizationCreateWithoutOrg_detailsInput, OrganizationUncheckedCreateWithoutOrg_detailsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrg_detailsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type org_detailsUpdatesocialsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MediaUpdateOneWithoutOrg_detailsNestedInput = {
    create?: XOR<MediaCreateWithoutOrg_detailsInput, MediaUncheckedCreateWithoutOrg_detailsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutOrg_detailsInput
    upsert?: MediaUpsertWithoutOrg_detailsInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutOrg_detailsInput, MediaUpdateWithoutOrg_detailsInput>, MediaUncheckedUpdateWithoutOrg_detailsInput>
  }

  export type OrganizationUpdateOneRequiredWithoutOrg_detailsNestedInput = {
    create?: XOR<OrganizationCreateWithoutOrg_detailsInput, OrganizationUncheckedCreateWithoutOrg_detailsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrg_detailsInput
    upsert?: OrganizationUpsertWithoutOrg_detailsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutOrg_detailsInput, OrganizationUpdateWithoutOrg_detailsInput>, OrganizationUncheckedUpdateWithoutOrg_detailsInput>
  }

  export type form_fieldCreateNestedManyWithoutStructInput = {
    create?: XOR<form_fieldCreateWithoutStructInput, form_fieldUncheckedCreateWithoutStructInput> | form_fieldCreateWithoutStructInput[] | form_fieldUncheckedCreateWithoutStructInput[]
    connectOrCreate?: form_fieldCreateOrConnectWithoutStructInput | form_fieldCreateOrConnectWithoutStructInput[]
    createMany?: form_fieldCreateManyStructInputEnvelope
    connect?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
  }

  export type MediaCreateNestedOneWithoutStructInput = {
    create?: XOR<MediaCreateWithoutStructInput, MediaUncheckedCreateWithoutStructInput>
    connectOrCreate?: MediaCreateOrConnectWithoutStructInput
    connect?: MediaWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutStructInput = {
    create?: XOR<OrganizationCreateWithoutStructInput, OrganizationUncheckedCreateWithoutStructInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutStructInput
    connect?: OrganizationWhereUniqueInput
  }

  export type struct_set_instanceCreateNestedManyWithoutStructInput = {
    create?: XOR<struct_set_instanceCreateWithoutStructInput, struct_set_instanceUncheckedCreateWithoutStructInput> | struct_set_instanceCreateWithoutStructInput[] | struct_set_instanceUncheckedCreateWithoutStructInput[]
    connectOrCreate?: struct_set_instanceCreateOrConnectWithoutStructInput | struct_set_instanceCreateOrConnectWithoutStructInput[]
    createMany?: struct_set_instanceCreateManyStructInputEnvelope
    connect?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
  }

  export type form_fieldUncheckedCreateNestedManyWithoutStructInput = {
    create?: XOR<form_fieldCreateWithoutStructInput, form_fieldUncheckedCreateWithoutStructInput> | form_fieldCreateWithoutStructInput[] | form_fieldUncheckedCreateWithoutStructInput[]
    connectOrCreate?: form_fieldCreateOrConnectWithoutStructInput | form_fieldCreateOrConnectWithoutStructInput[]
    createMany?: form_fieldCreateManyStructInputEnvelope
    connect?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
  }

  export type struct_set_instanceUncheckedCreateNestedManyWithoutStructInput = {
    create?: XOR<struct_set_instanceCreateWithoutStructInput, struct_set_instanceUncheckedCreateWithoutStructInput> | struct_set_instanceCreateWithoutStructInput[] | struct_set_instanceUncheckedCreateWithoutStructInput[]
    connectOrCreate?: struct_set_instanceCreateOrConnectWithoutStructInput | struct_set_instanceCreateOrConnectWithoutStructInput[]
    createMany?: struct_set_instanceCreateManyStructInputEnvelope
    connect?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
  }

  export type form_fieldUpdateManyWithoutStructNestedInput = {
    create?: XOR<form_fieldCreateWithoutStructInput, form_fieldUncheckedCreateWithoutStructInput> | form_fieldCreateWithoutStructInput[] | form_fieldUncheckedCreateWithoutStructInput[]
    connectOrCreate?: form_fieldCreateOrConnectWithoutStructInput | form_fieldCreateOrConnectWithoutStructInput[]
    upsert?: form_fieldUpsertWithWhereUniqueWithoutStructInput | form_fieldUpsertWithWhereUniqueWithoutStructInput[]
    createMany?: form_fieldCreateManyStructInputEnvelope
    set?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    disconnect?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    delete?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    connect?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    update?: form_fieldUpdateWithWhereUniqueWithoutStructInput | form_fieldUpdateWithWhereUniqueWithoutStructInput[]
    updateMany?: form_fieldUpdateManyWithWhereWithoutStructInput | form_fieldUpdateManyWithWhereWithoutStructInput[]
    deleteMany?: form_fieldScalarWhereInput | form_fieldScalarWhereInput[]
  }

  export type MediaUpdateOneWithoutStructNestedInput = {
    create?: XOR<MediaCreateWithoutStructInput, MediaUncheckedCreateWithoutStructInput>
    connectOrCreate?: MediaCreateOrConnectWithoutStructInput
    upsert?: MediaUpsertWithoutStructInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutStructInput, MediaUpdateWithoutStructInput>, MediaUncheckedUpdateWithoutStructInput>
  }

  export type OrganizationUpdateOneRequiredWithoutStructNestedInput = {
    create?: XOR<OrganizationCreateWithoutStructInput, OrganizationUncheckedCreateWithoutStructInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutStructInput
    upsert?: OrganizationUpsertWithoutStructInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutStructInput, OrganizationUpdateWithoutStructInput>, OrganizationUncheckedUpdateWithoutStructInput>
  }

  export type struct_set_instanceUpdateManyWithoutStructNestedInput = {
    create?: XOR<struct_set_instanceCreateWithoutStructInput, struct_set_instanceUncheckedCreateWithoutStructInput> | struct_set_instanceCreateWithoutStructInput[] | struct_set_instanceUncheckedCreateWithoutStructInput[]
    connectOrCreate?: struct_set_instanceCreateOrConnectWithoutStructInput | struct_set_instanceCreateOrConnectWithoutStructInput[]
    upsert?: struct_set_instanceUpsertWithWhereUniqueWithoutStructInput | struct_set_instanceUpsertWithWhereUniqueWithoutStructInput[]
    createMany?: struct_set_instanceCreateManyStructInputEnvelope
    set?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    disconnect?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    delete?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    connect?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    update?: struct_set_instanceUpdateWithWhereUniqueWithoutStructInput | struct_set_instanceUpdateWithWhereUniqueWithoutStructInput[]
    updateMany?: struct_set_instanceUpdateManyWithWhereWithoutStructInput | struct_set_instanceUpdateManyWithWhereWithoutStructInput[]
    deleteMany?: struct_set_instanceScalarWhereInput | struct_set_instanceScalarWhereInput[]
  }

  export type form_fieldUncheckedUpdateManyWithoutStructNestedInput = {
    create?: XOR<form_fieldCreateWithoutStructInput, form_fieldUncheckedCreateWithoutStructInput> | form_fieldCreateWithoutStructInput[] | form_fieldUncheckedCreateWithoutStructInput[]
    connectOrCreate?: form_fieldCreateOrConnectWithoutStructInput | form_fieldCreateOrConnectWithoutStructInput[]
    upsert?: form_fieldUpsertWithWhereUniqueWithoutStructInput | form_fieldUpsertWithWhereUniqueWithoutStructInput[]
    createMany?: form_fieldCreateManyStructInputEnvelope
    set?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    disconnect?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    delete?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    connect?: form_fieldWhereUniqueInput | form_fieldWhereUniqueInput[]
    update?: form_fieldUpdateWithWhereUniqueWithoutStructInput | form_fieldUpdateWithWhereUniqueWithoutStructInput[]
    updateMany?: form_fieldUpdateManyWithWhereWithoutStructInput | form_fieldUpdateManyWithWhereWithoutStructInput[]
    deleteMany?: form_fieldScalarWhereInput | form_fieldScalarWhereInput[]
  }

  export type struct_set_instanceUncheckedUpdateManyWithoutStructNestedInput = {
    create?: XOR<struct_set_instanceCreateWithoutStructInput, struct_set_instanceUncheckedCreateWithoutStructInput> | struct_set_instanceCreateWithoutStructInput[] | struct_set_instanceUncheckedCreateWithoutStructInput[]
    connectOrCreate?: struct_set_instanceCreateOrConnectWithoutStructInput | struct_set_instanceCreateOrConnectWithoutStructInput[]
    upsert?: struct_set_instanceUpsertWithWhereUniqueWithoutStructInput | struct_set_instanceUpsertWithWhereUniqueWithoutStructInput[]
    createMany?: struct_set_instanceCreateManyStructInputEnvelope
    set?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    disconnect?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    delete?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    connect?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    update?: struct_set_instanceUpdateWithWhereUniqueWithoutStructInput | struct_set_instanceUpdateWithWhereUniqueWithoutStructInput[]
    updateMany?: struct_set_instanceUpdateManyWithWhereWithoutStructInput | struct_set_instanceUpdateManyWithWhereWithoutStructInput[]
    deleteMany?: struct_set_instanceScalarWhereInput | struct_set_instanceScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutStruct_setInput = {
    create?: XOR<OrganizationCreateWithoutStruct_setInput, OrganizationUncheckedCreateWithoutStruct_setInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutStruct_setInput
    connect?: OrganizationWhereUniqueInput
  }

  export type struct_set_instanceCreateNestedManyWithoutStruct_setInput = {
    create?: XOR<struct_set_instanceCreateWithoutStruct_setInput, struct_set_instanceUncheckedCreateWithoutStruct_setInput> | struct_set_instanceCreateWithoutStruct_setInput[] | struct_set_instanceUncheckedCreateWithoutStruct_setInput[]
    connectOrCreate?: struct_set_instanceCreateOrConnectWithoutStruct_setInput | struct_set_instanceCreateOrConnectWithoutStruct_setInput[]
    createMany?: struct_set_instanceCreateManyStruct_setInputEnvelope
    connect?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
  }

  export type struct_set_instanceUncheckedCreateNestedManyWithoutStruct_setInput = {
    create?: XOR<struct_set_instanceCreateWithoutStruct_setInput, struct_set_instanceUncheckedCreateWithoutStruct_setInput> | struct_set_instanceCreateWithoutStruct_setInput[] | struct_set_instanceUncheckedCreateWithoutStruct_setInput[]
    connectOrCreate?: struct_set_instanceCreateOrConnectWithoutStruct_setInput | struct_set_instanceCreateOrConnectWithoutStruct_setInput[]
    createMany?: struct_set_instanceCreateManyStruct_setInputEnvelope
    connect?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutStruct_setNestedInput = {
    create?: XOR<OrganizationCreateWithoutStruct_setInput, OrganizationUncheckedCreateWithoutStruct_setInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutStruct_setInput
    upsert?: OrganizationUpsertWithoutStruct_setInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutStruct_setInput, OrganizationUpdateWithoutStruct_setInput>, OrganizationUncheckedUpdateWithoutStruct_setInput>
  }

  export type struct_set_instanceUpdateManyWithoutStruct_setNestedInput = {
    create?: XOR<struct_set_instanceCreateWithoutStruct_setInput, struct_set_instanceUncheckedCreateWithoutStruct_setInput> | struct_set_instanceCreateWithoutStruct_setInput[] | struct_set_instanceUncheckedCreateWithoutStruct_setInput[]
    connectOrCreate?: struct_set_instanceCreateOrConnectWithoutStruct_setInput | struct_set_instanceCreateOrConnectWithoutStruct_setInput[]
    upsert?: struct_set_instanceUpsertWithWhereUniqueWithoutStruct_setInput | struct_set_instanceUpsertWithWhereUniqueWithoutStruct_setInput[]
    createMany?: struct_set_instanceCreateManyStruct_setInputEnvelope
    set?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    disconnect?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    delete?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    connect?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    update?: struct_set_instanceUpdateWithWhereUniqueWithoutStruct_setInput | struct_set_instanceUpdateWithWhereUniqueWithoutStruct_setInput[]
    updateMany?: struct_set_instanceUpdateManyWithWhereWithoutStruct_setInput | struct_set_instanceUpdateManyWithWhereWithoutStruct_setInput[]
    deleteMany?: struct_set_instanceScalarWhereInput | struct_set_instanceScalarWhereInput[]
  }

  export type struct_set_instanceUncheckedUpdateManyWithoutStruct_setNestedInput = {
    create?: XOR<struct_set_instanceCreateWithoutStruct_setInput, struct_set_instanceUncheckedCreateWithoutStruct_setInput> | struct_set_instanceCreateWithoutStruct_setInput[] | struct_set_instanceUncheckedCreateWithoutStruct_setInput[]
    connectOrCreate?: struct_set_instanceCreateOrConnectWithoutStruct_setInput | struct_set_instanceCreateOrConnectWithoutStruct_setInput[]
    upsert?: struct_set_instanceUpsertWithWhereUniqueWithoutStruct_setInput | struct_set_instanceUpsertWithWhereUniqueWithoutStruct_setInput[]
    createMany?: struct_set_instanceCreateManyStruct_setInputEnvelope
    set?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    disconnect?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    delete?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    connect?: struct_set_instanceWhereUniqueInput | struct_set_instanceWhereUniqueInput[]
    update?: struct_set_instanceUpdateWithWhereUniqueWithoutStruct_setInput | struct_set_instanceUpdateWithWhereUniqueWithoutStruct_setInput[]
    updateMany?: struct_set_instanceUpdateManyWithWhereWithoutStruct_setInput | struct_set_instanceUpdateManyWithWhereWithoutStruct_setInput[]
    deleteMany?: struct_set_instanceScalarWhereInput | struct_set_instanceScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutStruct_set_instanceInput = {
    create?: XOR<OrganizationCreateWithoutStruct_set_instanceInput, OrganizationUncheckedCreateWithoutStruct_set_instanceInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutStruct_set_instanceInput
    connect?: OrganizationWhereUniqueInput
  }

  export type structCreateNestedOneWithoutStruct_set_instanceInput = {
    create?: XOR<structCreateWithoutStruct_set_instanceInput, structUncheckedCreateWithoutStruct_set_instanceInput>
    connectOrCreate?: structCreateOrConnectWithoutStruct_set_instanceInput
    connect?: structWhereUniqueInput
  }

  export type struct_setCreateNestedOneWithoutStruct_set_instanceInput = {
    create?: XOR<struct_setCreateWithoutStruct_set_instanceInput, struct_setUncheckedCreateWithoutStruct_set_instanceInput>
    connectOrCreate?: struct_setCreateOrConnectWithoutStruct_set_instanceInput
    connect?: struct_setWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutStruct_set_instanceNestedInput = {
    create?: XOR<OrganizationCreateWithoutStruct_set_instanceInput, OrganizationUncheckedCreateWithoutStruct_set_instanceInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutStruct_set_instanceInput
    upsert?: OrganizationUpsertWithoutStruct_set_instanceInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutStruct_set_instanceInput, OrganizationUpdateWithoutStruct_set_instanceInput>, OrganizationUncheckedUpdateWithoutStruct_set_instanceInput>
  }

  export type structUpdateOneRequiredWithoutStruct_set_instanceNestedInput = {
    create?: XOR<structCreateWithoutStruct_set_instanceInput, structUncheckedCreateWithoutStruct_set_instanceInput>
    connectOrCreate?: structCreateOrConnectWithoutStruct_set_instanceInput
    upsert?: structUpsertWithoutStruct_set_instanceInput
    connect?: structWhereUniqueInput
    update?: XOR<XOR<structUpdateToOneWithWhereWithoutStruct_set_instanceInput, structUpdateWithoutStruct_set_instanceInput>, structUncheckedUpdateWithoutStruct_set_instanceInput>
  }

  export type struct_setUpdateOneRequiredWithoutStruct_set_instanceNestedInput = {
    create?: XOR<struct_setCreateWithoutStruct_set_instanceInput, struct_setUncheckedCreateWithoutStruct_set_instanceInput>
    connectOrCreate?: struct_setCreateOrConnectWithoutStruct_set_instanceInput
    upsert?: struct_setUpsertWithoutStruct_set_instanceInput
    connect?: struct_setWhereUniqueInput
    update?: XOR<XOR<struct_setUpdateToOneWithWhereWithoutStruct_set_instanceInput, struct_setUpdateWithoutStruct_set_instanceInput>, struct_setUncheckedUpdateWithoutStruct_set_instanceInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumfield_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.field_type | Enumfield_typeFieldRefInput<$PrismaModel>
    in?: $Enums.field_type[] | ListEnumfield_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.field_type[] | ListEnumfield_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumfield_typeFilter<$PrismaModel> | $Enums.field_type
  }

  export type NestedEnumfield_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.field_type | Enumfield_typeFieldRefInput<$PrismaModel>
    in?: $Enums.field_type[] | ListEnumfield_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.field_type[] | ListEnumfield_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumfield_typeWithAggregatesFilter<$PrismaModel> | $Enums.field_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfield_typeFilter<$PrismaModel>
    _max?: NestedEnumfield_typeFilter<$PrismaModel>
  }

  export type CollectionCreateWithoutCategoryInput = {
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    icon: string
    page_content?: boolean
    enable_author?: boolean
    enable_comments?: boolean
    enable_featured_posts?: boolean
    enable_rating?: boolean
    path_prefix?: string | null
    title?: string | null
    Organization: OrganizationCreateNestedOneWithoutCollectionInput
    Content?: ContentCreateNestedManyWithoutCollectionInput
    Field?: FieldCreateNestedManyWithoutCollectionInput
    Template?: TemplateCreateNestedManyWithoutCollectionInput
    form_field?: form_fieldCreateNestedManyWithoutCollectionInput
  }

  export type CollectionUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    organization_id: number
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    icon: string
    page_content?: boolean
    enable_author?: boolean
    enable_comments?: boolean
    enable_featured_posts?: boolean
    enable_rating?: boolean
    path_prefix?: string | null
    title?: string | null
    Content?: ContentUncheckedCreateNestedManyWithoutCollectionInput
    Field?: FieldUncheckedCreateNestedManyWithoutCollectionInput
    Template?: TemplateUncheckedCreateNestedManyWithoutCollectionInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type CollectionCreateOrConnectWithoutCategoryInput = {
    where: CollectionWhereUniqueInput
    create: XOR<CollectionCreateWithoutCategoryInput, CollectionUncheckedCreateWithoutCategoryInput>
  }

  export type OrganizationCreateWithoutCategoryInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutCategoryInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutCategoryInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutCategoryInput, OrganizationUncheckedCreateWithoutCategoryInput>
  }

  export type CategoryCreateWithoutOther_CategoryInput = {
    name: string
    slug: string
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    short_name: string
    Collection: CollectionCreateNestedOneWithoutCategoryInput
    Organization: OrganizationCreateNestedOneWithoutCategoryInput
    Category?: CategoryCreateNestedOneWithoutOther_CategoryInput
    Content?: ContentCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutOther_CategoryInput = {
    id?: number
    name: string
    organization_id: number
    slug: string
    description?: string | null
    parent_id?: number | null
    collection_id: number
    created_at?: Date | string
    updated_at: Date | string
    short_name: string
    Content?: ContentUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutOther_CategoryInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutOther_CategoryInput, CategoryUncheckedCreateWithoutOther_CategoryInput>
  }

  export type CategoryCreateWithoutCategoryInput = {
    name: string
    slug: string
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    short_name: string
    Collection: CollectionCreateNestedOneWithoutCategoryInput
    Organization: OrganizationCreateNestedOneWithoutCategoryInput
    other_Category?: CategoryCreateNestedManyWithoutCategoryInput
    Content?: ContentCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    organization_id: number
    slug: string
    description?: string | null
    collection_id: number
    created_at?: Date | string
    updated_at: Date | string
    short_name: string
    other_Category?: CategoryUncheckedCreateNestedManyWithoutCategoryInput
    Content?: ContentUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutCategoryInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutCategoryInput, CategoryUncheckedCreateWithoutCategoryInput>
  }

  export type CategoryCreateManyCategoryInputEnvelope = {
    data: CategoryCreateManyCategoryInput | CategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ContentCreateWithoutCategoryInput = {
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    blocks: JsonNullValueInput | InputJsonValue
    html: string
    archive?: boolean
    description?: string | null
    draft?: boolean
    slug: string
    title?: string | null
    comments_enabled?: boolean
    featured?: boolean
    content_category?: ContentCreatecontent_categoryInput | string[]
    Comment?: CommentCreateNestedManyWithoutContentInput
    author?: authorCreateNestedOneWithoutContentInput
    Collection: CollectionCreateNestedOneWithoutContentInput
    Organization?: OrganizationCreateNestedOneWithoutContentInput
    ContentTemplateInstance?: ContentTemplateInstanceCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateWithoutCategoryInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    blocks: JsonNullValueInput | InputJsonValue
    html: string
    archive?: boolean
    collection_id: number
    description?: string | null
    draft?: boolean
    slug: string
    title?: string | null
    comments_enabled?: boolean
    organization_id?: number | null
    author_id?: number | null
    featured?: boolean
    content_category?: ContentCreatecontent_categoryInput | string[]
    Comment?: CommentUncheckedCreateNestedManyWithoutContentInput
    ContentTemplateInstance?: ContentTemplateInstanceUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutCategoryInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutCategoryInput, ContentUncheckedCreateWithoutCategoryInput>
  }

  export type CollectionUpsertWithoutCategoryInput = {
    update: XOR<CollectionUpdateWithoutCategoryInput, CollectionUncheckedUpdateWithoutCategoryInput>
    create: XOR<CollectionCreateWithoutCategoryInput, CollectionUncheckedCreateWithoutCategoryInput>
    where?: CollectionWhereInput
  }

  export type CollectionUpdateToOneWithWhereWithoutCategoryInput = {
    where?: CollectionWhereInput
    data: XOR<CollectionUpdateWithoutCategoryInput, CollectionUncheckedUpdateWithoutCategoryInput>
  }

  export type CollectionUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    page_content?: BoolFieldUpdateOperationsInput | boolean
    enable_author?: BoolFieldUpdateOperationsInput | boolean
    enable_comments?: BoolFieldUpdateOperationsInput | boolean
    enable_featured_posts?: BoolFieldUpdateOperationsInput | boolean
    enable_rating?: BoolFieldUpdateOperationsInput | boolean
    path_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    Organization?: OrganizationUpdateOneRequiredWithoutCollectionNestedInput
    Content?: ContentUpdateManyWithoutCollectionNestedInput
    Field?: FieldUpdateManyWithoutCollectionNestedInput
    Template?: TemplateUpdateManyWithoutCollectionNestedInput
    form_field?: form_fieldUpdateManyWithoutCollectionNestedInput
  }

  export type CollectionUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    page_content?: BoolFieldUpdateOperationsInput | boolean
    enable_author?: BoolFieldUpdateOperationsInput | boolean
    enable_comments?: BoolFieldUpdateOperationsInput | boolean
    enable_featured_posts?: BoolFieldUpdateOperationsInput | boolean
    enable_rating?: BoolFieldUpdateOperationsInput | boolean
    path_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: ContentUncheckedUpdateManyWithoutCollectionNestedInput
    Field?: FieldUncheckedUpdateManyWithoutCollectionNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutCollectionNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type OrganizationUpsertWithoutCategoryInput = {
    update: XOR<OrganizationUpdateWithoutCategoryInput, OrganizationUncheckedUpdateWithoutCategoryInput>
    create: XOR<OrganizationCreateWithoutCategoryInput, OrganizationUncheckedCreateWithoutCategoryInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutCategoryInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutCategoryInput, OrganizationUncheckedUpdateWithoutCategoryInput>
  }

  export type OrganizationUpdateWithoutCategoryInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type CategoryUpsertWithoutOther_CategoryInput = {
    update: XOR<CategoryUpdateWithoutOther_CategoryInput, CategoryUncheckedUpdateWithoutOther_CategoryInput>
    create: XOR<CategoryCreateWithoutOther_CategoryInput, CategoryUncheckedCreateWithoutOther_CategoryInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutOther_CategoryInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutOther_CategoryInput, CategoryUncheckedUpdateWithoutOther_CategoryInput>
  }

  export type CategoryUpdateWithoutOther_CategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    short_name?: StringFieldUpdateOperationsInput | string
    Collection?: CollectionUpdateOneRequiredWithoutCategoryNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutCategoryNestedInput
    Category?: CategoryUpdateOneWithoutOther_CategoryNestedInput
    Content?: ContentUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutOther_CategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    collection_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    short_name?: StringFieldUpdateOperationsInput | string
    Content?: ContentUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutCategoryInput, CategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<CategoryCreateWithoutCategoryInput, CategoryUncheckedCreateWithoutCategoryInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutCategoryInput, CategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type CategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    organization_id?: IntFilter<"Category"> | number
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    parent_id?: IntNullableFilter<"Category"> | number | null
    collection_id?: IntFilter<"Category"> | number
    created_at?: DateTimeFilter<"Category"> | Date | string
    updated_at?: DateTimeFilter<"Category"> | Date | string
    short_name?: StringFilter<"Category"> | string
  }

  export type ContentUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ContentWhereUniqueInput
    update: XOR<ContentUpdateWithoutCategoryInput, ContentUncheckedUpdateWithoutCategoryInput>
    create: XOR<ContentCreateWithoutCategoryInput, ContentUncheckedCreateWithoutCategoryInput>
  }

  export type ContentUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ContentWhereUniqueInput
    data: XOR<ContentUpdateWithoutCategoryInput, ContentUncheckedUpdateWithoutCategoryInput>
  }

  export type ContentUpdateManyWithWhereWithoutCategoryInput = {
    where: ContentScalarWhereInput
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ContentScalarWhereInput = {
    AND?: ContentScalarWhereInput | ContentScalarWhereInput[]
    OR?: ContentScalarWhereInput[]
    NOT?: ContentScalarWhereInput | ContentScalarWhereInput[]
    id?: IntFilter<"Content"> | number
    data?: JsonFilter<"Content">
    created_at?: DateTimeFilter<"Content"> | Date | string
    updated_at?: DateTimeFilter<"Content"> | Date | string
    blocks?: JsonFilter<"Content">
    html?: StringFilter<"Content"> | string
    archive?: BoolFilter<"Content"> | boolean
    collection_id?: IntFilter<"Content"> | number
    description?: StringNullableFilter<"Content"> | string | null
    draft?: BoolFilter<"Content"> | boolean
    slug?: StringFilter<"Content"> | string
    title?: StringNullableFilter<"Content"> | string | null
    comments_enabled?: BoolFilter<"Content"> | boolean
    organization_id?: IntNullableFilter<"Content"> | number | null
    author_id?: IntNullableFilter<"Content"> | number | null
    featured?: BoolFilter<"Content"> | boolean
    content_category?: StringNullableListFilter<"Content">
  }

  export type CategoryCreateWithoutCollectionInput = {
    name: string
    slug: string
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    short_name: string
    Organization: OrganizationCreateNestedOneWithoutCategoryInput
    Category?: CategoryCreateNestedOneWithoutOther_CategoryInput
    other_Category?: CategoryCreateNestedManyWithoutCategoryInput
    Content?: ContentCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutCollectionInput = {
    id?: number
    name: string
    organization_id: number
    slug: string
    description?: string | null
    parent_id?: number | null
    created_at?: Date | string
    updated_at: Date | string
    short_name: string
    other_Category?: CategoryUncheckedCreateNestedManyWithoutCategoryInput
    Content?: ContentUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutCollectionInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutCollectionInput, CategoryUncheckedCreateWithoutCollectionInput>
  }

  export type CategoryCreateManyCollectionInputEnvelope = {
    data: CategoryCreateManyCollectionInput | CategoryCreateManyCollectionInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationCreateWithoutCollectionInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutCollectionInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutCollectionInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutCollectionInput, OrganizationUncheckedCreateWithoutCollectionInput>
  }

  export type ContentCreateWithoutCollectionInput = {
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    blocks: JsonNullValueInput | InputJsonValue
    html: string
    archive?: boolean
    description?: string | null
    draft?: boolean
    slug: string
    title?: string | null
    comments_enabled?: boolean
    featured?: boolean
    content_category?: ContentCreatecontent_categoryInput | string[]
    Comment?: CommentCreateNestedManyWithoutContentInput
    author?: authorCreateNestedOneWithoutContentInput
    Organization?: OrganizationCreateNestedOneWithoutContentInput
    ContentTemplateInstance?: ContentTemplateInstanceCreateNestedManyWithoutContentInput
    Category?: CategoryCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateWithoutCollectionInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    blocks: JsonNullValueInput | InputJsonValue
    html: string
    archive?: boolean
    description?: string | null
    draft?: boolean
    slug: string
    title?: string | null
    comments_enabled?: boolean
    organization_id?: number | null
    author_id?: number | null
    featured?: boolean
    content_category?: ContentCreatecontent_categoryInput | string[]
    Comment?: CommentUncheckedCreateNestedManyWithoutContentInput
    ContentTemplateInstance?: ContentTemplateInstanceUncheckedCreateNestedManyWithoutContentInput
    Category?: CategoryUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutCollectionInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutCollectionInput, ContentUncheckedCreateWithoutCollectionInput>
  }

  export type ContentCreateManyCollectionInputEnvelope = {
    data: ContentCreateManyCollectionInput | ContentCreateManyCollectionInput[]
    skipDuplicates?: boolean
  }

  export type FieldCreateWithoutCollectionInput = {
    name: string
    type: string
    required: boolean
    options?: FieldCreateoptionsInput | string[]
    created_at?: Date | string
    updated_at: Date | string
    Template?: TemplateCreateNestedOneWithoutFieldInput
  }

  export type FieldUncheckedCreateWithoutCollectionInput = {
    id?: number
    name: string
    type: string
    required: boolean
    options?: FieldCreateoptionsInput | string[]
    created_at?: Date | string
    updated_at: Date | string
    template_id?: number | null
  }

  export type FieldCreateOrConnectWithoutCollectionInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutCollectionInput, FieldUncheckedCreateWithoutCollectionInput>
  }

  export type FieldCreateManyCollectionInputEnvelope = {
    data: FieldCreateManyCollectionInput | FieldCreateManyCollectionInput[]
    skipDuplicates?: boolean
  }

  export type TemplateCreateWithoutCollectionInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    Field?: FieldCreateNestedManyWithoutTemplateInput
    TemplateInstance?: TemplateInstanceCreateNestedManyWithoutTemplateInput
  }

  export type TemplateUncheckedCreateWithoutCollectionInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    Field?: FieldUncheckedCreateNestedManyWithoutTemplateInput
    TemplateInstance?: TemplateInstanceUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type TemplateCreateOrConnectWithoutCollectionInput = {
    where: TemplateWhereUniqueInput
    create: XOR<TemplateCreateWithoutCollectionInput, TemplateUncheckedCreateWithoutCollectionInput>
  }

  export type TemplateCreateManyCollectionInputEnvelope = {
    data: TemplateCreateManyCollectionInput | TemplateCreateManyCollectionInput[]
    skipDuplicates?: boolean
  }

  export type form_fieldCreateWithoutCollectionInput = {
    name: string
    required?: boolean
    created_at?: Date | string
    updated_at: Date | string
    type: $Enums.field_type
    default_value?: string | null
    help?: string | null
    order?: number
    description?: string | null
    label: string
    placeholder?: string | null
    regex?: string | null
    options?: form_fieldCreateoptionsInput | InputJsonValue[]
    Organization: OrganizationCreateNestedOneWithoutForm_fieldInput
    struct?: structCreateNestedOneWithoutForm_fieldInput
  }

  export type form_fieldUncheckedCreateWithoutCollectionInput = {
    id?: number
    name: string
    required?: boolean
    created_at?: Date | string
    updated_at: Date | string
    type: $Enums.field_type
    default_value?: string | null
    help?: string | null
    order?: number
    description?: string | null
    label: string
    placeholder?: string | null
    regex?: string | null
    organization_id: number
    options?: form_fieldCreateoptionsInput | InputJsonValue[]
    struct_id?: number | null
  }

  export type form_fieldCreateOrConnectWithoutCollectionInput = {
    where: form_fieldWhereUniqueInput
    create: XOR<form_fieldCreateWithoutCollectionInput, form_fieldUncheckedCreateWithoutCollectionInput>
  }

  export type form_fieldCreateManyCollectionInputEnvelope = {
    data: form_fieldCreateManyCollectionInput | form_fieldCreateManyCollectionInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithWhereUniqueWithoutCollectionInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutCollectionInput, CategoryUncheckedUpdateWithoutCollectionInput>
    create: XOR<CategoryCreateWithoutCollectionInput, CategoryUncheckedCreateWithoutCollectionInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutCollectionInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutCollectionInput, CategoryUncheckedUpdateWithoutCollectionInput>
  }

  export type CategoryUpdateManyWithWhereWithoutCollectionInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutCollectionInput>
  }

  export type OrganizationUpsertWithoutCollectionInput = {
    update: XOR<OrganizationUpdateWithoutCollectionInput, OrganizationUncheckedUpdateWithoutCollectionInput>
    create: XOR<OrganizationCreateWithoutCollectionInput, OrganizationUncheckedCreateWithoutCollectionInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutCollectionInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutCollectionInput, OrganizationUncheckedUpdateWithoutCollectionInput>
  }

  export type OrganizationUpdateWithoutCollectionInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutCollectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ContentUpsertWithWhereUniqueWithoutCollectionInput = {
    where: ContentWhereUniqueInput
    update: XOR<ContentUpdateWithoutCollectionInput, ContentUncheckedUpdateWithoutCollectionInput>
    create: XOR<ContentCreateWithoutCollectionInput, ContentUncheckedCreateWithoutCollectionInput>
  }

  export type ContentUpdateWithWhereUniqueWithoutCollectionInput = {
    where: ContentWhereUniqueInput
    data: XOR<ContentUpdateWithoutCollectionInput, ContentUncheckedUpdateWithoutCollectionInput>
  }

  export type ContentUpdateManyWithWhereWithoutCollectionInput = {
    where: ContentScalarWhereInput
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyWithoutCollectionInput>
  }

  export type FieldUpsertWithWhereUniqueWithoutCollectionInput = {
    where: FieldWhereUniqueInput
    update: XOR<FieldUpdateWithoutCollectionInput, FieldUncheckedUpdateWithoutCollectionInput>
    create: XOR<FieldCreateWithoutCollectionInput, FieldUncheckedCreateWithoutCollectionInput>
  }

  export type FieldUpdateWithWhereUniqueWithoutCollectionInput = {
    where: FieldWhereUniqueInput
    data: XOR<FieldUpdateWithoutCollectionInput, FieldUncheckedUpdateWithoutCollectionInput>
  }

  export type FieldUpdateManyWithWhereWithoutCollectionInput = {
    where: FieldScalarWhereInput
    data: XOR<FieldUpdateManyMutationInput, FieldUncheckedUpdateManyWithoutCollectionInput>
  }

  export type FieldScalarWhereInput = {
    AND?: FieldScalarWhereInput | FieldScalarWhereInput[]
    OR?: FieldScalarWhereInput[]
    NOT?: FieldScalarWhereInput | FieldScalarWhereInput[]
    id?: IntFilter<"Field"> | number
    name?: StringFilter<"Field"> | string
    type?: StringFilter<"Field"> | string
    required?: BoolFilter<"Field"> | boolean
    options?: StringNullableListFilter<"Field">
    created_at?: DateTimeFilter<"Field"> | Date | string
    updated_at?: DateTimeFilter<"Field"> | Date | string
    template_id?: IntNullableFilter<"Field"> | number | null
    collection_id?: IntNullableFilter<"Field"> | number | null
  }

  export type TemplateUpsertWithWhereUniqueWithoutCollectionInput = {
    where: TemplateWhereUniqueInput
    update: XOR<TemplateUpdateWithoutCollectionInput, TemplateUncheckedUpdateWithoutCollectionInput>
    create: XOR<TemplateCreateWithoutCollectionInput, TemplateUncheckedCreateWithoutCollectionInput>
  }

  export type TemplateUpdateWithWhereUniqueWithoutCollectionInput = {
    where: TemplateWhereUniqueInput
    data: XOR<TemplateUpdateWithoutCollectionInput, TemplateUncheckedUpdateWithoutCollectionInput>
  }

  export type TemplateUpdateManyWithWhereWithoutCollectionInput = {
    where: TemplateScalarWhereInput
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyWithoutCollectionInput>
  }

  export type TemplateScalarWhereInput = {
    AND?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
    OR?: TemplateScalarWhereInput[]
    NOT?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
    id?: IntFilter<"Template"> | number
    name?: StringFilter<"Template"> | string
    collection_id?: IntFilter<"Template"> | number
    created_at?: DateTimeFilter<"Template"> | Date | string
    updated_at?: DateTimeFilter<"Template"> | Date | string
  }

  export type form_fieldUpsertWithWhereUniqueWithoutCollectionInput = {
    where: form_fieldWhereUniqueInput
    update: XOR<form_fieldUpdateWithoutCollectionInput, form_fieldUncheckedUpdateWithoutCollectionInput>
    create: XOR<form_fieldCreateWithoutCollectionInput, form_fieldUncheckedCreateWithoutCollectionInput>
  }

  export type form_fieldUpdateWithWhereUniqueWithoutCollectionInput = {
    where: form_fieldWhereUniqueInput
    data: XOR<form_fieldUpdateWithoutCollectionInput, form_fieldUncheckedUpdateWithoutCollectionInput>
  }

  export type form_fieldUpdateManyWithWhereWithoutCollectionInput = {
    where: form_fieldScalarWhereInput
    data: XOR<form_fieldUpdateManyMutationInput, form_fieldUncheckedUpdateManyWithoutCollectionInput>
  }

  export type form_fieldScalarWhereInput = {
    AND?: form_fieldScalarWhereInput | form_fieldScalarWhereInput[]
    OR?: form_fieldScalarWhereInput[]
    NOT?: form_fieldScalarWhereInput | form_fieldScalarWhereInput[]
    id?: IntFilter<"form_field"> | number
    name?: StringFilter<"form_field"> | string
    required?: BoolFilter<"form_field"> | boolean
    created_at?: DateTimeFilter<"form_field"> | Date | string
    updated_at?: DateTimeFilter<"form_field"> | Date | string
    type?: Enumfield_typeFilter<"form_field"> | $Enums.field_type
    default_value?: StringNullableFilter<"form_field"> | string | null
    help?: StringNullableFilter<"form_field"> | string | null
    order?: FloatFilter<"form_field"> | number
    description?: StringNullableFilter<"form_field"> | string | null
    label?: StringFilter<"form_field"> | string
    placeholder?: StringNullableFilter<"form_field"> | string | null
    regex?: StringNullableFilter<"form_field"> | string | null
    organization_id?: IntFilter<"form_field"> | number
    collection_id?: IntNullableFilter<"form_field"> | number | null
    options?: JsonNullableListFilter<"form_field">
    struct_id?: IntNullableFilter<"form_field"> | number | null
  }

  export type ContentCreateWithoutCommentInput = {
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    blocks: JsonNullValueInput | InputJsonValue
    html: string
    archive?: boolean
    description?: string | null
    draft?: boolean
    slug: string
    title?: string | null
    comments_enabled?: boolean
    featured?: boolean
    content_category?: ContentCreatecontent_categoryInput | string[]
    author?: authorCreateNestedOneWithoutContentInput
    Collection: CollectionCreateNestedOneWithoutContentInput
    Organization?: OrganizationCreateNestedOneWithoutContentInput
    ContentTemplateInstance?: ContentTemplateInstanceCreateNestedManyWithoutContentInput
    Category?: CategoryCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateWithoutCommentInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    blocks: JsonNullValueInput | InputJsonValue
    html: string
    archive?: boolean
    collection_id: number
    description?: string | null
    draft?: boolean
    slug: string
    title?: string | null
    comments_enabled?: boolean
    organization_id?: number | null
    author_id?: number | null
    featured?: boolean
    content_category?: ContentCreatecontent_categoryInput | string[]
    ContentTemplateInstance?: ContentTemplateInstanceUncheckedCreateNestedManyWithoutContentInput
    Category?: CategoryUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutCommentInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutCommentInput, ContentUncheckedCreateWithoutCommentInput>
  }

  export type OrganizationCreateWithoutCommentInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutCommentInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutCommentInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutCommentInput, OrganizationUncheckedCreateWithoutCommentInput>
  }

  export type CommentCreateWithoutOther_CommentInput = {
    text: string
    author: string
    created_at?: Date | string
    updated_at: Date | string
    approved?: boolean
    email: string
    image_url?: string | null
    rating?: number | null
    Content: ContentCreateNestedOneWithoutCommentInput
    Organization: OrganizationCreateNestedOneWithoutCommentInput
    Comment?: CommentCreateNestedOneWithoutOther_CommentInput
  }

  export type CommentUncheckedCreateWithoutOther_CommentInput = {
    id?: number
    text: string
    author: string
    content_id: number
    parent_id?: number | null
    created_at?: Date | string
    updated_at: Date | string
    approved?: boolean
    organization_id: number
    email: string
    image_url?: string | null
    rating?: number | null
  }

  export type CommentCreateOrConnectWithoutOther_CommentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutOther_CommentInput, CommentUncheckedCreateWithoutOther_CommentInput>
  }

  export type CommentCreateWithoutCommentInput = {
    text: string
    author: string
    created_at?: Date | string
    updated_at: Date | string
    approved?: boolean
    email: string
    image_url?: string | null
    rating?: number | null
    Content: ContentCreateNestedOneWithoutCommentInput
    Organization: OrganizationCreateNestedOneWithoutCommentInput
    other_Comment?: CommentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutCommentInput = {
    id?: number
    text: string
    author: string
    content_id: number
    created_at?: Date | string
    updated_at: Date | string
    approved?: boolean
    organization_id: number
    email: string
    image_url?: string | null
    rating?: number | null
    other_Comment?: CommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutCommentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutCommentInput, CommentUncheckedCreateWithoutCommentInput>
  }

  export type CommentCreateManyCommentInputEnvelope = {
    data: CommentCreateManyCommentInput | CommentCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type ContentUpsertWithoutCommentInput = {
    update: XOR<ContentUpdateWithoutCommentInput, ContentUncheckedUpdateWithoutCommentInput>
    create: XOR<ContentCreateWithoutCommentInput, ContentUncheckedCreateWithoutCommentInput>
    where?: ContentWhereInput
  }

  export type ContentUpdateToOneWithWhereWithoutCommentInput = {
    where?: ContentWhereInput
    data: XOR<ContentUpdateWithoutCommentInput, ContentUncheckedUpdateWithoutCommentInput>
  }

  export type ContentUpdateWithoutCommentInput = {
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: JsonNullValueInput | InputJsonValue
    html?: StringFieldUpdateOperationsInput | string
    archive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    draft?: BoolFieldUpdateOperationsInput | boolean
    slug?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comments_enabled?: BoolFieldUpdateOperationsInput | boolean
    featured?: BoolFieldUpdateOperationsInput | boolean
    content_category?: ContentUpdatecontent_categoryInput | string[]
    author?: authorUpdateOneWithoutContentNestedInput
    Collection?: CollectionUpdateOneRequiredWithoutContentNestedInput
    Organization?: OrganizationUpdateOneWithoutContentNestedInput
    ContentTemplateInstance?: ContentTemplateInstanceUpdateManyWithoutContentNestedInput
    Category?: CategoryUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: JsonNullValueInput | InputJsonValue
    html?: StringFieldUpdateOperationsInput | string
    archive?: BoolFieldUpdateOperationsInput | boolean
    collection_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    draft?: BoolFieldUpdateOperationsInput | boolean
    slug?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comments_enabled?: BoolFieldUpdateOperationsInput | boolean
    organization_id?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    content_category?: ContentUpdatecontent_categoryInput | string[]
    ContentTemplateInstance?: ContentTemplateInstanceUncheckedUpdateManyWithoutContentNestedInput
    Category?: CategoryUncheckedUpdateManyWithoutContentNestedInput
  }

  export type OrganizationUpsertWithoutCommentInput = {
    update: XOR<OrganizationUpdateWithoutCommentInput, OrganizationUncheckedUpdateWithoutCommentInput>
    create: XOR<OrganizationCreateWithoutCommentInput, OrganizationUncheckedCreateWithoutCommentInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutCommentInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutCommentInput, OrganizationUncheckedUpdateWithoutCommentInput>
  }

  export type OrganizationUpdateWithoutCommentInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type CommentUpsertWithoutOther_CommentInput = {
    update: XOR<CommentUpdateWithoutOther_CommentInput, CommentUncheckedUpdateWithoutOther_CommentInput>
    create: XOR<CommentCreateWithoutOther_CommentInput, CommentUncheckedCreateWithoutOther_CommentInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutOther_CommentInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutOther_CommentInput, CommentUncheckedUpdateWithoutOther_CommentInput>
  }

  export type CommentUpdateWithoutOther_CommentInput = {
    text?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    Content?: ContentUpdateOneRequiredWithoutCommentNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutCommentNestedInput
    Comment?: CommentUpdateOneWithoutOther_CommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutOther_CommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    content_id?: IntFieldUpdateOperationsInput | number
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    organization_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommentUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutCommentInput, CommentUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentCreateWithoutCommentInput, CommentUncheckedCreateWithoutCommentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutCommentInput, CommentUncheckedUpdateWithoutCommentInput>
  }

  export type CommentUpdateManyWithWhereWithoutCommentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCommentInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: IntFilter<"Comment"> | number
    text?: StringFilter<"Comment"> | string
    author?: StringFilter<"Comment"> | string
    content_id?: IntFilter<"Comment"> | number
    parent_id?: IntNullableFilter<"Comment"> | number | null
    created_at?: DateTimeFilter<"Comment"> | Date | string
    updated_at?: DateTimeFilter<"Comment"> | Date | string
    approved?: BoolFilter<"Comment"> | boolean
    organization_id?: IntFilter<"Comment"> | number
    email?: StringFilter<"Comment"> | string
    image_url?: StringNullableFilter<"Comment"> | string | null
    rating?: IntNullableFilter<"Comment"> | number | null
  }

  export type OrganizationCreateWithoutCompletionUsageInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutCompletionUsageInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutCompletionUsageInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutCompletionUsageInput, OrganizationUncheckedCreateWithoutCompletionUsageInput>
  }

  export type OrganizationUpsertWithoutCompletionUsageInput = {
    update: XOR<OrganizationUpdateWithoutCompletionUsageInput, OrganizationUncheckedUpdateWithoutCompletionUsageInput>
    create: XOR<OrganizationCreateWithoutCompletionUsageInput, OrganizationUncheckedCreateWithoutCompletionUsageInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutCompletionUsageInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutCompletionUsageInput, OrganizationUncheckedUpdateWithoutCompletionUsageInput>
  }

  export type OrganizationUpdateWithoutCompletionUsageInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutCompletionUsageInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type CommentCreateWithoutContentInput = {
    text: string
    author: string
    created_at?: Date | string
    updated_at: Date | string
    approved?: boolean
    email: string
    image_url?: string | null
    rating?: number | null
    Organization: OrganizationCreateNestedOneWithoutCommentInput
    Comment?: CommentCreateNestedOneWithoutOther_CommentInput
    other_Comment?: CommentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutContentInput = {
    id?: number
    text: string
    author: string
    parent_id?: number | null
    created_at?: Date | string
    updated_at: Date | string
    approved?: boolean
    organization_id: number
    email: string
    image_url?: string | null
    rating?: number | null
    other_Comment?: CommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutContentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutContentInput, CommentUncheckedCreateWithoutContentInput>
  }

  export type CommentCreateManyContentInputEnvelope = {
    data: CommentCreateManyContentInput | CommentCreateManyContentInput[]
    skipDuplicates?: boolean
  }

  export type authorCreateWithoutContentInput = {
    created_at?: Date | string
    updated_at: Date | string
    name: string
    description: string
    slug: string
    Media: MediaCreateNestedOneWithoutAuthorInput
    Organization: OrganizationCreateNestedOneWithoutAuthorInput
  }

  export type authorUncheckedCreateWithoutContentInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    name: string
    description: string
    organization_id: number
    media_id: number
    slug: string
  }

  export type authorCreateOrConnectWithoutContentInput = {
    where: authorWhereUniqueInput
    create: XOR<authorCreateWithoutContentInput, authorUncheckedCreateWithoutContentInput>
  }

  export type CollectionCreateWithoutContentInput = {
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    icon: string
    page_content?: boolean
    enable_author?: boolean
    enable_comments?: boolean
    enable_featured_posts?: boolean
    enable_rating?: boolean
    path_prefix?: string | null
    title?: string | null
    Category?: CategoryCreateNestedManyWithoutCollectionInput
    Organization: OrganizationCreateNestedOneWithoutCollectionInput
    Field?: FieldCreateNestedManyWithoutCollectionInput
    Template?: TemplateCreateNestedManyWithoutCollectionInput
    form_field?: form_fieldCreateNestedManyWithoutCollectionInput
  }

  export type CollectionUncheckedCreateWithoutContentInput = {
    id?: number
    name: string
    organization_id: number
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    icon: string
    page_content?: boolean
    enable_author?: boolean
    enable_comments?: boolean
    enable_featured_posts?: boolean
    enable_rating?: boolean
    path_prefix?: string | null
    title?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutCollectionInput
    Field?: FieldUncheckedCreateNestedManyWithoutCollectionInput
    Template?: TemplateUncheckedCreateNestedManyWithoutCollectionInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type CollectionCreateOrConnectWithoutContentInput = {
    where: CollectionWhereUniqueInput
    create: XOR<CollectionCreateWithoutContentInput, CollectionUncheckedCreateWithoutContentInput>
  }

  export type OrganizationCreateWithoutContentInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutContentInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutContentInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutContentInput, OrganizationUncheckedCreateWithoutContentInput>
  }

  export type ContentTemplateInstanceCreateWithoutContentInput = {
    TemplateInstance: TemplateInstanceCreateNestedOneWithoutContentTemplateInstanceInput
  }

  export type ContentTemplateInstanceUncheckedCreateWithoutContentInput = {
    id?: number
    template_instance_id: number
  }

  export type ContentTemplateInstanceCreateOrConnectWithoutContentInput = {
    where: ContentTemplateInstanceWhereUniqueInput
    create: XOR<ContentTemplateInstanceCreateWithoutContentInput, ContentTemplateInstanceUncheckedCreateWithoutContentInput>
  }

  export type ContentTemplateInstanceCreateManyContentInputEnvelope = {
    data: ContentTemplateInstanceCreateManyContentInput | ContentTemplateInstanceCreateManyContentInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutContentInput = {
    name: string
    slug: string
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    short_name: string
    Collection: CollectionCreateNestedOneWithoutCategoryInput
    Organization: OrganizationCreateNestedOneWithoutCategoryInput
    Category?: CategoryCreateNestedOneWithoutOther_CategoryInput
    other_Category?: CategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutContentInput = {
    id?: number
    name: string
    organization_id: number
    slug: string
    description?: string | null
    parent_id?: number | null
    collection_id: number
    created_at?: Date | string
    updated_at: Date | string
    short_name: string
    other_Category?: CategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutContentInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutContentInput, CategoryUncheckedCreateWithoutContentInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutContentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutContentInput, CommentUncheckedUpdateWithoutContentInput>
    create: XOR<CommentCreateWithoutContentInput, CommentUncheckedCreateWithoutContentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutContentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutContentInput, CommentUncheckedUpdateWithoutContentInput>
  }

  export type CommentUpdateManyWithWhereWithoutContentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutContentInput>
  }

  export type authorUpsertWithoutContentInput = {
    update: XOR<authorUpdateWithoutContentInput, authorUncheckedUpdateWithoutContentInput>
    create: XOR<authorCreateWithoutContentInput, authorUncheckedCreateWithoutContentInput>
    where?: authorWhereInput
  }

  export type authorUpdateToOneWithWhereWithoutContentInput = {
    where?: authorWhereInput
    data: XOR<authorUpdateWithoutContentInput, authorUncheckedUpdateWithoutContentInput>
  }

  export type authorUpdateWithoutContentInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    Media?: MediaUpdateOneRequiredWithoutAuthorNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutAuthorNestedInput
  }

  export type authorUncheckedUpdateWithoutContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    media_id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type CollectionUpsertWithoutContentInput = {
    update: XOR<CollectionUpdateWithoutContentInput, CollectionUncheckedUpdateWithoutContentInput>
    create: XOR<CollectionCreateWithoutContentInput, CollectionUncheckedCreateWithoutContentInput>
    where?: CollectionWhereInput
  }

  export type CollectionUpdateToOneWithWhereWithoutContentInput = {
    where?: CollectionWhereInput
    data: XOR<CollectionUpdateWithoutContentInput, CollectionUncheckedUpdateWithoutContentInput>
  }

  export type CollectionUpdateWithoutContentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    page_content?: BoolFieldUpdateOperationsInput | boolean
    enable_author?: BoolFieldUpdateOperationsInput | boolean
    enable_comments?: BoolFieldUpdateOperationsInput | boolean
    enable_featured_posts?: BoolFieldUpdateOperationsInput | boolean
    enable_rating?: BoolFieldUpdateOperationsInput | boolean
    path_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutCollectionNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutCollectionNestedInput
    Field?: FieldUpdateManyWithoutCollectionNestedInput
    Template?: TemplateUpdateManyWithoutCollectionNestedInput
    form_field?: form_fieldUpdateManyWithoutCollectionNestedInput
  }

  export type CollectionUncheckedUpdateWithoutContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    page_content?: BoolFieldUpdateOperationsInput | boolean
    enable_author?: BoolFieldUpdateOperationsInput | boolean
    enable_comments?: BoolFieldUpdateOperationsInput | boolean
    enable_featured_posts?: BoolFieldUpdateOperationsInput | boolean
    enable_rating?: BoolFieldUpdateOperationsInput | boolean
    path_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutCollectionNestedInput
    Field?: FieldUncheckedUpdateManyWithoutCollectionNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutCollectionNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type OrganizationUpsertWithoutContentInput = {
    update: XOR<OrganizationUpdateWithoutContentInput, OrganizationUncheckedUpdateWithoutContentInput>
    create: XOR<OrganizationCreateWithoutContentInput, OrganizationUncheckedCreateWithoutContentInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutContentInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutContentInput, OrganizationUncheckedUpdateWithoutContentInput>
  }

  export type OrganizationUpdateWithoutContentInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ContentTemplateInstanceUpsertWithWhereUniqueWithoutContentInput = {
    where: ContentTemplateInstanceWhereUniqueInput
    update: XOR<ContentTemplateInstanceUpdateWithoutContentInput, ContentTemplateInstanceUncheckedUpdateWithoutContentInput>
    create: XOR<ContentTemplateInstanceCreateWithoutContentInput, ContentTemplateInstanceUncheckedCreateWithoutContentInput>
  }

  export type ContentTemplateInstanceUpdateWithWhereUniqueWithoutContentInput = {
    where: ContentTemplateInstanceWhereUniqueInput
    data: XOR<ContentTemplateInstanceUpdateWithoutContentInput, ContentTemplateInstanceUncheckedUpdateWithoutContentInput>
  }

  export type ContentTemplateInstanceUpdateManyWithWhereWithoutContentInput = {
    where: ContentTemplateInstanceScalarWhereInput
    data: XOR<ContentTemplateInstanceUpdateManyMutationInput, ContentTemplateInstanceUncheckedUpdateManyWithoutContentInput>
  }

  export type ContentTemplateInstanceScalarWhereInput = {
    AND?: ContentTemplateInstanceScalarWhereInput | ContentTemplateInstanceScalarWhereInput[]
    OR?: ContentTemplateInstanceScalarWhereInput[]
    NOT?: ContentTemplateInstanceScalarWhereInput | ContentTemplateInstanceScalarWhereInput[]
    id?: IntFilter<"ContentTemplateInstance"> | number
    content_id?: IntFilter<"ContentTemplateInstance"> | number
    template_instance_id?: IntFilter<"ContentTemplateInstance"> | number
  }

  export type CategoryUpsertWithWhereUniqueWithoutContentInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutContentInput, CategoryUncheckedUpdateWithoutContentInput>
    create: XOR<CategoryCreateWithoutContentInput, CategoryUncheckedCreateWithoutContentInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutContentInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutContentInput, CategoryUncheckedUpdateWithoutContentInput>
  }

  export type CategoryUpdateManyWithWhereWithoutContentInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutContentInput>
  }

  export type ContentCreateWithoutContentTemplateInstanceInput = {
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    blocks: JsonNullValueInput | InputJsonValue
    html: string
    archive?: boolean
    description?: string | null
    draft?: boolean
    slug: string
    title?: string | null
    comments_enabled?: boolean
    featured?: boolean
    content_category?: ContentCreatecontent_categoryInput | string[]
    Comment?: CommentCreateNestedManyWithoutContentInput
    author?: authorCreateNestedOneWithoutContentInput
    Collection: CollectionCreateNestedOneWithoutContentInput
    Organization?: OrganizationCreateNestedOneWithoutContentInput
    Category?: CategoryCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateWithoutContentTemplateInstanceInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    blocks: JsonNullValueInput | InputJsonValue
    html: string
    archive?: boolean
    collection_id: number
    description?: string | null
    draft?: boolean
    slug: string
    title?: string | null
    comments_enabled?: boolean
    organization_id?: number | null
    author_id?: number | null
    featured?: boolean
    content_category?: ContentCreatecontent_categoryInput | string[]
    Comment?: CommentUncheckedCreateNestedManyWithoutContentInput
    Category?: CategoryUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutContentTemplateInstanceInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutContentTemplateInstanceInput, ContentUncheckedCreateWithoutContentTemplateInstanceInput>
  }

  export type TemplateInstanceCreateWithoutContentTemplateInstanceInput = {
    values: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    title: string
    Template: TemplateCreateNestedOneWithoutTemplateInstanceInput
  }

  export type TemplateInstanceUncheckedCreateWithoutContentTemplateInstanceInput = {
    id?: number
    values: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    title: string
    templateId: number
  }

  export type TemplateInstanceCreateOrConnectWithoutContentTemplateInstanceInput = {
    where: TemplateInstanceWhereUniqueInput
    create: XOR<TemplateInstanceCreateWithoutContentTemplateInstanceInput, TemplateInstanceUncheckedCreateWithoutContentTemplateInstanceInput>
  }

  export type ContentUpsertWithoutContentTemplateInstanceInput = {
    update: XOR<ContentUpdateWithoutContentTemplateInstanceInput, ContentUncheckedUpdateWithoutContentTemplateInstanceInput>
    create: XOR<ContentCreateWithoutContentTemplateInstanceInput, ContentUncheckedCreateWithoutContentTemplateInstanceInput>
    where?: ContentWhereInput
  }

  export type ContentUpdateToOneWithWhereWithoutContentTemplateInstanceInput = {
    where?: ContentWhereInput
    data: XOR<ContentUpdateWithoutContentTemplateInstanceInput, ContentUncheckedUpdateWithoutContentTemplateInstanceInput>
  }

  export type ContentUpdateWithoutContentTemplateInstanceInput = {
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: JsonNullValueInput | InputJsonValue
    html?: StringFieldUpdateOperationsInput | string
    archive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    draft?: BoolFieldUpdateOperationsInput | boolean
    slug?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comments_enabled?: BoolFieldUpdateOperationsInput | boolean
    featured?: BoolFieldUpdateOperationsInput | boolean
    content_category?: ContentUpdatecontent_categoryInput | string[]
    Comment?: CommentUpdateManyWithoutContentNestedInput
    author?: authorUpdateOneWithoutContentNestedInput
    Collection?: CollectionUpdateOneRequiredWithoutContentNestedInput
    Organization?: OrganizationUpdateOneWithoutContentNestedInput
    Category?: CategoryUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutContentTemplateInstanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: JsonNullValueInput | InputJsonValue
    html?: StringFieldUpdateOperationsInput | string
    archive?: BoolFieldUpdateOperationsInput | boolean
    collection_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    draft?: BoolFieldUpdateOperationsInput | boolean
    slug?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comments_enabled?: BoolFieldUpdateOperationsInput | boolean
    organization_id?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    content_category?: ContentUpdatecontent_categoryInput | string[]
    Comment?: CommentUncheckedUpdateManyWithoutContentNestedInput
    Category?: CategoryUncheckedUpdateManyWithoutContentNestedInput
  }

  export type TemplateInstanceUpsertWithoutContentTemplateInstanceInput = {
    update: XOR<TemplateInstanceUpdateWithoutContentTemplateInstanceInput, TemplateInstanceUncheckedUpdateWithoutContentTemplateInstanceInput>
    create: XOR<TemplateInstanceCreateWithoutContentTemplateInstanceInput, TemplateInstanceUncheckedCreateWithoutContentTemplateInstanceInput>
    where?: TemplateInstanceWhereInput
  }

  export type TemplateInstanceUpdateToOneWithWhereWithoutContentTemplateInstanceInput = {
    where?: TemplateInstanceWhereInput
    data: XOR<TemplateInstanceUpdateWithoutContentTemplateInstanceInput, TemplateInstanceUncheckedUpdateWithoutContentTemplateInstanceInput>
  }

  export type TemplateInstanceUpdateWithoutContentTemplateInstanceInput = {
    values?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    Template?: TemplateUpdateOneRequiredWithoutTemplateInstanceNestedInput
  }

  export type TemplateInstanceUncheckedUpdateWithoutContentTemplateInstanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    templateId?: IntFieldUpdateOperationsInput | number
  }

  export type CollectionCreateWithoutFieldInput = {
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    icon: string
    page_content?: boolean
    enable_author?: boolean
    enable_comments?: boolean
    enable_featured_posts?: boolean
    enable_rating?: boolean
    path_prefix?: string | null
    title?: string | null
    Category?: CategoryCreateNestedManyWithoutCollectionInput
    Organization: OrganizationCreateNestedOneWithoutCollectionInput
    Content?: ContentCreateNestedManyWithoutCollectionInput
    Template?: TemplateCreateNestedManyWithoutCollectionInput
    form_field?: form_fieldCreateNestedManyWithoutCollectionInput
  }

  export type CollectionUncheckedCreateWithoutFieldInput = {
    id?: number
    name: string
    organization_id: number
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    icon: string
    page_content?: boolean
    enable_author?: boolean
    enable_comments?: boolean
    enable_featured_posts?: boolean
    enable_rating?: boolean
    path_prefix?: string | null
    title?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutCollectionInput
    Content?: ContentUncheckedCreateNestedManyWithoutCollectionInput
    Template?: TemplateUncheckedCreateNestedManyWithoutCollectionInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type CollectionCreateOrConnectWithoutFieldInput = {
    where: CollectionWhereUniqueInput
    create: XOR<CollectionCreateWithoutFieldInput, CollectionUncheckedCreateWithoutFieldInput>
  }

  export type TemplateCreateWithoutFieldInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    Collection: CollectionCreateNestedOneWithoutTemplateInput
    TemplateInstance?: TemplateInstanceCreateNestedManyWithoutTemplateInput
  }

  export type TemplateUncheckedCreateWithoutFieldInput = {
    id?: number
    name: string
    collection_id: number
    created_at?: Date | string
    updated_at: Date | string
    TemplateInstance?: TemplateInstanceUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type TemplateCreateOrConnectWithoutFieldInput = {
    where: TemplateWhereUniqueInput
    create: XOR<TemplateCreateWithoutFieldInput, TemplateUncheckedCreateWithoutFieldInput>
  }

  export type CollectionUpsertWithoutFieldInput = {
    update: XOR<CollectionUpdateWithoutFieldInput, CollectionUncheckedUpdateWithoutFieldInput>
    create: XOR<CollectionCreateWithoutFieldInput, CollectionUncheckedCreateWithoutFieldInput>
    where?: CollectionWhereInput
  }

  export type CollectionUpdateToOneWithWhereWithoutFieldInput = {
    where?: CollectionWhereInput
    data: XOR<CollectionUpdateWithoutFieldInput, CollectionUncheckedUpdateWithoutFieldInput>
  }

  export type CollectionUpdateWithoutFieldInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    page_content?: BoolFieldUpdateOperationsInput | boolean
    enable_author?: BoolFieldUpdateOperationsInput | boolean
    enable_comments?: BoolFieldUpdateOperationsInput | boolean
    enable_featured_posts?: BoolFieldUpdateOperationsInput | boolean
    enable_rating?: BoolFieldUpdateOperationsInput | boolean
    path_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutCollectionNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutCollectionNestedInput
    Content?: ContentUpdateManyWithoutCollectionNestedInput
    Template?: TemplateUpdateManyWithoutCollectionNestedInput
    form_field?: form_fieldUpdateManyWithoutCollectionNestedInput
  }

  export type CollectionUncheckedUpdateWithoutFieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    page_content?: BoolFieldUpdateOperationsInput | boolean
    enable_author?: BoolFieldUpdateOperationsInput | boolean
    enable_comments?: BoolFieldUpdateOperationsInput | boolean
    enable_featured_posts?: BoolFieldUpdateOperationsInput | boolean
    enable_rating?: BoolFieldUpdateOperationsInput | boolean
    path_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutCollectionNestedInput
    Content?: ContentUncheckedUpdateManyWithoutCollectionNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutCollectionNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type TemplateUpsertWithoutFieldInput = {
    update: XOR<TemplateUpdateWithoutFieldInput, TemplateUncheckedUpdateWithoutFieldInput>
    create: XOR<TemplateCreateWithoutFieldInput, TemplateUncheckedCreateWithoutFieldInput>
    where?: TemplateWhereInput
  }

  export type TemplateUpdateToOneWithWhereWithoutFieldInput = {
    where?: TemplateWhereInput
    data: XOR<TemplateUpdateWithoutFieldInput, TemplateUncheckedUpdateWithoutFieldInput>
  }

  export type TemplateUpdateWithoutFieldInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Collection?: CollectionUpdateOneRequiredWithoutTemplateNestedInput
    TemplateInstance?: TemplateInstanceUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateUncheckedUpdateWithoutFieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    collection_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    TemplateInstance?: TemplateInstanceUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type OrganizationCreateWithoutImageGenerationBillingInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutImageGenerationBillingInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutImageGenerationBillingInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutImageGenerationBillingInput, OrganizationUncheckedCreateWithoutImageGenerationBillingInput>
  }

  export type OrganizationUpsertWithoutImageGenerationBillingInput = {
    update: XOR<OrganizationUpdateWithoutImageGenerationBillingInput, OrganizationUncheckedUpdateWithoutImageGenerationBillingInput>
    create: XOR<OrganizationCreateWithoutImageGenerationBillingInput, OrganizationUncheckedCreateWithoutImageGenerationBillingInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutImageGenerationBillingInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutImageGenerationBillingInput, OrganizationUncheckedUpdateWithoutImageGenerationBillingInput>
  }

  export type OrganizationUpdateWithoutImageGenerationBillingInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutImageGenerationBillingInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutInvoiceInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutInvoiceInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutInvoiceInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutInvoiceInput, OrganizationUncheckedCreateWithoutInvoiceInput>
  }

  export type OrganizationUpsertWithoutInvoiceInput = {
    update: XOR<OrganizationUpdateWithoutInvoiceInput, OrganizationUncheckedUpdateWithoutInvoiceInput>
    create: XOR<OrganizationCreateWithoutInvoiceInput, OrganizationUncheckedCreateWithoutInvoiceInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutInvoiceInput, OrganizationUncheckedUpdateWithoutInvoiceInput>
  }

  export type OrganizationUpdateWithoutInvoiceInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type MediaCreateWithoutLinkPageInput = {
    url: string
    alt_text?: string
    name?: string
    created_at?: Date | string
    updated_at: Date | string
    Organization: OrganizationCreateNestedOneWithoutMediaInput
    Users?: UsersCreateNestedManyWithoutMediaInput
    author?: authorCreateNestedManyWithoutMediaInput
    org_details?: org_detailsCreateNestedOneWithoutMediaInput
    struct?: structCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutLinkPageInput = {
    id?: number
    url: string
    alt_text?: string
    name?: string
    created_at?: Date | string
    organization_id: number
    updated_at: Date | string
    Users?: UsersUncheckedCreateNestedManyWithoutMediaInput
    author?: authorUncheckedCreateNestedManyWithoutMediaInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutMediaInput
    struct?: structUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutLinkPageInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutLinkPageInput, MediaUncheckedCreateWithoutLinkPageInput>
  }

  export type OrganizationCreateWithoutLinkPageInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutLinkPageInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutLinkPageInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutLinkPageInput, OrganizationUncheckedCreateWithoutLinkPageInput>
  }

  export type MediaUpsertWithoutLinkPageInput = {
    update: XOR<MediaUpdateWithoutLinkPageInput, MediaUncheckedUpdateWithoutLinkPageInput>
    create: XOR<MediaCreateWithoutLinkPageInput, MediaUncheckedCreateWithoutLinkPageInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutLinkPageInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutLinkPageInput, MediaUncheckedUpdateWithoutLinkPageInput>
  }

  export type MediaUpdateWithoutLinkPageInput = {
    url?: StringFieldUpdateOperationsInput | string
    alt_text?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Organization?: OrganizationUpdateOneRequiredWithoutMediaNestedInput
    Users?: UsersUpdateManyWithoutMediaNestedInput
    author?: authorUpdateManyWithoutMediaNestedInput
    org_details?: org_detailsUpdateOneWithoutMediaNestedInput
    struct?: structUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutLinkPageInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    alt_text?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUncheckedUpdateManyWithoutMediaNestedInput
    author?: authorUncheckedUpdateManyWithoutMediaNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutMediaNestedInput
    struct?: structUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type OrganizationUpsertWithoutLinkPageInput = {
    update: XOR<OrganizationUpdateWithoutLinkPageInput, OrganizationUncheckedUpdateWithoutLinkPageInput>
    create: XOR<OrganizationCreateWithoutLinkPageInput, OrganizationUncheckedCreateWithoutLinkPageInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutLinkPageInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutLinkPageInput, OrganizationUncheckedUpdateWithoutLinkPageInput>
  }

  export type OrganizationUpdateWithoutLinkPageInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutLinkPageInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type LinkPageCreateWithoutMediaInput = {
    created_at?: Date | string
    updated_at: Date | string
    description?: string | null
    title?: string | null
    links?: LinkPageCreatelinksInput | InputJsonValue[]
    Organization: OrganizationCreateNestedOneWithoutLinkPageInput
  }

  export type LinkPageUncheckedCreateWithoutMediaInput = {
    id?: number
    organization_id: number
    created_at?: Date | string
    updated_at: Date | string
    description?: string | null
    title?: string | null
    links?: LinkPageCreatelinksInput | InputJsonValue[]
  }

  export type LinkPageCreateOrConnectWithoutMediaInput = {
    where: LinkPageWhereUniqueInput
    create: XOR<LinkPageCreateWithoutMediaInput, LinkPageUncheckedCreateWithoutMediaInput>
  }

  export type LinkPageCreateManyMediaInputEnvelope = {
    data: LinkPageCreateManyMediaInput | LinkPageCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationCreateWithoutMediaInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutMediaInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutMediaInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutMediaInput, OrganizationUncheckedCreateWithoutMediaInput>
  }

  export type UsersCreateWithoutMediaInput = {
    email: string
    username: string
    password: string
    security_pin?: string | null
    created_at?: Date | string
    updated_at: Date | string
    role?: string
    UserOrganization?: UserOrganizationCreateNestedManyWithoutUsersInput
    Organization: OrganizationCreateNestedOneWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutMediaInput = {
    id?: number
    email: string
    username: string
    password: string
    security_pin?: string | null
    created_at?: Date | string
    organization_id: number
    updated_at: Date | string
    role?: string
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutMediaInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutMediaInput, UsersUncheckedCreateWithoutMediaInput>
  }

  export type UsersCreateManyMediaInputEnvelope = {
    data: UsersCreateManyMediaInput | UsersCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type authorCreateWithoutMediaInput = {
    created_at?: Date | string
    updated_at: Date | string
    name: string
    description: string
    slug: string
    Content?: ContentCreateNestedManyWithoutAuthorInput
    Organization: OrganizationCreateNestedOneWithoutAuthorInput
  }

  export type authorUncheckedCreateWithoutMediaInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    name: string
    description: string
    organization_id: number
    slug: string
    Content?: ContentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type authorCreateOrConnectWithoutMediaInput = {
    where: authorWhereUniqueInput
    create: XOR<authorCreateWithoutMediaInput, authorUncheckedCreateWithoutMediaInput>
  }

  export type authorCreateManyMediaInputEnvelope = {
    data: authorCreateManyMediaInput | authorCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type org_detailsCreateWithoutMediaInput = {
    gtag?: string | null
    url?: string | null
    company_name?: string | null
    phone?: string | null
    email?: string | null
    street_address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    socials?: org_detailsCreatesocialsInput | string[]
    company_description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    Organization: OrganizationCreateNestedOneWithoutOrg_detailsInput
  }

  export type org_detailsUncheckedCreateWithoutMediaInput = {
    gtag?: string | null
    url?: string | null
    company_name?: string | null
    phone?: string | null
    email?: string | null
    street_address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    socials?: org_detailsCreatesocialsInput | string[]
    company_description?: string | null
    created_at?: Date | string
    id?: number
    organization_id: number
    updated_at: Date | string
  }

  export type org_detailsCreateOrConnectWithoutMediaInput = {
    where: org_detailsWhereUniqueInput
    create: XOR<org_detailsCreateWithoutMediaInput, org_detailsUncheckedCreateWithoutMediaInput>
  }

  export type structCreateWithoutMediaInput = {
    created_at?: Date | string
    updated_at: Date | string
    name: string
    group: string
    cms?: boolean
    description?: string | null
    form_field?: form_fieldCreateNestedManyWithoutStructInput
    Organization: OrganizationCreateNestedOneWithoutStructInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutStructInput
  }

  export type structUncheckedCreateWithoutMediaInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    name: string
    group: string
    organization_id: number
    cms?: boolean
    description?: string | null
    form_field?: form_fieldUncheckedCreateNestedManyWithoutStructInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutStructInput
  }

  export type structCreateOrConnectWithoutMediaInput = {
    where: structWhereUniqueInput
    create: XOR<structCreateWithoutMediaInput, structUncheckedCreateWithoutMediaInput>
  }

  export type structCreateManyMediaInputEnvelope = {
    data: structCreateManyMediaInput | structCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type LinkPageUpsertWithWhereUniqueWithoutMediaInput = {
    where: LinkPageWhereUniqueInput
    update: XOR<LinkPageUpdateWithoutMediaInput, LinkPageUncheckedUpdateWithoutMediaInput>
    create: XOR<LinkPageCreateWithoutMediaInput, LinkPageUncheckedCreateWithoutMediaInput>
  }

  export type LinkPageUpdateWithWhereUniqueWithoutMediaInput = {
    where: LinkPageWhereUniqueInput
    data: XOR<LinkPageUpdateWithoutMediaInput, LinkPageUncheckedUpdateWithoutMediaInput>
  }

  export type LinkPageUpdateManyWithWhereWithoutMediaInput = {
    where: LinkPageScalarWhereInput
    data: XOR<LinkPageUpdateManyMutationInput, LinkPageUncheckedUpdateManyWithoutMediaInput>
  }

  export type LinkPageScalarWhereInput = {
    AND?: LinkPageScalarWhereInput | LinkPageScalarWhereInput[]
    OR?: LinkPageScalarWhereInput[]
    NOT?: LinkPageScalarWhereInput | LinkPageScalarWhereInput[]
    id?: IntFilter<"LinkPage"> | number
    organization_id?: IntFilter<"LinkPage"> | number
    created_at?: DateTimeFilter<"LinkPage"> | Date | string
    updated_at?: DateTimeFilter<"LinkPage"> | Date | string
    description?: StringNullableFilter<"LinkPage"> | string | null
    media_id?: IntNullableFilter<"LinkPage"> | number | null
    title?: StringNullableFilter<"LinkPage"> | string | null
    links?: JsonNullableListFilter<"LinkPage">
  }

  export type OrganizationUpsertWithoutMediaInput = {
    update: XOR<OrganizationUpdateWithoutMediaInput, OrganizationUncheckedUpdateWithoutMediaInput>
    create: XOR<OrganizationCreateWithoutMediaInput, OrganizationUncheckedCreateWithoutMediaInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutMediaInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutMediaInput, OrganizationUncheckedUpdateWithoutMediaInput>
  }

  export type OrganizationUpdateWithoutMediaInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UsersUpsertWithWhereUniqueWithoutMediaInput = {
    where: UsersWhereUniqueInput
    update: XOR<UsersUpdateWithoutMediaInput, UsersUncheckedUpdateWithoutMediaInput>
    create: XOR<UsersCreateWithoutMediaInput, UsersUncheckedCreateWithoutMediaInput>
  }

  export type UsersUpdateWithWhereUniqueWithoutMediaInput = {
    where: UsersWhereUniqueInput
    data: XOR<UsersUpdateWithoutMediaInput, UsersUncheckedUpdateWithoutMediaInput>
  }

  export type UsersUpdateManyWithWhereWithoutMediaInput = {
    where: UsersScalarWhereInput
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyWithoutMediaInput>
  }

  export type UsersScalarWhereInput = {
    AND?: UsersScalarWhereInput | UsersScalarWhereInput[]
    OR?: UsersScalarWhereInput[]
    NOT?: UsersScalarWhereInput | UsersScalarWhereInput[]
    id?: IntFilter<"Users"> | number
    email?: StringFilter<"Users"> | string
    username?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    security_pin?: StringNullableFilter<"Users"> | string | null
    created_at?: DateTimeFilter<"Users"> | Date | string
    organization_id?: IntFilter<"Users"> | number
    updated_at?: DateTimeFilter<"Users"> | Date | string
    role?: StringFilter<"Users"> | string
    media_id?: IntNullableFilter<"Users"> | number | null
  }

  export type authorUpsertWithWhereUniqueWithoutMediaInput = {
    where: authorWhereUniqueInput
    update: XOR<authorUpdateWithoutMediaInput, authorUncheckedUpdateWithoutMediaInput>
    create: XOR<authorCreateWithoutMediaInput, authorUncheckedCreateWithoutMediaInput>
  }

  export type authorUpdateWithWhereUniqueWithoutMediaInput = {
    where: authorWhereUniqueInput
    data: XOR<authorUpdateWithoutMediaInput, authorUncheckedUpdateWithoutMediaInput>
  }

  export type authorUpdateManyWithWhereWithoutMediaInput = {
    where: authorScalarWhereInput
    data: XOR<authorUpdateManyMutationInput, authorUncheckedUpdateManyWithoutMediaInput>
  }

  export type authorScalarWhereInput = {
    AND?: authorScalarWhereInput | authorScalarWhereInput[]
    OR?: authorScalarWhereInput[]
    NOT?: authorScalarWhereInput | authorScalarWhereInput[]
    id?: IntFilter<"author"> | number
    created_at?: DateTimeFilter<"author"> | Date | string
    updated_at?: DateTimeFilter<"author"> | Date | string
    name?: StringFilter<"author"> | string
    description?: StringFilter<"author"> | string
    organization_id?: IntFilter<"author"> | number
    media_id?: IntFilter<"author"> | number
    slug?: StringFilter<"author"> | string
  }

  export type org_detailsUpsertWithoutMediaInput = {
    update: XOR<org_detailsUpdateWithoutMediaInput, org_detailsUncheckedUpdateWithoutMediaInput>
    create: XOR<org_detailsCreateWithoutMediaInput, org_detailsUncheckedCreateWithoutMediaInput>
    where?: org_detailsWhereInput
  }

  export type org_detailsUpdateToOneWithWhereWithoutMediaInput = {
    where?: org_detailsWhereInput
    data: XOR<org_detailsUpdateWithoutMediaInput, org_detailsUncheckedUpdateWithoutMediaInput>
  }

  export type org_detailsUpdateWithoutMediaInput = {
    gtag?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: org_detailsUpdatesocialsInput | string[]
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Organization?: OrganizationUpdateOneRequiredWithoutOrg_detailsNestedInput
  }

  export type org_detailsUncheckedUpdateWithoutMediaInput = {
    gtag?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: org_detailsUpdatesocialsInput | string[]
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    organization_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type structUpsertWithWhereUniqueWithoutMediaInput = {
    where: structWhereUniqueInput
    update: XOR<structUpdateWithoutMediaInput, structUncheckedUpdateWithoutMediaInput>
    create: XOR<structCreateWithoutMediaInput, structUncheckedCreateWithoutMediaInput>
  }

  export type structUpdateWithWhereUniqueWithoutMediaInput = {
    where: structWhereUniqueInput
    data: XOR<structUpdateWithoutMediaInput, structUncheckedUpdateWithoutMediaInput>
  }

  export type structUpdateManyWithWhereWithoutMediaInput = {
    where: structScalarWhereInput
    data: XOR<structUpdateManyMutationInput, structUncheckedUpdateManyWithoutMediaInput>
  }

  export type structScalarWhereInput = {
    AND?: structScalarWhereInput | structScalarWhereInput[]
    OR?: structScalarWhereInput[]
    NOT?: structScalarWhereInput | structScalarWhereInput[]
    id?: IntFilter<"struct"> | number
    created_at?: DateTimeFilter<"struct"> | Date | string
    updated_at?: DateTimeFilter<"struct"> | Date | string
    name?: StringFilter<"struct"> | string
    group?: StringFilter<"struct"> | string
    organization_id?: IntFilter<"struct"> | number
    cms?: BoolFilter<"struct"> | boolean
    description?: StringNullableFilter<"struct"> | string | null
    media_id?: IntNullableFilter<"struct"> | number | null
  }

  export type OrganizationCreateWithoutMessagesInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutMessagesInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutMessagesInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutMessagesInput, OrganizationUncheckedCreateWithoutMessagesInput>
  }

  export type OrganizationUpsertWithoutMessagesInput = {
    update: XOR<OrganizationUpdateWithoutMessagesInput, OrganizationUncheckedUpdateWithoutMessagesInput>
    create: XOR<OrganizationCreateWithoutMessagesInput, OrganizationUncheckedCreateWithoutMessagesInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutMessagesInput, OrganizationUncheckedUpdateWithoutMessagesInput>
  }

  export type OrganizationUpdateWithoutMessagesInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type CategoryCreateWithoutOrganizationInput = {
    name: string
    slug: string
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    short_name: string
    Collection: CollectionCreateNestedOneWithoutCategoryInput
    Category?: CategoryCreateNestedOneWithoutOther_CategoryInput
    other_Category?: CategoryCreateNestedManyWithoutCategoryInput
    Content?: ContentCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutOrganizationInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    parent_id?: number | null
    collection_id: number
    created_at?: Date | string
    updated_at: Date | string
    short_name: string
    other_Category?: CategoryUncheckedCreateNestedManyWithoutCategoryInput
    Content?: ContentUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutOrganizationInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutOrganizationInput, CategoryUncheckedCreateWithoutOrganizationInput>
  }

  export type CategoryCreateManyOrganizationInputEnvelope = {
    data: CategoryCreateManyOrganizationInput | CategoryCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type CollectionCreateWithoutOrganizationInput = {
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    icon: string
    page_content?: boolean
    enable_author?: boolean
    enable_comments?: boolean
    enable_featured_posts?: boolean
    enable_rating?: boolean
    path_prefix?: string | null
    title?: string | null
    Category?: CategoryCreateNestedManyWithoutCollectionInput
    Content?: ContentCreateNestedManyWithoutCollectionInput
    Field?: FieldCreateNestedManyWithoutCollectionInput
    Template?: TemplateCreateNestedManyWithoutCollectionInput
    form_field?: form_fieldCreateNestedManyWithoutCollectionInput
  }

  export type CollectionUncheckedCreateWithoutOrganizationInput = {
    id?: number
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    icon: string
    page_content?: boolean
    enable_author?: boolean
    enable_comments?: boolean
    enable_featured_posts?: boolean
    enable_rating?: boolean
    path_prefix?: string | null
    title?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutCollectionInput
    Content?: ContentUncheckedCreateNestedManyWithoutCollectionInput
    Field?: FieldUncheckedCreateNestedManyWithoutCollectionInput
    Template?: TemplateUncheckedCreateNestedManyWithoutCollectionInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type CollectionCreateOrConnectWithoutOrganizationInput = {
    where: CollectionWhereUniqueInput
    create: XOR<CollectionCreateWithoutOrganizationInput, CollectionUncheckedCreateWithoutOrganizationInput>
  }

  export type CollectionCreateManyOrganizationInputEnvelope = {
    data: CollectionCreateManyOrganizationInput | CollectionCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutOrganizationInput = {
    text: string
    author: string
    created_at?: Date | string
    updated_at: Date | string
    approved?: boolean
    email: string
    image_url?: string | null
    rating?: number | null
    Content: ContentCreateNestedOneWithoutCommentInput
    Comment?: CommentCreateNestedOneWithoutOther_CommentInput
    other_Comment?: CommentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutOrganizationInput = {
    id?: number
    text: string
    author: string
    content_id: number
    parent_id?: number | null
    created_at?: Date | string
    updated_at: Date | string
    approved?: boolean
    email: string
    image_url?: string | null
    rating?: number | null
    other_Comment?: CommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutOrganizationInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutOrganizationInput, CommentUncheckedCreateWithoutOrganizationInput>
  }

  export type CommentCreateManyOrganizationInputEnvelope = {
    data: CommentCreateManyOrganizationInput | CommentCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type CompletionUsageCreateWithoutOrganizationInput = {
    created_at?: Date | string
    prompt_tokens: number
    completion_tokens: number
    total_tokens: number
    prompt_tokens_cost: number
    completion_tokens_cost: number
    total_tokens_cost: number
    prompt_tokens_price: number
    completion_tokens_price: number
    total_tokens_price: number
  }

  export type CompletionUsageUncheckedCreateWithoutOrganizationInput = {
    created_at?: Date | string
    prompt_tokens: number
    completion_tokens: number
    total_tokens: number
    prompt_tokens_cost: number
    completion_tokens_cost: number
    total_tokens_cost: number
    prompt_tokens_price: number
    completion_tokens_price: number
    total_tokens_price: number
    id?: number
  }

  export type CompletionUsageCreateOrConnectWithoutOrganizationInput = {
    where: CompletionUsageWhereUniqueInput
    create: XOR<CompletionUsageCreateWithoutOrganizationInput, CompletionUsageUncheckedCreateWithoutOrganizationInput>
  }

  export type CompletionUsageCreateManyOrganizationInputEnvelope = {
    data: CompletionUsageCreateManyOrganizationInput | CompletionUsageCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ContentCreateWithoutOrganizationInput = {
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    blocks: JsonNullValueInput | InputJsonValue
    html: string
    archive?: boolean
    description?: string | null
    draft?: boolean
    slug: string
    title?: string | null
    comments_enabled?: boolean
    featured?: boolean
    content_category?: ContentCreatecontent_categoryInput | string[]
    Comment?: CommentCreateNestedManyWithoutContentInput
    author?: authorCreateNestedOneWithoutContentInput
    Collection: CollectionCreateNestedOneWithoutContentInput
    ContentTemplateInstance?: ContentTemplateInstanceCreateNestedManyWithoutContentInput
    Category?: CategoryCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateWithoutOrganizationInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    blocks: JsonNullValueInput | InputJsonValue
    html: string
    archive?: boolean
    collection_id: number
    description?: string | null
    draft?: boolean
    slug: string
    title?: string | null
    comments_enabled?: boolean
    author_id?: number | null
    featured?: boolean
    content_category?: ContentCreatecontent_categoryInput | string[]
    Comment?: CommentUncheckedCreateNestedManyWithoutContentInput
    ContentTemplateInstance?: ContentTemplateInstanceUncheckedCreateNestedManyWithoutContentInput
    Category?: CategoryUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutOrganizationInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutOrganizationInput, ContentUncheckedCreateWithoutOrganizationInput>
  }

  export type ContentCreateManyOrganizationInputEnvelope = {
    data: ContentCreateManyOrganizationInput | ContentCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ImageGenerationBillingCreateWithoutOrganizationInput = {
    id: string
    completed_at: Date | string
    started_at: Date | string
    created_at: Date | string
    predict_time: number
    model: string
    status: string
    cost: number
    price: number
  }

  export type ImageGenerationBillingUncheckedCreateWithoutOrganizationInput = {
    id: string
    completed_at: Date | string
    started_at: Date | string
    created_at: Date | string
    predict_time: number
    model: string
    status: string
    cost: number
    price: number
  }

  export type ImageGenerationBillingCreateOrConnectWithoutOrganizationInput = {
    where: ImageGenerationBillingWhereUniqueInput
    create: XOR<ImageGenerationBillingCreateWithoutOrganizationInput, ImageGenerationBillingUncheckedCreateWithoutOrganizationInput>
  }

  export type ImageGenerationBillingCreateManyOrganizationInputEnvelope = {
    data: ImageGenerationBillingCreateManyOrganizationInput | ImageGenerationBillingCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutOrganizationInput = {
    amount_paid: number
    currency: string
    paid_at: Date | string
    pdf: string
    url: string
    id: string
  }

  export type InvoiceUncheckedCreateWithoutOrganizationInput = {
    amount_paid: number
    currency: string
    paid_at: Date | string
    pdf: string
    url: string
    id: string
  }

  export type InvoiceCreateOrConnectWithoutOrganizationInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutOrganizationInput, InvoiceUncheckedCreateWithoutOrganizationInput>
  }

  export type InvoiceCreateManyOrganizationInputEnvelope = {
    data: InvoiceCreateManyOrganizationInput | InvoiceCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type LinkPageCreateWithoutOrganizationInput = {
    created_at?: Date | string
    updated_at: Date | string
    description?: string | null
    title?: string | null
    links?: LinkPageCreatelinksInput | InputJsonValue[]
    Media?: MediaCreateNestedOneWithoutLinkPageInput
  }

  export type LinkPageUncheckedCreateWithoutOrganizationInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    description?: string | null
    media_id?: number | null
    title?: string | null
    links?: LinkPageCreatelinksInput | InputJsonValue[]
  }

  export type LinkPageCreateOrConnectWithoutOrganizationInput = {
    where: LinkPageWhereUniqueInput
    create: XOR<LinkPageCreateWithoutOrganizationInput, LinkPageUncheckedCreateWithoutOrganizationInput>
  }

  export type LinkPageCreateManyOrganizationInputEnvelope = {
    data: LinkPageCreateManyOrganizationInput | LinkPageCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type MediaCreateWithoutOrganizationInput = {
    url: string
    alt_text?: string
    name?: string
    created_at?: Date | string
    updated_at: Date | string
    LinkPage?: LinkPageCreateNestedManyWithoutMediaInput
    Users?: UsersCreateNestedManyWithoutMediaInput
    author?: authorCreateNestedManyWithoutMediaInput
    org_details?: org_detailsCreateNestedOneWithoutMediaInput
    struct?: structCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutOrganizationInput = {
    id?: number
    url: string
    alt_text?: string
    name?: string
    created_at?: Date | string
    updated_at: Date | string
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutMediaInput
    Users?: UsersUncheckedCreateNestedManyWithoutMediaInput
    author?: authorUncheckedCreateNestedManyWithoutMediaInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutMediaInput
    struct?: structUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutOrganizationInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutOrganizationInput, MediaUncheckedCreateWithoutOrganizationInput>
  }

  export type MediaCreateManyOrganizationInputEnvelope = {
    data: MediaCreateManyOrganizationInput | MediaCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type MessagesCreateWithoutOrganizationInput = {
    created_at?: Date | string
    updated_at: Date | string
    message: string
    first_name: string
    email: string
    phone_number?: string | null
    last_name?: string | null
    other_fields?: NullableJsonNullValueInput | InputJsonValue
    viewed?: boolean
    archived?: boolean
  }

  export type MessagesUncheckedCreateWithoutOrganizationInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    message: string
    first_name: string
    email: string
    phone_number?: string | null
    last_name?: string | null
    other_fields?: NullableJsonNullValueInput | InputJsonValue
    viewed?: boolean
    archived?: boolean
  }

  export type MessagesCreateOrConnectWithoutOrganizationInput = {
    where: MessagesWhereUniqueInput
    create: XOR<MessagesCreateWithoutOrganizationInput, MessagesUncheckedCreateWithoutOrganizationInput>
  }

  export type MessagesCreateManyOrganizationInputEnvelope = {
    data: MessagesCreateManyOrganizationInput | MessagesCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type PageCreateWithoutOrganizationInput = {
    title: string
    slug: string
    created_at?: Date | string
    updated_at: Date | string
    published?: boolean
    archive?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PageUncheckedCreateWithoutOrganizationInput = {
    id?: number
    title: string
    slug: string
    created_at?: Date | string
    updated_at: Date | string
    published?: boolean
    archive?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PageCreateOrConnectWithoutOrganizationInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutOrganizationInput, PageUncheckedCreateWithoutOrganizationInput>
  }

  export type PageCreateManyOrganizationInputEnvelope = {
    data: PageCreateManyOrganizationInput | PageCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutOrganizationInput = {
    stripe_subscription_id: string
  }

  export type SubscriptionUncheckedCreateWithoutOrganizationInput = {
    id?: number
    stripe_subscription_id: string
  }

  export type SubscriptionCreateOrConnectWithoutOrganizationInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutOrganizationInput, SubscriptionUncheckedCreateWithoutOrganizationInput>
  }

  export type SubscriptionCreateManyOrganizationInputEnvelope = {
    data: SubscriptionCreateManyOrganizationInput | SubscriptionCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ThreadCreateWithoutOrganizationInput = {
    thread_id: string
    title?: string
    created_at?: Date | string
    updated_at: Date | string
    should_hide_thread?: boolean
    Run?: RunCreateNestedManyWithoutThreadInput
    ThreadMessage?: ThreadMessageCreateNestedManyWithoutThreadInput
  }

  export type ThreadUncheckedCreateWithoutOrganizationInput = {
    thread_id: string
    title?: string
    created_at?: Date | string
    updated_at: Date | string
    should_hide_thread?: boolean
    Run?: RunUncheckedCreateNestedManyWithoutThreadInput
    ThreadMessage?: ThreadMessageUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ThreadCreateOrConnectWithoutOrganizationInput = {
    where: ThreadWhereUniqueInput
    create: XOR<ThreadCreateWithoutOrganizationInput, ThreadUncheckedCreateWithoutOrganizationInput>
  }

  export type ThreadCreateManyOrganizationInputEnvelope = {
    data: ThreadCreateManyOrganizationInput | ThreadCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type UsageCreateWithoutOrganizationInput = {
    prompt_tokens: number
    completion_tokens: number
    total_tokens: number
    created_at?: Date | string
    Run: RunCreateNestedOneWithoutUsageInput
  }

  export type UsageUncheckedCreateWithoutOrganizationInput = {
    run_id: string
    prompt_tokens: number
    completion_tokens: number
    total_tokens: number
    created_at?: Date | string
  }

  export type UsageCreateOrConnectWithoutOrganizationInput = {
    where: UsageWhereUniqueInput
    create: XOR<UsageCreateWithoutOrganizationInput, UsageUncheckedCreateWithoutOrganizationInput>
  }

  export type UsageCreateManyOrganizationInputEnvelope = {
    data: UsageCreateManyOrganizationInput | UsageCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type UserOrganizationCreateWithoutOrganizationInput = {
    role?: string
    created_at?: Date | string
    Users: UsersCreateNestedOneWithoutUserOrganizationInput
  }

  export type UserOrganizationUncheckedCreateWithoutOrganizationInput = {
    user_id: number
    role?: string
    created_at?: Date | string
  }

  export type UserOrganizationCreateOrConnectWithoutOrganizationInput = {
    where: UserOrganizationWhereUniqueInput
    create: XOR<UserOrganizationCreateWithoutOrganizationInput, UserOrganizationUncheckedCreateWithoutOrganizationInput>
  }

  export type UserOrganizationCreateManyOrganizationInputEnvelope = {
    data: UserOrganizationCreateManyOrganizationInput | UserOrganizationCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type UsersCreateWithoutOrganizationInput = {
    email: string
    username: string
    password: string
    security_pin?: string | null
    created_at?: Date | string
    updated_at: Date | string
    role?: string
    UserOrganization?: UserOrganizationCreateNestedManyWithoutUsersInput
    Media?: MediaCreateNestedOneWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutOrganizationInput = {
    id?: number
    email: string
    username: string
    password: string
    security_pin?: string | null
    created_at?: Date | string
    updated_at: Date | string
    role?: string
    media_id?: number | null
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutOrganizationInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutOrganizationInput, UsersUncheckedCreateWithoutOrganizationInput>
  }

  export type UsersCreateManyOrganizationInputEnvelope = {
    data: UsersCreateManyOrganizationInput | UsersCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type authorCreateWithoutOrganizationInput = {
    created_at?: Date | string
    updated_at: Date | string
    name: string
    description: string
    slug: string
    Content?: ContentCreateNestedManyWithoutAuthorInput
    Media: MediaCreateNestedOneWithoutAuthorInput
  }

  export type authorUncheckedCreateWithoutOrganizationInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    name: string
    description: string
    media_id: number
    slug: string
    Content?: ContentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type authorCreateOrConnectWithoutOrganizationInput = {
    where: authorWhereUniqueInput
    create: XOR<authorCreateWithoutOrganizationInput, authorUncheckedCreateWithoutOrganizationInput>
  }

  export type authorCreateManyOrganizationInputEnvelope = {
    data: authorCreateManyOrganizationInput | authorCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type form_fieldCreateWithoutOrganizationInput = {
    name: string
    required?: boolean
    created_at?: Date | string
    updated_at: Date | string
    type: $Enums.field_type
    default_value?: string | null
    help?: string | null
    order?: number
    description?: string | null
    label: string
    placeholder?: string | null
    regex?: string | null
    options?: form_fieldCreateoptionsInput | InputJsonValue[]
    Collection?: CollectionCreateNestedOneWithoutForm_fieldInput
    struct?: structCreateNestedOneWithoutForm_fieldInput
  }

  export type form_fieldUncheckedCreateWithoutOrganizationInput = {
    id?: number
    name: string
    required?: boolean
    created_at?: Date | string
    updated_at: Date | string
    type: $Enums.field_type
    default_value?: string | null
    help?: string | null
    order?: number
    description?: string | null
    label: string
    placeholder?: string | null
    regex?: string | null
    collection_id?: number | null
    options?: form_fieldCreateoptionsInput | InputJsonValue[]
    struct_id?: number | null
  }

  export type form_fieldCreateOrConnectWithoutOrganizationInput = {
    where: form_fieldWhereUniqueInput
    create: XOR<form_fieldCreateWithoutOrganizationInput, form_fieldUncheckedCreateWithoutOrganizationInput>
  }

  export type form_fieldCreateManyOrganizationInputEnvelope = {
    data: form_fieldCreateManyOrganizationInput | form_fieldCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type org_detailsCreateWithoutOrganizationInput = {
    gtag?: string | null
    url?: string | null
    company_name?: string | null
    phone?: string | null
    email?: string | null
    street_address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    socials?: org_detailsCreatesocialsInput | string[]
    company_description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    Media?: MediaCreateNestedOneWithoutOrg_detailsInput
  }

  export type org_detailsUncheckedCreateWithoutOrganizationInput = {
    gtag?: string | null
    url?: string | null
    company_name?: string | null
    phone?: string | null
    email?: string | null
    street_address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    socials?: org_detailsCreatesocialsInput | string[]
    company_description?: string | null
    created_at?: Date | string
    id?: number
    media_id?: number | null
    updated_at: Date | string
  }

  export type org_detailsCreateOrConnectWithoutOrganizationInput = {
    where: org_detailsWhereUniqueInput
    create: XOR<org_detailsCreateWithoutOrganizationInput, org_detailsUncheckedCreateWithoutOrganizationInput>
  }

  export type structCreateWithoutOrganizationInput = {
    created_at?: Date | string
    updated_at: Date | string
    name: string
    group: string
    cms?: boolean
    description?: string | null
    form_field?: form_fieldCreateNestedManyWithoutStructInput
    Media?: MediaCreateNestedOneWithoutStructInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutStructInput
  }

  export type structUncheckedCreateWithoutOrganizationInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    name: string
    group: string
    cms?: boolean
    description?: string | null
    media_id?: number | null
    form_field?: form_fieldUncheckedCreateNestedManyWithoutStructInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutStructInput
  }

  export type structCreateOrConnectWithoutOrganizationInput = {
    where: structWhereUniqueInput
    create: XOR<structCreateWithoutOrganizationInput, structUncheckedCreateWithoutOrganizationInput>
  }

  export type structCreateManyOrganizationInputEnvelope = {
    data: structCreateManyOrganizationInput | structCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type struct_setCreateWithoutOrganizationInput = {
    name: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
    icon: string
    pinned?: boolean
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutStruct_setInput
  }

  export type struct_setUncheckedCreateWithoutOrganizationInput = {
    id?: number
    name: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
    icon: string
    pinned?: boolean
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutStruct_setInput
  }

  export type struct_setCreateOrConnectWithoutOrganizationInput = {
    where: struct_setWhereUniqueInput
    create: XOR<struct_setCreateWithoutOrganizationInput, struct_setUncheckedCreateWithoutOrganizationInput>
  }

  export type struct_setCreateManyOrganizationInputEnvelope = {
    data: struct_setCreateManyOrganizationInput | struct_setCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type struct_set_instanceCreateWithoutOrganizationInput = {
    created_at?: Date | string
    updated_at: Date | string
    instance_data: JsonNullValueInput | InputJsonValue
    key: string
    struct: structCreateNestedOneWithoutStruct_set_instanceInput
    struct_set: struct_setCreateNestedOneWithoutStruct_set_instanceInput
  }

  export type struct_set_instanceUncheckedCreateWithoutOrganizationInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    instance_data: JsonNullValueInput | InputJsonValue
    struct_set_id: number
    struct_id: number
    key: string
  }

  export type struct_set_instanceCreateOrConnectWithoutOrganizationInput = {
    where: struct_set_instanceWhereUniqueInput
    create: XOR<struct_set_instanceCreateWithoutOrganizationInput, struct_set_instanceUncheckedCreateWithoutOrganizationInput>
  }

  export type struct_set_instanceCreateManyOrganizationInputEnvelope = {
    data: struct_set_instanceCreateManyOrganizationInput | struct_set_instanceCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutOrganizationInput, CategoryUncheckedUpdateWithoutOrganizationInput>
    create: XOR<CategoryCreateWithoutOrganizationInput, CategoryUncheckedCreateWithoutOrganizationInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutOrganizationInput, CategoryUncheckedUpdateWithoutOrganizationInput>
  }

  export type CategoryUpdateManyWithWhereWithoutOrganizationInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type CollectionUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: CollectionWhereUniqueInput
    update: XOR<CollectionUpdateWithoutOrganizationInput, CollectionUncheckedUpdateWithoutOrganizationInput>
    create: XOR<CollectionCreateWithoutOrganizationInput, CollectionUncheckedCreateWithoutOrganizationInput>
  }

  export type CollectionUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: CollectionWhereUniqueInput
    data: XOR<CollectionUpdateWithoutOrganizationInput, CollectionUncheckedUpdateWithoutOrganizationInput>
  }

  export type CollectionUpdateManyWithWhereWithoutOrganizationInput = {
    where: CollectionScalarWhereInput
    data: XOR<CollectionUpdateManyMutationInput, CollectionUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type CollectionScalarWhereInput = {
    AND?: CollectionScalarWhereInput | CollectionScalarWhereInput[]
    OR?: CollectionScalarWhereInput[]
    NOT?: CollectionScalarWhereInput | CollectionScalarWhereInput[]
    id?: IntFilter<"Collection"> | number
    name?: StringFilter<"Collection"> | string
    organization_id?: IntFilter<"Collection"> | number
    description?: StringNullableFilter<"Collection"> | string | null
    created_at?: DateTimeFilter<"Collection"> | Date | string
    updated_at?: DateTimeFilter<"Collection"> | Date | string
    icon?: StringFilter<"Collection"> | string
    page_content?: BoolFilter<"Collection"> | boolean
    enable_author?: BoolFilter<"Collection"> | boolean
    enable_comments?: BoolFilter<"Collection"> | boolean
    enable_featured_posts?: BoolFilter<"Collection"> | boolean
    enable_rating?: BoolFilter<"Collection"> | boolean
    path_prefix?: StringNullableFilter<"Collection"> | string | null
    title?: StringNullableFilter<"Collection"> | string | null
  }

  export type CommentUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutOrganizationInput, CommentUncheckedUpdateWithoutOrganizationInput>
    create: XOR<CommentCreateWithoutOrganizationInput, CommentUncheckedCreateWithoutOrganizationInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutOrganizationInput, CommentUncheckedUpdateWithoutOrganizationInput>
  }

  export type CommentUpdateManyWithWhereWithoutOrganizationInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type CompletionUsageUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: CompletionUsageWhereUniqueInput
    update: XOR<CompletionUsageUpdateWithoutOrganizationInput, CompletionUsageUncheckedUpdateWithoutOrganizationInput>
    create: XOR<CompletionUsageCreateWithoutOrganizationInput, CompletionUsageUncheckedCreateWithoutOrganizationInput>
  }

  export type CompletionUsageUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: CompletionUsageWhereUniqueInput
    data: XOR<CompletionUsageUpdateWithoutOrganizationInput, CompletionUsageUncheckedUpdateWithoutOrganizationInput>
  }

  export type CompletionUsageUpdateManyWithWhereWithoutOrganizationInput = {
    where: CompletionUsageScalarWhereInput
    data: XOR<CompletionUsageUpdateManyMutationInput, CompletionUsageUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type CompletionUsageScalarWhereInput = {
    AND?: CompletionUsageScalarWhereInput | CompletionUsageScalarWhereInput[]
    OR?: CompletionUsageScalarWhereInput[]
    NOT?: CompletionUsageScalarWhereInput | CompletionUsageScalarWhereInput[]
    created_at?: DateTimeFilter<"CompletionUsage"> | Date | string
    prompt_tokens?: IntFilter<"CompletionUsage"> | number
    completion_tokens?: IntFilter<"CompletionUsage"> | number
    total_tokens?: IntFilter<"CompletionUsage"> | number
    prompt_tokens_cost?: FloatFilter<"CompletionUsage"> | number
    completion_tokens_cost?: FloatFilter<"CompletionUsage"> | number
    total_tokens_cost?: FloatFilter<"CompletionUsage"> | number
    prompt_tokens_price?: FloatFilter<"CompletionUsage"> | number
    completion_tokens_price?: FloatFilter<"CompletionUsage"> | number
    total_tokens_price?: FloatFilter<"CompletionUsage"> | number
    id?: IntFilter<"CompletionUsage"> | number
    organization_id?: IntFilter<"CompletionUsage"> | number
  }

  export type ContentUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ContentWhereUniqueInput
    update: XOR<ContentUpdateWithoutOrganizationInput, ContentUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ContentCreateWithoutOrganizationInput, ContentUncheckedCreateWithoutOrganizationInput>
  }

  export type ContentUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ContentWhereUniqueInput
    data: XOR<ContentUpdateWithoutOrganizationInput, ContentUncheckedUpdateWithoutOrganizationInput>
  }

  export type ContentUpdateManyWithWhereWithoutOrganizationInput = {
    where: ContentScalarWhereInput
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ImageGenerationBillingUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ImageGenerationBillingWhereUniqueInput
    update: XOR<ImageGenerationBillingUpdateWithoutOrganizationInput, ImageGenerationBillingUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ImageGenerationBillingCreateWithoutOrganizationInput, ImageGenerationBillingUncheckedCreateWithoutOrganizationInput>
  }

  export type ImageGenerationBillingUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ImageGenerationBillingWhereUniqueInput
    data: XOR<ImageGenerationBillingUpdateWithoutOrganizationInput, ImageGenerationBillingUncheckedUpdateWithoutOrganizationInput>
  }

  export type ImageGenerationBillingUpdateManyWithWhereWithoutOrganizationInput = {
    where: ImageGenerationBillingScalarWhereInput
    data: XOR<ImageGenerationBillingUpdateManyMutationInput, ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ImageGenerationBillingScalarWhereInput = {
    AND?: ImageGenerationBillingScalarWhereInput | ImageGenerationBillingScalarWhereInput[]
    OR?: ImageGenerationBillingScalarWhereInput[]
    NOT?: ImageGenerationBillingScalarWhereInput | ImageGenerationBillingScalarWhereInput[]
    id?: StringFilter<"ImageGenerationBilling"> | string
    completed_at?: DateTimeFilter<"ImageGenerationBilling"> | Date | string
    started_at?: DateTimeFilter<"ImageGenerationBilling"> | Date | string
    created_at?: DateTimeFilter<"ImageGenerationBilling"> | Date | string
    predict_time?: FloatFilter<"ImageGenerationBilling"> | number
    model?: StringFilter<"ImageGenerationBilling"> | string
    status?: StringFilter<"ImageGenerationBilling"> | string
    cost?: FloatFilter<"ImageGenerationBilling"> | number
    price?: FloatFilter<"ImageGenerationBilling"> | number
    organization_id?: IntFilter<"ImageGenerationBilling"> | number
  }

  export type InvoiceUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutOrganizationInput, InvoiceUncheckedUpdateWithoutOrganizationInput>
    create: XOR<InvoiceCreateWithoutOrganizationInput, InvoiceUncheckedCreateWithoutOrganizationInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutOrganizationInput, InvoiceUncheckedUpdateWithoutOrganizationInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutOrganizationInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    organization_id?: IntFilter<"Invoice"> | number
    amount_paid?: IntFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    paid_at?: DateTimeFilter<"Invoice"> | Date | string
    pdf?: StringFilter<"Invoice"> | string
    url?: StringFilter<"Invoice"> | string
    id?: StringFilter<"Invoice"> | string
  }

  export type LinkPageUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: LinkPageWhereUniqueInput
    update: XOR<LinkPageUpdateWithoutOrganizationInput, LinkPageUncheckedUpdateWithoutOrganizationInput>
    create: XOR<LinkPageCreateWithoutOrganizationInput, LinkPageUncheckedCreateWithoutOrganizationInput>
  }

  export type LinkPageUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: LinkPageWhereUniqueInput
    data: XOR<LinkPageUpdateWithoutOrganizationInput, LinkPageUncheckedUpdateWithoutOrganizationInput>
  }

  export type LinkPageUpdateManyWithWhereWithoutOrganizationInput = {
    where: LinkPageScalarWhereInput
    data: XOR<LinkPageUpdateManyMutationInput, LinkPageUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type MediaUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutOrganizationInput, MediaUncheckedUpdateWithoutOrganizationInput>
    create: XOR<MediaCreateWithoutOrganizationInput, MediaUncheckedCreateWithoutOrganizationInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutOrganizationInput, MediaUncheckedUpdateWithoutOrganizationInput>
  }

  export type MediaUpdateManyWithWhereWithoutOrganizationInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type MediaScalarWhereInput = {
    AND?: MediaScalarWhereInput | MediaScalarWhereInput[]
    OR?: MediaScalarWhereInput[]
    NOT?: MediaScalarWhereInput | MediaScalarWhereInput[]
    id?: IntFilter<"Media"> | number
    url?: StringFilter<"Media"> | string
    alt_text?: StringFilter<"Media"> | string
    name?: StringFilter<"Media"> | string
    created_at?: DateTimeFilter<"Media"> | Date | string
    organization_id?: IntFilter<"Media"> | number
    updated_at?: DateTimeFilter<"Media"> | Date | string
  }

  export type MessagesUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: MessagesWhereUniqueInput
    update: XOR<MessagesUpdateWithoutOrganizationInput, MessagesUncheckedUpdateWithoutOrganizationInput>
    create: XOR<MessagesCreateWithoutOrganizationInput, MessagesUncheckedCreateWithoutOrganizationInput>
  }

  export type MessagesUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: MessagesWhereUniqueInput
    data: XOR<MessagesUpdateWithoutOrganizationInput, MessagesUncheckedUpdateWithoutOrganizationInput>
  }

  export type MessagesUpdateManyWithWhereWithoutOrganizationInput = {
    where: MessagesScalarWhereInput
    data: XOR<MessagesUpdateManyMutationInput, MessagesUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type MessagesScalarWhereInput = {
    AND?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
    OR?: MessagesScalarWhereInput[]
    NOT?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
    id?: IntFilter<"Messages"> | number
    created_at?: DateTimeFilter<"Messages"> | Date | string
    updated_at?: DateTimeFilter<"Messages"> | Date | string
    message?: StringFilter<"Messages"> | string
    first_name?: StringFilter<"Messages"> | string
    email?: StringFilter<"Messages"> | string
    phone_number?: StringNullableFilter<"Messages"> | string | null
    last_name?: StringNullableFilter<"Messages"> | string | null
    other_fields?: JsonNullableFilter<"Messages">
    organization_id?: IntFilter<"Messages"> | number
    viewed?: BoolFilter<"Messages"> | boolean
    archived?: BoolFilter<"Messages"> | boolean
  }

  export type PageUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: PageWhereUniqueInput
    update: XOR<PageUpdateWithoutOrganizationInput, PageUncheckedUpdateWithoutOrganizationInput>
    create: XOR<PageCreateWithoutOrganizationInput, PageUncheckedCreateWithoutOrganizationInput>
  }

  export type PageUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: PageWhereUniqueInput
    data: XOR<PageUpdateWithoutOrganizationInput, PageUncheckedUpdateWithoutOrganizationInput>
  }

  export type PageUpdateManyWithWhereWithoutOrganizationInput = {
    where: PageScalarWhereInput
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type PageScalarWhereInput = {
    AND?: PageScalarWhereInput | PageScalarWhereInput[]
    OR?: PageScalarWhereInput[]
    NOT?: PageScalarWhereInput | PageScalarWhereInput[]
    id?: IntFilter<"Page"> | number
    title?: StringFilter<"Page"> | string
    slug?: StringFilter<"Page"> | string
    created_at?: DateTimeFilter<"Page"> | Date | string
    updated_at?: DateTimeFilter<"Page"> | Date | string
    published?: BoolFilter<"Page"> | boolean
    archive?: BoolFilter<"Page"> | boolean
    data?: JsonNullableFilter<"Page">
    organization_id?: IntFilter<"Page"> | number
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutOrganizationInput, SubscriptionUncheckedUpdateWithoutOrganizationInput>
    create: XOR<SubscriptionCreateWithoutOrganizationInput, SubscriptionUncheckedCreateWithoutOrganizationInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutOrganizationInput, SubscriptionUncheckedUpdateWithoutOrganizationInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutOrganizationInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: IntFilter<"Subscription"> | number
    organization_id?: IntFilter<"Subscription"> | number
    stripe_subscription_id?: StringFilter<"Subscription"> | string
  }

  export type ThreadUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ThreadWhereUniqueInput
    update: XOR<ThreadUpdateWithoutOrganizationInput, ThreadUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ThreadCreateWithoutOrganizationInput, ThreadUncheckedCreateWithoutOrganizationInput>
  }

  export type ThreadUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ThreadWhereUniqueInput
    data: XOR<ThreadUpdateWithoutOrganizationInput, ThreadUncheckedUpdateWithoutOrganizationInput>
  }

  export type ThreadUpdateManyWithWhereWithoutOrganizationInput = {
    where: ThreadScalarWhereInput
    data: XOR<ThreadUpdateManyMutationInput, ThreadUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ThreadScalarWhereInput = {
    AND?: ThreadScalarWhereInput | ThreadScalarWhereInput[]
    OR?: ThreadScalarWhereInput[]
    NOT?: ThreadScalarWhereInput | ThreadScalarWhereInput[]
    thread_id?: StringFilter<"Thread"> | string
    title?: StringFilter<"Thread"> | string
    created_at?: DateTimeFilter<"Thread"> | Date | string
    updated_at?: DateTimeFilter<"Thread"> | Date | string
    organization_id?: IntFilter<"Thread"> | number
    should_hide_thread?: BoolFilter<"Thread"> | boolean
  }

  export type UsageUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UsageWhereUniqueInput
    update: XOR<UsageUpdateWithoutOrganizationInput, UsageUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UsageCreateWithoutOrganizationInput, UsageUncheckedCreateWithoutOrganizationInput>
  }

  export type UsageUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UsageWhereUniqueInput
    data: XOR<UsageUpdateWithoutOrganizationInput, UsageUncheckedUpdateWithoutOrganizationInput>
  }

  export type UsageUpdateManyWithWhereWithoutOrganizationInput = {
    where: UsageScalarWhereInput
    data: XOR<UsageUpdateManyMutationInput, UsageUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type UsageScalarWhereInput = {
    AND?: UsageScalarWhereInput | UsageScalarWhereInput[]
    OR?: UsageScalarWhereInput[]
    NOT?: UsageScalarWhereInput | UsageScalarWhereInput[]
    run_id?: StringFilter<"Usage"> | string
    prompt_tokens?: IntFilter<"Usage"> | number
    completion_tokens?: IntFilter<"Usage"> | number
    total_tokens?: IntFilter<"Usage"> | number
    organization_id?: IntNullableFilter<"Usage"> | number | null
    created_at?: DateTimeFilter<"Usage"> | Date | string
  }

  export type UserOrganizationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UserOrganizationWhereUniqueInput
    update: XOR<UserOrganizationUpdateWithoutOrganizationInput, UserOrganizationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UserOrganizationCreateWithoutOrganizationInput, UserOrganizationUncheckedCreateWithoutOrganizationInput>
  }

  export type UserOrganizationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UserOrganizationWhereUniqueInput
    data: XOR<UserOrganizationUpdateWithoutOrganizationInput, UserOrganizationUncheckedUpdateWithoutOrganizationInput>
  }

  export type UserOrganizationUpdateManyWithWhereWithoutOrganizationInput = {
    where: UserOrganizationScalarWhereInput
    data: XOR<UserOrganizationUpdateManyMutationInput, UserOrganizationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type UserOrganizationScalarWhereInput = {
    AND?: UserOrganizationScalarWhereInput | UserOrganizationScalarWhereInput[]
    OR?: UserOrganizationScalarWhereInput[]
    NOT?: UserOrganizationScalarWhereInput | UserOrganizationScalarWhereInput[]
    user_id?: IntFilter<"UserOrganization"> | number
    organization_id?: IntFilter<"UserOrganization"> | number
    role?: StringFilter<"UserOrganization"> | string
    created_at?: DateTimeFilter<"UserOrganization"> | Date | string
  }

  export type UsersUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UsersWhereUniqueInput
    update: XOR<UsersUpdateWithoutOrganizationInput, UsersUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UsersCreateWithoutOrganizationInput, UsersUncheckedCreateWithoutOrganizationInput>
  }

  export type UsersUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UsersWhereUniqueInput
    data: XOR<UsersUpdateWithoutOrganizationInput, UsersUncheckedUpdateWithoutOrganizationInput>
  }

  export type UsersUpdateManyWithWhereWithoutOrganizationInput = {
    where: UsersScalarWhereInput
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type authorUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: authorWhereUniqueInput
    update: XOR<authorUpdateWithoutOrganizationInput, authorUncheckedUpdateWithoutOrganizationInput>
    create: XOR<authorCreateWithoutOrganizationInput, authorUncheckedCreateWithoutOrganizationInput>
  }

  export type authorUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: authorWhereUniqueInput
    data: XOR<authorUpdateWithoutOrganizationInput, authorUncheckedUpdateWithoutOrganizationInput>
  }

  export type authorUpdateManyWithWhereWithoutOrganizationInput = {
    where: authorScalarWhereInput
    data: XOR<authorUpdateManyMutationInput, authorUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type form_fieldUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: form_fieldWhereUniqueInput
    update: XOR<form_fieldUpdateWithoutOrganizationInput, form_fieldUncheckedUpdateWithoutOrganizationInput>
    create: XOR<form_fieldCreateWithoutOrganizationInput, form_fieldUncheckedCreateWithoutOrganizationInput>
  }

  export type form_fieldUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: form_fieldWhereUniqueInput
    data: XOR<form_fieldUpdateWithoutOrganizationInput, form_fieldUncheckedUpdateWithoutOrganizationInput>
  }

  export type form_fieldUpdateManyWithWhereWithoutOrganizationInput = {
    where: form_fieldScalarWhereInput
    data: XOR<form_fieldUpdateManyMutationInput, form_fieldUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type org_detailsUpsertWithoutOrganizationInput = {
    update: XOR<org_detailsUpdateWithoutOrganizationInput, org_detailsUncheckedUpdateWithoutOrganizationInput>
    create: XOR<org_detailsCreateWithoutOrganizationInput, org_detailsUncheckedCreateWithoutOrganizationInput>
    where?: org_detailsWhereInput
  }

  export type org_detailsUpdateToOneWithWhereWithoutOrganizationInput = {
    where?: org_detailsWhereInput
    data: XOR<org_detailsUpdateWithoutOrganizationInput, org_detailsUncheckedUpdateWithoutOrganizationInput>
  }

  export type org_detailsUpdateWithoutOrganizationInput = {
    gtag?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: org_detailsUpdatesocialsInput | string[]
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Media?: MediaUpdateOneWithoutOrg_detailsNestedInput
  }

  export type org_detailsUncheckedUpdateWithoutOrganizationInput = {
    gtag?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    socials?: org_detailsUpdatesocialsInput | string[]
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    media_id?: NullableIntFieldUpdateOperationsInput | number | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type structUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: structWhereUniqueInput
    update: XOR<structUpdateWithoutOrganizationInput, structUncheckedUpdateWithoutOrganizationInput>
    create: XOR<structCreateWithoutOrganizationInput, structUncheckedCreateWithoutOrganizationInput>
  }

  export type structUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: structWhereUniqueInput
    data: XOR<structUpdateWithoutOrganizationInput, structUncheckedUpdateWithoutOrganizationInput>
  }

  export type structUpdateManyWithWhereWithoutOrganizationInput = {
    where: structScalarWhereInput
    data: XOR<structUpdateManyMutationInput, structUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type struct_setUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: struct_setWhereUniqueInput
    update: XOR<struct_setUpdateWithoutOrganizationInput, struct_setUncheckedUpdateWithoutOrganizationInput>
    create: XOR<struct_setCreateWithoutOrganizationInput, struct_setUncheckedCreateWithoutOrganizationInput>
  }

  export type struct_setUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: struct_setWhereUniqueInput
    data: XOR<struct_setUpdateWithoutOrganizationInput, struct_setUncheckedUpdateWithoutOrganizationInput>
  }

  export type struct_setUpdateManyWithWhereWithoutOrganizationInput = {
    where: struct_setScalarWhereInput
    data: XOR<struct_setUpdateManyMutationInput, struct_setUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type struct_setScalarWhereInput = {
    AND?: struct_setScalarWhereInput | struct_setScalarWhereInput[]
    OR?: struct_setScalarWhereInput[]
    NOT?: struct_setScalarWhereInput | struct_setScalarWhereInput[]
    id?: IntFilter<"struct_set"> | number
    name?: StringFilter<"struct_set"> | string
    description?: StringFilter<"struct_set"> | string
    created_at?: DateTimeFilter<"struct_set"> | Date | string
    updated_at?: DateTimeFilter<"struct_set"> | Date | string
    organization_id?: IntFilter<"struct_set"> | number
    icon?: StringFilter<"struct_set"> | string
    pinned?: BoolFilter<"struct_set"> | boolean
  }

  export type struct_set_instanceUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: struct_set_instanceWhereUniqueInput
    update: XOR<struct_set_instanceUpdateWithoutOrganizationInput, struct_set_instanceUncheckedUpdateWithoutOrganizationInput>
    create: XOR<struct_set_instanceCreateWithoutOrganizationInput, struct_set_instanceUncheckedCreateWithoutOrganizationInput>
  }

  export type struct_set_instanceUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: struct_set_instanceWhereUniqueInput
    data: XOR<struct_set_instanceUpdateWithoutOrganizationInput, struct_set_instanceUncheckedUpdateWithoutOrganizationInput>
  }

  export type struct_set_instanceUpdateManyWithWhereWithoutOrganizationInput = {
    where: struct_set_instanceScalarWhereInput
    data: XOR<struct_set_instanceUpdateManyMutationInput, struct_set_instanceUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type struct_set_instanceScalarWhereInput = {
    AND?: struct_set_instanceScalarWhereInput | struct_set_instanceScalarWhereInput[]
    OR?: struct_set_instanceScalarWhereInput[]
    NOT?: struct_set_instanceScalarWhereInput | struct_set_instanceScalarWhereInput[]
    id?: IntFilter<"struct_set_instance"> | number
    created_at?: DateTimeFilter<"struct_set_instance"> | Date | string
    updated_at?: DateTimeFilter<"struct_set_instance"> | Date | string
    instance_data?: JsonFilter<"struct_set_instance">
    organization_id?: IntFilter<"struct_set_instance"> | number
    struct_set_id?: IntFilter<"struct_set_instance"> | number
    struct_id?: IntFilter<"struct_set_instance"> | number
    key?: StringFilter<"struct_set_instance"> | string
  }

  export type OrganizationCreateWithoutPageInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutPageInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutPageInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutPageInput, OrganizationUncheckedCreateWithoutPageInput>
  }

  export type OrganizationUpsertWithoutPageInput = {
    update: XOR<OrganizationUpdateWithoutPageInput, OrganizationUncheckedUpdateWithoutPageInput>
    create: XOR<OrganizationCreateWithoutPageInput, OrganizationUncheckedCreateWithoutPageInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutPageInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutPageInput, OrganizationUncheckedUpdateWithoutPageInput>
  }

  export type OrganizationUpdateWithoutPageInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutPageInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ThreadCreateWithoutRunInput = {
    thread_id: string
    title?: string
    created_at?: Date | string
    updated_at: Date | string
    should_hide_thread?: boolean
    Organization: OrganizationCreateNestedOneWithoutThreadInput
    ThreadMessage?: ThreadMessageCreateNestedManyWithoutThreadInput
  }

  export type ThreadUncheckedCreateWithoutRunInput = {
    thread_id: string
    title?: string
    created_at?: Date | string
    updated_at: Date | string
    organization_id: number
    should_hide_thread?: boolean
    ThreadMessage?: ThreadMessageUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ThreadCreateOrConnectWithoutRunInput = {
    where: ThreadWhereUniqueInput
    create: XOR<ThreadCreateWithoutRunInput, ThreadUncheckedCreateWithoutRunInput>
  }

  export type ThreadMessageCreateWithoutRunInput = {
    id: string
    created_at: Date | string
    role: string
    content: string
    assistant_id?: string | null
    Thread: ThreadCreateNestedOneWithoutThreadMessageInput
  }

  export type ThreadMessageUncheckedCreateWithoutRunInput = {
    id: string
    created_at: Date | string
    thread_id: string
    role: string
    content: string
    assistant_id?: string | null
  }

  export type ThreadMessageCreateOrConnectWithoutRunInput = {
    where: ThreadMessageWhereUniqueInput
    create: XOR<ThreadMessageCreateWithoutRunInput, ThreadMessageUncheckedCreateWithoutRunInput>
  }

  export type ThreadMessageCreateManyRunInputEnvelope = {
    data: ThreadMessageCreateManyRunInput | ThreadMessageCreateManyRunInput[]
    skipDuplicates?: boolean
  }

  export type UsageCreateWithoutRunInput = {
    prompt_tokens: number
    completion_tokens: number
    total_tokens: number
    created_at?: Date | string
    Organization?: OrganizationCreateNestedOneWithoutUsageInput
  }

  export type UsageUncheckedCreateWithoutRunInput = {
    prompt_tokens: number
    completion_tokens: number
    total_tokens: number
    organization_id?: number | null
    created_at?: Date | string
  }

  export type UsageCreateOrConnectWithoutRunInput = {
    where: UsageWhereUniqueInput
    create: XOR<UsageCreateWithoutRunInput, UsageUncheckedCreateWithoutRunInput>
  }

  export type ThreadUpsertWithoutRunInput = {
    update: XOR<ThreadUpdateWithoutRunInput, ThreadUncheckedUpdateWithoutRunInput>
    create: XOR<ThreadCreateWithoutRunInput, ThreadUncheckedCreateWithoutRunInput>
    where?: ThreadWhereInput
  }

  export type ThreadUpdateToOneWithWhereWithoutRunInput = {
    where?: ThreadWhereInput
    data: XOR<ThreadUpdateWithoutRunInput, ThreadUncheckedUpdateWithoutRunInput>
  }

  export type ThreadUpdateWithoutRunInput = {
    thread_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    should_hide_thread?: BoolFieldUpdateOperationsInput | boolean
    Organization?: OrganizationUpdateOneRequiredWithoutThreadNestedInput
    ThreadMessage?: ThreadMessageUpdateManyWithoutThreadNestedInput
  }

  export type ThreadUncheckedUpdateWithoutRunInput = {
    thread_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization_id?: IntFieldUpdateOperationsInput | number
    should_hide_thread?: BoolFieldUpdateOperationsInput | boolean
    ThreadMessage?: ThreadMessageUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type ThreadMessageUpsertWithWhereUniqueWithoutRunInput = {
    where: ThreadMessageWhereUniqueInput
    update: XOR<ThreadMessageUpdateWithoutRunInput, ThreadMessageUncheckedUpdateWithoutRunInput>
    create: XOR<ThreadMessageCreateWithoutRunInput, ThreadMessageUncheckedCreateWithoutRunInput>
  }

  export type ThreadMessageUpdateWithWhereUniqueWithoutRunInput = {
    where: ThreadMessageWhereUniqueInput
    data: XOR<ThreadMessageUpdateWithoutRunInput, ThreadMessageUncheckedUpdateWithoutRunInput>
  }

  export type ThreadMessageUpdateManyWithWhereWithoutRunInput = {
    where: ThreadMessageScalarWhereInput
    data: XOR<ThreadMessageUpdateManyMutationInput, ThreadMessageUncheckedUpdateManyWithoutRunInput>
  }

  export type ThreadMessageScalarWhereInput = {
    AND?: ThreadMessageScalarWhereInput | ThreadMessageScalarWhereInput[]
    OR?: ThreadMessageScalarWhereInput[]
    NOT?: ThreadMessageScalarWhereInput | ThreadMessageScalarWhereInput[]
    id?: StringFilter<"ThreadMessage"> | string
    created_at?: DateTimeFilter<"ThreadMessage"> | Date | string
    thread_id?: StringFilter<"ThreadMessage"> | string
    role?: StringFilter<"ThreadMessage"> | string
    content?: StringFilter<"ThreadMessage"> | string
    assistant_id?: StringNullableFilter<"ThreadMessage"> | string | null
    run_id?: StringNullableFilter<"ThreadMessage"> | string | null
  }

  export type UsageUpsertWithoutRunInput = {
    update: XOR<UsageUpdateWithoutRunInput, UsageUncheckedUpdateWithoutRunInput>
    create: XOR<UsageCreateWithoutRunInput, UsageUncheckedCreateWithoutRunInput>
    where?: UsageWhereInput
  }

  export type UsageUpdateToOneWithWhereWithoutRunInput = {
    where?: UsageWhereInput
    data: XOR<UsageUpdateWithoutRunInput, UsageUncheckedUpdateWithoutRunInput>
  }

  export type UsageUpdateWithoutRunInput = {
    prompt_tokens?: IntFieldUpdateOperationsInput | number
    completion_tokens?: IntFieldUpdateOperationsInput | number
    total_tokens?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Organization?: OrganizationUpdateOneWithoutUsageNestedInput
  }

  export type UsageUncheckedUpdateWithoutRunInput = {
    prompt_tokens?: IntFieldUpdateOperationsInput | number
    completion_tokens?: IntFieldUpdateOperationsInput | number
    total_tokens?: IntFieldUpdateOperationsInput | number
    organization_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateWithoutSubscriptionInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutSubscriptionInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutSubscriptionInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSubscriptionInput, OrganizationUncheckedCreateWithoutSubscriptionInput>
  }

  export type OrganizationUpsertWithoutSubscriptionInput = {
    update: XOR<OrganizationUpdateWithoutSubscriptionInput, OrganizationUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<OrganizationCreateWithoutSubscriptionInput, OrganizationUncheckedCreateWithoutSubscriptionInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutSubscriptionInput, OrganizationUncheckedUpdateWithoutSubscriptionInput>
  }

  export type OrganizationUpdateWithoutSubscriptionInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutSubscriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type FieldCreateWithoutTemplateInput = {
    name: string
    type: string
    required: boolean
    options?: FieldCreateoptionsInput | string[]
    created_at?: Date | string
    updated_at: Date | string
    Collection?: CollectionCreateNestedOneWithoutFieldInput
  }

  export type FieldUncheckedCreateWithoutTemplateInput = {
    id?: number
    name: string
    type: string
    required: boolean
    options?: FieldCreateoptionsInput | string[]
    created_at?: Date | string
    updated_at: Date | string
    collection_id?: number | null
  }

  export type FieldCreateOrConnectWithoutTemplateInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutTemplateInput, FieldUncheckedCreateWithoutTemplateInput>
  }

  export type FieldCreateManyTemplateInputEnvelope = {
    data: FieldCreateManyTemplateInput | FieldCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type CollectionCreateWithoutTemplateInput = {
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    icon: string
    page_content?: boolean
    enable_author?: boolean
    enable_comments?: boolean
    enable_featured_posts?: boolean
    enable_rating?: boolean
    path_prefix?: string | null
    title?: string | null
    Category?: CategoryCreateNestedManyWithoutCollectionInput
    Organization: OrganizationCreateNestedOneWithoutCollectionInput
    Content?: ContentCreateNestedManyWithoutCollectionInput
    Field?: FieldCreateNestedManyWithoutCollectionInput
    form_field?: form_fieldCreateNestedManyWithoutCollectionInput
  }

  export type CollectionUncheckedCreateWithoutTemplateInput = {
    id?: number
    name: string
    organization_id: number
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    icon: string
    page_content?: boolean
    enable_author?: boolean
    enable_comments?: boolean
    enable_featured_posts?: boolean
    enable_rating?: boolean
    path_prefix?: string | null
    title?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutCollectionInput
    Content?: ContentUncheckedCreateNestedManyWithoutCollectionInput
    Field?: FieldUncheckedCreateNestedManyWithoutCollectionInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type CollectionCreateOrConnectWithoutTemplateInput = {
    where: CollectionWhereUniqueInput
    create: XOR<CollectionCreateWithoutTemplateInput, CollectionUncheckedCreateWithoutTemplateInput>
  }

  export type TemplateInstanceCreateWithoutTemplateInput = {
    values: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    title: string
    ContentTemplateInstance?: ContentTemplateInstanceCreateNestedManyWithoutTemplateInstanceInput
  }

  export type TemplateInstanceUncheckedCreateWithoutTemplateInput = {
    id?: number
    values: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    title: string
    ContentTemplateInstance?: ContentTemplateInstanceUncheckedCreateNestedManyWithoutTemplateInstanceInput
  }

  export type TemplateInstanceCreateOrConnectWithoutTemplateInput = {
    where: TemplateInstanceWhereUniqueInput
    create: XOR<TemplateInstanceCreateWithoutTemplateInput, TemplateInstanceUncheckedCreateWithoutTemplateInput>
  }

  export type TemplateInstanceCreateManyTemplateInputEnvelope = {
    data: TemplateInstanceCreateManyTemplateInput | TemplateInstanceCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type FieldUpsertWithWhereUniqueWithoutTemplateInput = {
    where: FieldWhereUniqueInput
    update: XOR<FieldUpdateWithoutTemplateInput, FieldUncheckedUpdateWithoutTemplateInput>
    create: XOR<FieldCreateWithoutTemplateInput, FieldUncheckedCreateWithoutTemplateInput>
  }

  export type FieldUpdateWithWhereUniqueWithoutTemplateInput = {
    where: FieldWhereUniqueInput
    data: XOR<FieldUpdateWithoutTemplateInput, FieldUncheckedUpdateWithoutTemplateInput>
  }

  export type FieldUpdateManyWithWhereWithoutTemplateInput = {
    where: FieldScalarWhereInput
    data: XOR<FieldUpdateManyMutationInput, FieldUncheckedUpdateManyWithoutTemplateInput>
  }

  export type CollectionUpsertWithoutTemplateInput = {
    update: XOR<CollectionUpdateWithoutTemplateInput, CollectionUncheckedUpdateWithoutTemplateInput>
    create: XOR<CollectionCreateWithoutTemplateInput, CollectionUncheckedCreateWithoutTemplateInput>
    where?: CollectionWhereInput
  }

  export type CollectionUpdateToOneWithWhereWithoutTemplateInput = {
    where?: CollectionWhereInput
    data: XOR<CollectionUpdateWithoutTemplateInput, CollectionUncheckedUpdateWithoutTemplateInput>
  }

  export type CollectionUpdateWithoutTemplateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    page_content?: BoolFieldUpdateOperationsInput | boolean
    enable_author?: BoolFieldUpdateOperationsInput | boolean
    enable_comments?: BoolFieldUpdateOperationsInput | boolean
    enable_featured_posts?: BoolFieldUpdateOperationsInput | boolean
    enable_rating?: BoolFieldUpdateOperationsInput | boolean
    path_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutCollectionNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutCollectionNestedInput
    Content?: ContentUpdateManyWithoutCollectionNestedInput
    Field?: FieldUpdateManyWithoutCollectionNestedInput
    form_field?: form_fieldUpdateManyWithoutCollectionNestedInput
  }

  export type CollectionUncheckedUpdateWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    page_content?: BoolFieldUpdateOperationsInput | boolean
    enable_author?: BoolFieldUpdateOperationsInput | boolean
    enable_comments?: BoolFieldUpdateOperationsInput | boolean
    enable_featured_posts?: BoolFieldUpdateOperationsInput | boolean
    enable_rating?: BoolFieldUpdateOperationsInput | boolean
    path_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutCollectionNestedInput
    Content?: ContentUncheckedUpdateManyWithoutCollectionNestedInput
    Field?: FieldUncheckedUpdateManyWithoutCollectionNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type TemplateInstanceUpsertWithWhereUniqueWithoutTemplateInput = {
    where: TemplateInstanceWhereUniqueInput
    update: XOR<TemplateInstanceUpdateWithoutTemplateInput, TemplateInstanceUncheckedUpdateWithoutTemplateInput>
    create: XOR<TemplateInstanceCreateWithoutTemplateInput, TemplateInstanceUncheckedCreateWithoutTemplateInput>
  }

  export type TemplateInstanceUpdateWithWhereUniqueWithoutTemplateInput = {
    where: TemplateInstanceWhereUniqueInput
    data: XOR<TemplateInstanceUpdateWithoutTemplateInput, TemplateInstanceUncheckedUpdateWithoutTemplateInput>
  }

  export type TemplateInstanceUpdateManyWithWhereWithoutTemplateInput = {
    where: TemplateInstanceScalarWhereInput
    data: XOR<TemplateInstanceUpdateManyMutationInput, TemplateInstanceUncheckedUpdateManyWithoutTemplateInput>
  }

  export type TemplateInstanceScalarWhereInput = {
    AND?: TemplateInstanceScalarWhereInput | TemplateInstanceScalarWhereInput[]
    OR?: TemplateInstanceScalarWhereInput[]
    NOT?: TemplateInstanceScalarWhereInput | TemplateInstanceScalarWhereInput[]
    id?: IntFilter<"TemplateInstance"> | number
    values?: JsonFilter<"TemplateInstance">
    created_at?: DateTimeFilter<"TemplateInstance"> | Date | string
    updated_at?: DateTimeFilter<"TemplateInstance"> | Date | string
    title?: StringFilter<"TemplateInstance"> | string
    templateId?: IntFilter<"TemplateInstance"> | number
  }

  export type ContentTemplateInstanceCreateWithoutTemplateInstanceInput = {
    Content: ContentCreateNestedOneWithoutContentTemplateInstanceInput
  }

  export type ContentTemplateInstanceUncheckedCreateWithoutTemplateInstanceInput = {
    id?: number
    content_id: number
  }

  export type ContentTemplateInstanceCreateOrConnectWithoutTemplateInstanceInput = {
    where: ContentTemplateInstanceWhereUniqueInput
    create: XOR<ContentTemplateInstanceCreateWithoutTemplateInstanceInput, ContentTemplateInstanceUncheckedCreateWithoutTemplateInstanceInput>
  }

  export type ContentTemplateInstanceCreateManyTemplateInstanceInputEnvelope = {
    data: ContentTemplateInstanceCreateManyTemplateInstanceInput | ContentTemplateInstanceCreateManyTemplateInstanceInput[]
    skipDuplicates?: boolean
  }

  export type TemplateCreateWithoutTemplateInstanceInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    Field?: FieldCreateNestedManyWithoutTemplateInput
    Collection: CollectionCreateNestedOneWithoutTemplateInput
  }

  export type TemplateUncheckedCreateWithoutTemplateInstanceInput = {
    id?: number
    name: string
    collection_id: number
    created_at?: Date | string
    updated_at: Date | string
    Field?: FieldUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type TemplateCreateOrConnectWithoutTemplateInstanceInput = {
    where: TemplateWhereUniqueInput
    create: XOR<TemplateCreateWithoutTemplateInstanceInput, TemplateUncheckedCreateWithoutTemplateInstanceInput>
  }

  export type ContentTemplateInstanceUpsertWithWhereUniqueWithoutTemplateInstanceInput = {
    where: ContentTemplateInstanceWhereUniqueInput
    update: XOR<ContentTemplateInstanceUpdateWithoutTemplateInstanceInput, ContentTemplateInstanceUncheckedUpdateWithoutTemplateInstanceInput>
    create: XOR<ContentTemplateInstanceCreateWithoutTemplateInstanceInput, ContentTemplateInstanceUncheckedCreateWithoutTemplateInstanceInput>
  }

  export type ContentTemplateInstanceUpdateWithWhereUniqueWithoutTemplateInstanceInput = {
    where: ContentTemplateInstanceWhereUniqueInput
    data: XOR<ContentTemplateInstanceUpdateWithoutTemplateInstanceInput, ContentTemplateInstanceUncheckedUpdateWithoutTemplateInstanceInput>
  }

  export type ContentTemplateInstanceUpdateManyWithWhereWithoutTemplateInstanceInput = {
    where: ContentTemplateInstanceScalarWhereInput
    data: XOR<ContentTemplateInstanceUpdateManyMutationInput, ContentTemplateInstanceUncheckedUpdateManyWithoutTemplateInstanceInput>
  }

  export type TemplateUpsertWithoutTemplateInstanceInput = {
    update: XOR<TemplateUpdateWithoutTemplateInstanceInput, TemplateUncheckedUpdateWithoutTemplateInstanceInput>
    create: XOR<TemplateCreateWithoutTemplateInstanceInput, TemplateUncheckedCreateWithoutTemplateInstanceInput>
    where?: TemplateWhereInput
  }

  export type TemplateUpdateToOneWithWhereWithoutTemplateInstanceInput = {
    where?: TemplateWhereInput
    data: XOR<TemplateUpdateWithoutTemplateInstanceInput, TemplateUncheckedUpdateWithoutTemplateInstanceInput>
  }

  export type TemplateUpdateWithoutTemplateInstanceInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Field?: FieldUpdateManyWithoutTemplateNestedInput
    Collection?: CollectionUpdateOneRequiredWithoutTemplateNestedInput
  }

  export type TemplateUncheckedUpdateWithoutTemplateInstanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    collection_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Field?: FieldUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type RunCreateWithoutThreadInput = {
    id: string
    created_at: Date | string
    assistant_id: string
    status: string
    started_at: Date | string
    expires_at?: Date | string | null
    cancelled_at?: Date | string | null
    failed_at?: Date | string | null
    completed_at?: Date | string | null
    last_error?: string | null
    model: string
    instructions?: string | null
    ThreadMessage?: ThreadMessageCreateNestedManyWithoutRunInput
    Usage?: UsageCreateNestedOneWithoutRunInput
  }

  export type RunUncheckedCreateWithoutThreadInput = {
    id: string
    created_at: Date | string
    assistant_id: string
    status: string
    started_at: Date | string
    expires_at?: Date | string | null
    cancelled_at?: Date | string | null
    failed_at?: Date | string | null
    completed_at?: Date | string | null
    last_error?: string | null
    model: string
    instructions?: string | null
    ThreadMessage?: ThreadMessageUncheckedCreateNestedManyWithoutRunInput
    Usage?: UsageUncheckedCreateNestedOneWithoutRunInput
  }

  export type RunCreateOrConnectWithoutThreadInput = {
    where: RunWhereUniqueInput
    create: XOR<RunCreateWithoutThreadInput, RunUncheckedCreateWithoutThreadInput>
  }

  export type RunCreateManyThreadInputEnvelope = {
    data: RunCreateManyThreadInput | RunCreateManyThreadInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationCreateWithoutThreadInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutThreadInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutThreadInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutThreadInput, OrganizationUncheckedCreateWithoutThreadInput>
  }

  export type ThreadMessageCreateWithoutThreadInput = {
    id: string
    created_at: Date | string
    role: string
    content: string
    assistant_id?: string | null
    Run?: RunCreateNestedOneWithoutThreadMessageInput
  }

  export type ThreadMessageUncheckedCreateWithoutThreadInput = {
    id: string
    created_at: Date | string
    role: string
    content: string
    assistant_id?: string | null
    run_id?: string | null
  }

  export type ThreadMessageCreateOrConnectWithoutThreadInput = {
    where: ThreadMessageWhereUniqueInput
    create: XOR<ThreadMessageCreateWithoutThreadInput, ThreadMessageUncheckedCreateWithoutThreadInput>
  }

  export type ThreadMessageCreateManyThreadInputEnvelope = {
    data: ThreadMessageCreateManyThreadInput | ThreadMessageCreateManyThreadInput[]
    skipDuplicates?: boolean
  }

  export type RunUpsertWithWhereUniqueWithoutThreadInput = {
    where: RunWhereUniqueInput
    update: XOR<RunUpdateWithoutThreadInput, RunUncheckedUpdateWithoutThreadInput>
    create: XOR<RunCreateWithoutThreadInput, RunUncheckedCreateWithoutThreadInput>
  }

  export type RunUpdateWithWhereUniqueWithoutThreadInput = {
    where: RunWhereUniqueInput
    data: XOR<RunUpdateWithoutThreadInput, RunUncheckedUpdateWithoutThreadInput>
  }

  export type RunUpdateManyWithWhereWithoutThreadInput = {
    where: RunScalarWhereInput
    data: XOR<RunUpdateManyMutationInput, RunUncheckedUpdateManyWithoutThreadInput>
  }

  export type RunScalarWhereInput = {
    AND?: RunScalarWhereInput | RunScalarWhereInput[]
    OR?: RunScalarWhereInput[]
    NOT?: RunScalarWhereInput | RunScalarWhereInput[]
    id?: StringFilter<"Run"> | string
    created_at?: DateTimeFilter<"Run"> | Date | string
    assistant_id?: StringFilter<"Run"> | string
    thread_id?: StringFilter<"Run"> | string
    status?: StringFilter<"Run"> | string
    started_at?: DateTimeFilter<"Run"> | Date | string
    expires_at?: DateTimeNullableFilter<"Run"> | Date | string | null
    cancelled_at?: DateTimeNullableFilter<"Run"> | Date | string | null
    failed_at?: DateTimeNullableFilter<"Run"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"Run"> | Date | string | null
    last_error?: StringNullableFilter<"Run"> | string | null
    model?: StringFilter<"Run"> | string
    instructions?: StringNullableFilter<"Run"> | string | null
  }

  export type OrganizationUpsertWithoutThreadInput = {
    update: XOR<OrganizationUpdateWithoutThreadInput, OrganizationUncheckedUpdateWithoutThreadInput>
    create: XOR<OrganizationCreateWithoutThreadInput, OrganizationUncheckedCreateWithoutThreadInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutThreadInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutThreadInput, OrganizationUncheckedUpdateWithoutThreadInput>
  }

  export type OrganizationUpdateWithoutThreadInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutThreadInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ThreadMessageUpsertWithWhereUniqueWithoutThreadInput = {
    where: ThreadMessageWhereUniqueInput
    update: XOR<ThreadMessageUpdateWithoutThreadInput, ThreadMessageUncheckedUpdateWithoutThreadInput>
    create: XOR<ThreadMessageCreateWithoutThreadInput, ThreadMessageUncheckedCreateWithoutThreadInput>
  }

  export type ThreadMessageUpdateWithWhereUniqueWithoutThreadInput = {
    where: ThreadMessageWhereUniqueInput
    data: XOR<ThreadMessageUpdateWithoutThreadInput, ThreadMessageUncheckedUpdateWithoutThreadInput>
  }

  export type ThreadMessageUpdateManyWithWhereWithoutThreadInput = {
    where: ThreadMessageScalarWhereInput
    data: XOR<ThreadMessageUpdateManyMutationInput, ThreadMessageUncheckedUpdateManyWithoutThreadInput>
  }

  export type RunCreateWithoutThreadMessageInput = {
    id: string
    created_at: Date | string
    assistant_id: string
    status: string
    started_at: Date | string
    expires_at?: Date | string | null
    cancelled_at?: Date | string | null
    failed_at?: Date | string | null
    completed_at?: Date | string | null
    last_error?: string | null
    model: string
    instructions?: string | null
    Thread: ThreadCreateNestedOneWithoutRunInput
    Usage?: UsageCreateNestedOneWithoutRunInput
  }

  export type RunUncheckedCreateWithoutThreadMessageInput = {
    id: string
    created_at: Date | string
    assistant_id: string
    thread_id: string
    status: string
    started_at: Date | string
    expires_at?: Date | string | null
    cancelled_at?: Date | string | null
    failed_at?: Date | string | null
    completed_at?: Date | string | null
    last_error?: string | null
    model: string
    instructions?: string | null
    Usage?: UsageUncheckedCreateNestedOneWithoutRunInput
  }

  export type RunCreateOrConnectWithoutThreadMessageInput = {
    where: RunWhereUniqueInput
    create: XOR<RunCreateWithoutThreadMessageInput, RunUncheckedCreateWithoutThreadMessageInput>
  }

  export type ThreadCreateWithoutThreadMessageInput = {
    thread_id: string
    title?: string
    created_at?: Date | string
    updated_at: Date | string
    should_hide_thread?: boolean
    Run?: RunCreateNestedManyWithoutThreadInput
    Organization: OrganizationCreateNestedOneWithoutThreadInput
  }

  export type ThreadUncheckedCreateWithoutThreadMessageInput = {
    thread_id: string
    title?: string
    created_at?: Date | string
    updated_at: Date | string
    organization_id: number
    should_hide_thread?: boolean
    Run?: RunUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ThreadCreateOrConnectWithoutThreadMessageInput = {
    where: ThreadWhereUniqueInput
    create: XOR<ThreadCreateWithoutThreadMessageInput, ThreadUncheckedCreateWithoutThreadMessageInput>
  }

  export type RunUpsertWithoutThreadMessageInput = {
    update: XOR<RunUpdateWithoutThreadMessageInput, RunUncheckedUpdateWithoutThreadMessageInput>
    create: XOR<RunCreateWithoutThreadMessageInput, RunUncheckedCreateWithoutThreadMessageInput>
    where?: RunWhereInput
  }

  export type RunUpdateToOneWithWhereWithoutThreadMessageInput = {
    where?: RunWhereInput
    data: XOR<RunUpdateWithoutThreadMessageInput, RunUncheckedUpdateWithoutThreadMessageInput>
  }

  export type RunUpdateWithoutThreadMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assistant_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_error?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    Thread?: ThreadUpdateOneRequiredWithoutRunNestedInput
    Usage?: UsageUpdateOneWithoutRunNestedInput
  }

  export type RunUncheckedUpdateWithoutThreadMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assistant_id?: StringFieldUpdateOperationsInput | string
    thread_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_error?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    Usage?: UsageUncheckedUpdateOneWithoutRunNestedInput
  }

  export type ThreadUpsertWithoutThreadMessageInput = {
    update: XOR<ThreadUpdateWithoutThreadMessageInput, ThreadUncheckedUpdateWithoutThreadMessageInput>
    create: XOR<ThreadCreateWithoutThreadMessageInput, ThreadUncheckedCreateWithoutThreadMessageInput>
    where?: ThreadWhereInput
  }

  export type ThreadUpdateToOneWithWhereWithoutThreadMessageInput = {
    where?: ThreadWhereInput
    data: XOR<ThreadUpdateWithoutThreadMessageInput, ThreadUncheckedUpdateWithoutThreadMessageInput>
  }

  export type ThreadUpdateWithoutThreadMessageInput = {
    thread_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    should_hide_thread?: BoolFieldUpdateOperationsInput | boolean
    Run?: RunUpdateManyWithoutThreadNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutThreadNestedInput
  }

  export type ThreadUncheckedUpdateWithoutThreadMessageInput = {
    thread_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization_id?: IntFieldUpdateOperationsInput | number
    should_hide_thread?: BoolFieldUpdateOperationsInput | boolean
    Run?: RunUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type OrganizationCreateWithoutUsageInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUsageInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutUsageInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUsageInput, OrganizationUncheckedCreateWithoutUsageInput>
  }

  export type RunCreateWithoutUsageInput = {
    id: string
    created_at: Date | string
    assistant_id: string
    status: string
    started_at: Date | string
    expires_at?: Date | string | null
    cancelled_at?: Date | string | null
    failed_at?: Date | string | null
    completed_at?: Date | string | null
    last_error?: string | null
    model: string
    instructions?: string | null
    Thread: ThreadCreateNestedOneWithoutRunInput
    ThreadMessage?: ThreadMessageCreateNestedManyWithoutRunInput
  }

  export type RunUncheckedCreateWithoutUsageInput = {
    id: string
    created_at: Date | string
    assistant_id: string
    thread_id: string
    status: string
    started_at: Date | string
    expires_at?: Date | string | null
    cancelled_at?: Date | string | null
    failed_at?: Date | string | null
    completed_at?: Date | string | null
    last_error?: string | null
    model: string
    instructions?: string | null
    ThreadMessage?: ThreadMessageUncheckedCreateNestedManyWithoutRunInput
  }

  export type RunCreateOrConnectWithoutUsageInput = {
    where: RunWhereUniqueInput
    create: XOR<RunCreateWithoutUsageInput, RunUncheckedCreateWithoutUsageInput>
  }

  export type OrganizationUpsertWithoutUsageInput = {
    update: XOR<OrganizationUpdateWithoutUsageInput, OrganizationUncheckedUpdateWithoutUsageInput>
    create: XOR<OrganizationCreateWithoutUsageInput, OrganizationUncheckedCreateWithoutUsageInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUsageInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUsageInput, OrganizationUncheckedUpdateWithoutUsageInput>
  }

  export type OrganizationUpdateWithoutUsageInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUsageInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type RunUpsertWithoutUsageInput = {
    update: XOR<RunUpdateWithoutUsageInput, RunUncheckedUpdateWithoutUsageInput>
    create: XOR<RunCreateWithoutUsageInput, RunUncheckedCreateWithoutUsageInput>
    where?: RunWhereInput
  }

  export type RunUpdateToOneWithWhereWithoutUsageInput = {
    where?: RunWhereInput
    data: XOR<RunUpdateWithoutUsageInput, RunUncheckedUpdateWithoutUsageInput>
  }

  export type RunUpdateWithoutUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assistant_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_error?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    Thread?: ThreadUpdateOneRequiredWithoutRunNestedInput
    ThreadMessage?: ThreadMessageUpdateManyWithoutRunNestedInput
  }

  export type RunUncheckedUpdateWithoutUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assistant_id?: StringFieldUpdateOperationsInput | string
    thread_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_error?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    ThreadMessage?: ThreadMessageUncheckedUpdateManyWithoutRunNestedInput
  }

  export type OrganizationCreateWithoutUserOrganizationInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUserOrganizationInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutUserOrganizationInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUserOrganizationInput, OrganizationUncheckedCreateWithoutUserOrganizationInput>
  }

  export type UsersCreateWithoutUserOrganizationInput = {
    email: string
    username: string
    password: string
    security_pin?: string | null
    created_at?: Date | string
    updated_at: Date | string
    role?: string
    Media?: MediaCreateNestedOneWithoutUsersInput
    Organization: OrganizationCreateNestedOneWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutUserOrganizationInput = {
    id?: number
    email: string
    username: string
    password: string
    security_pin?: string | null
    created_at?: Date | string
    organization_id: number
    updated_at: Date | string
    role?: string
    media_id?: number | null
  }

  export type UsersCreateOrConnectWithoutUserOrganizationInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUserOrganizationInput, UsersUncheckedCreateWithoutUserOrganizationInput>
  }

  export type OrganizationUpsertWithoutUserOrganizationInput = {
    update: XOR<OrganizationUpdateWithoutUserOrganizationInput, OrganizationUncheckedUpdateWithoutUserOrganizationInput>
    create: XOR<OrganizationCreateWithoutUserOrganizationInput, OrganizationUncheckedCreateWithoutUserOrganizationInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUserOrganizationInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUserOrganizationInput, OrganizationUncheckedUpdateWithoutUserOrganizationInput>
  }

  export type OrganizationUpdateWithoutUserOrganizationInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUserOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UsersUpsertWithoutUserOrganizationInput = {
    update: XOR<UsersUpdateWithoutUserOrganizationInput, UsersUncheckedUpdateWithoutUserOrganizationInput>
    create: XOR<UsersCreateWithoutUserOrganizationInput, UsersUncheckedCreateWithoutUserOrganizationInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUserOrganizationInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUserOrganizationInput, UsersUncheckedUpdateWithoutUserOrganizationInput>
  }

  export type UsersUpdateWithoutUserOrganizationInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    security_pin?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    Media?: MediaUpdateOneWithoutUsersNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutUserOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    security_pin?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    media_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserOrganizationCreateWithoutUsersInput = {
    role?: string
    created_at?: Date | string
    Organization: OrganizationCreateNestedOneWithoutUserOrganizationInput
  }

  export type UserOrganizationUncheckedCreateWithoutUsersInput = {
    organization_id: number
    role?: string
    created_at?: Date | string
  }

  export type UserOrganizationCreateOrConnectWithoutUsersInput = {
    where: UserOrganizationWhereUniqueInput
    create: XOR<UserOrganizationCreateWithoutUsersInput, UserOrganizationUncheckedCreateWithoutUsersInput>
  }

  export type UserOrganizationCreateManyUsersInputEnvelope = {
    data: UserOrganizationCreateManyUsersInput | UserOrganizationCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type MediaCreateWithoutUsersInput = {
    url: string
    alt_text?: string
    name?: string
    created_at?: Date | string
    updated_at: Date | string
    LinkPage?: LinkPageCreateNestedManyWithoutMediaInput
    Organization: OrganizationCreateNestedOneWithoutMediaInput
    author?: authorCreateNestedManyWithoutMediaInput
    org_details?: org_detailsCreateNestedOneWithoutMediaInput
    struct?: structCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutUsersInput = {
    id?: number
    url: string
    alt_text?: string
    name?: string
    created_at?: Date | string
    organization_id: number
    updated_at: Date | string
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutMediaInput
    author?: authorUncheckedCreateNestedManyWithoutMediaInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutMediaInput
    struct?: structUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutUsersInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutUsersInput, MediaUncheckedCreateWithoutUsersInput>
  }

  export type OrganizationCreateWithoutUsersInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUsersInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutUsersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
  }

  export type UserOrganizationUpsertWithWhereUniqueWithoutUsersInput = {
    where: UserOrganizationWhereUniqueInput
    update: XOR<UserOrganizationUpdateWithoutUsersInput, UserOrganizationUncheckedUpdateWithoutUsersInput>
    create: XOR<UserOrganizationCreateWithoutUsersInput, UserOrganizationUncheckedCreateWithoutUsersInput>
  }

  export type UserOrganizationUpdateWithWhereUniqueWithoutUsersInput = {
    where: UserOrganizationWhereUniqueInput
    data: XOR<UserOrganizationUpdateWithoutUsersInput, UserOrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type UserOrganizationUpdateManyWithWhereWithoutUsersInput = {
    where: UserOrganizationScalarWhereInput
    data: XOR<UserOrganizationUpdateManyMutationInput, UserOrganizationUncheckedUpdateManyWithoutUsersInput>
  }

  export type MediaUpsertWithoutUsersInput = {
    update: XOR<MediaUpdateWithoutUsersInput, MediaUncheckedUpdateWithoutUsersInput>
    create: XOR<MediaCreateWithoutUsersInput, MediaUncheckedCreateWithoutUsersInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutUsersInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutUsersInput, MediaUncheckedUpdateWithoutUsersInput>
  }

  export type MediaUpdateWithoutUsersInput = {
    url?: StringFieldUpdateOperationsInput | string
    alt_text?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    LinkPage?: LinkPageUpdateManyWithoutMediaNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutMediaNestedInput
    author?: authorUpdateManyWithoutMediaNestedInput
    org_details?: org_detailsUpdateOneWithoutMediaNestedInput
    struct?: structUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    alt_text?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    LinkPage?: LinkPageUncheckedUpdateManyWithoutMediaNestedInput
    author?: authorUncheckedUpdateManyWithoutMediaNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutMediaNestedInput
    struct?: structUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type OrganizationUpsertWithoutUsersInput = {
    update: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUsersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type OrganizationUpdateWithoutUsersInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ContentCreateWithoutAuthorInput = {
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    blocks: JsonNullValueInput | InputJsonValue
    html: string
    archive?: boolean
    description?: string | null
    draft?: boolean
    slug: string
    title?: string | null
    comments_enabled?: boolean
    featured?: boolean
    content_category?: ContentCreatecontent_categoryInput | string[]
    Comment?: CommentCreateNestedManyWithoutContentInput
    Collection: CollectionCreateNestedOneWithoutContentInput
    Organization?: OrganizationCreateNestedOneWithoutContentInput
    ContentTemplateInstance?: ContentTemplateInstanceCreateNestedManyWithoutContentInput
    Category?: CategoryCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateWithoutAuthorInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    blocks: JsonNullValueInput | InputJsonValue
    html: string
    archive?: boolean
    collection_id: number
    description?: string | null
    draft?: boolean
    slug: string
    title?: string | null
    comments_enabled?: boolean
    organization_id?: number | null
    featured?: boolean
    content_category?: ContentCreatecontent_categoryInput | string[]
    Comment?: CommentUncheckedCreateNestedManyWithoutContentInput
    ContentTemplateInstance?: ContentTemplateInstanceUncheckedCreateNestedManyWithoutContentInput
    Category?: CategoryUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutAuthorInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutAuthorInput, ContentUncheckedCreateWithoutAuthorInput>
  }

  export type ContentCreateManyAuthorInputEnvelope = {
    data: ContentCreateManyAuthorInput | ContentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type MediaCreateWithoutAuthorInput = {
    url: string
    alt_text?: string
    name?: string
    created_at?: Date | string
    updated_at: Date | string
    LinkPage?: LinkPageCreateNestedManyWithoutMediaInput
    Organization: OrganizationCreateNestedOneWithoutMediaInput
    Users?: UsersCreateNestedManyWithoutMediaInput
    org_details?: org_detailsCreateNestedOneWithoutMediaInput
    struct?: structCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutAuthorInput = {
    id?: number
    url: string
    alt_text?: string
    name?: string
    created_at?: Date | string
    organization_id: number
    updated_at: Date | string
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutMediaInput
    Users?: UsersUncheckedCreateNestedManyWithoutMediaInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutMediaInput
    struct?: structUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutAuthorInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutAuthorInput, MediaUncheckedCreateWithoutAuthorInput>
  }

  export type OrganizationCreateWithoutAuthorInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutAuthorInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutAuthorInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutAuthorInput, OrganizationUncheckedCreateWithoutAuthorInput>
  }

  export type ContentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ContentWhereUniqueInput
    update: XOR<ContentUpdateWithoutAuthorInput, ContentUncheckedUpdateWithoutAuthorInput>
    create: XOR<ContentCreateWithoutAuthorInput, ContentUncheckedCreateWithoutAuthorInput>
  }

  export type ContentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ContentWhereUniqueInput
    data: XOR<ContentUpdateWithoutAuthorInput, ContentUncheckedUpdateWithoutAuthorInput>
  }

  export type ContentUpdateManyWithWhereWithoutAuthorInput = {
    where: ContentScalarWhereInput
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type MediaUpsertWithoutAuthorInput = {
    update: XOR<MediaUpdateWithoutAuthorInput, MediaUncheckedUpdateWithoutAuthorInput>
    create: XOR<MediaCreateWithoutAuthorInput, MediaUncheckedCreateWithoutAuthorInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutAuthorInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutAuthorInput, MediaUncheckedUpdateWithoutAuthorInput>
  }

  export type MediaUpdateWithoutAuthorInput = {
    url?: StringFieldUpdateOperationsInput | string
    alt_text?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    LinkPage?: LinkPageUpdateManyWithoutMediaNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutMediaNestedInput
    Users?: UsersUpdateManyWithoutMediaNestedInput
    org_details?: org_detailsUpdateOneWithoutMediaNestedInput
    struct?: structUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    alt_text?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    LinkPage?: LinkPageUncheckedUpdateManyWithoutMediaNestedInput
    Users?: UsersUncheckedUpdateManyWithoutMediaNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutMediaNestedInput
    struct?: structUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type OrganizationUpsertWithoutAuthorInput = {
    update: XOR<OrganizationUpdateWithoutAuthorInput, OrganizationUncheckedUpdateWithoutAuthorInput>
    create: XOR<OrganizationCreateWithoutAuthorInput, OrganizationUncheckedCreateWithoutAuthorInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutAuthorInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutAuthorInput, OrganizationUncheckedUpdateWithoutAuthorInput>
  }

  export type OrganizationUpdateWithoutAuthorInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type CollectionCreateWithoutForm_fieldInput = {
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    icon: string
    page_content?: boolean
    enable_author?: boolean
    enable_comments?: boolean
    enable_featured_posts?: boolean
    enable_rating?: boolean
    path_prefix?: string | null
    title?: string | null
    Category?: CategoryCreateNestedManyWithoutCollectionInput
    Organization: OrganizationCreateNestedOneWithoutCollectionInput
    Content?: ContentCreateNestedManyWithoutCollectionInput
    Field?: FieldCreateNestedManyWithoutCollectionInput
    Template?: TemplateCreateNestedManyWithoutCollectionInput
  }

  export type CollectionUncheckedCreateWithoutForm_fieldInput = {
    id?: number
    name: string
    organization_id: number
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    icon: string
    page_content?: boolean
    enable_author?: boolean
    enable_comments?: boolean
    enable_featured_posts?: boolean
    enable_rating?: boolean
    path_prefix?: string | null
    title?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutCollectionInput
    Content?: ContentUncheckedCreateNestedManyWithoutCollectionInput
    Field?: FieldUncheckedCreateNestedManyWithoutCollectionInput
    Template?: TemplateUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type CollectionCreateOrConnectWithoutForm_fieldInput = {
    where: CollectionWhereUniqueInput
    create: XOR<CollectionCreateWithoutForm_fieldInput, CollectionUncheckedCreateWithoutForm_fieldInput>
  }

  export type OrganizationCreateWithoutForm_fieldInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutForm_fieldInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutForm_fieldInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutForm_fieldInput, OrganizationUncheckedCreateWithoutForm_fieldInput>
  }

  export type structCreateWithoutForm_fieldInput = {
    created_at?: Date | string
    updated_at: Date | string
    name: string
    group: string
    cms?: boolean
    description?: string | null
    Media?: MediaCreateNestedOneWithoutStructInput
    Organization: OrganizationCreateNestedOneWithoutStructInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutStructInput
  }

  export type structUncheckedCreateWithoutForm_fieldInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    name: string
    group: string
    organization_id: number
    cms?: boolean
    description?: string | null
    media_id?: number | null
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutStructInput
  }

  export type structCreateOrConnectWithoutForm_fieldInput = {
    where: structWhereUniqueInput
    create: XOR<structCreateWithoutForm_fieldInput, structUncheckedCreateWithoutForm_fieldInput>
  }

  export type CollectionUpsertWithoutForm_fieldInput = {
    update: XOR<CollectionUpdateWithoutForm_fieldInput, CollectionUncheckedUpdateWithoutForm_fieldInput>
    create: XOR<CollectionCreateWithoutForm_fieldInput, CollectionUncheckedCreateWithoutForm_fieldInput>
    where?: CollectionWhereInput
  }

  export type CollectionUpdateToOneWithWhereWithoutForm_fieldInput = {
    where?: CollectionWhereInput
    data: XOR<CollectionUpdateWithoutForm_fieldInput, CollectionUncheckedUpdateWithoutForm_fieldInput>
  }

  export type CollectionUpdateWithoutForm_fieldInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    page_content?: BoolFieldUpdateOperationsInput | boolean
    enable_author?: BoolFieldUpdateOperationsInput | boolean
    enable_comments?: BoolFieldUpdateOperationsInput | boolean
    enable_featured_posts?: BoolFieldUpdateOperationsInput | boolean
    enable_rating?: BoolFieldUpdateOperationsInput | boolean
    path_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutCollectionNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutCollectionNestedInput
    Content?: ContentUpdateManyWithoutCollectionNestedInput
    Field?: FieldUpdateManyWithoutCollectionNestedInput
    Template?: TemplateUpdateManyWithoutCollectionNestedInput
  }

  export type CollectionUncheckedUpdateWithoutForm_fieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    page_content?: BoolFieldUpdateOperationsInput | boolean
    enable_author?: BoolFieldUpdateOperationsInput | boolean
    enable_comments?: BoolFieldUpdateOperationsInput | boolean
    enable_featured_posts?: BoolFieldUpdateOperationsInput | boolean
    enable_rating?: BoolFieldUpdateOperationsInput | boolean
    path_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutCollectionNestedInput
    Content?: ContentUncheckedUpdateManyWithoutCollectionNestedInput
    Field?: FieldUncheckedUpdateManyWithoutCollectionNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type OrganizationUpsertWithoutForm_fieldInput = {
    update: XOR<OrganizationUpdateWithoutForm_fieldInput, OrganizationUncheckedUpdateWithoutForm_fieldInput>
    create: XOR<OrganizationCreateWithoutForm_fieldInput, OrganizationUncheckedCreateWithoutForm_fieldInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutForm_fieldInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutForm_fieldInput, OrganizationUncheckedUpdateWithoutForm_fieldInput>
  }

  export type OrganizationUpdateWithoutForm_fieldInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutForm_fieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type structUpsertWithoutForm_fieldInput = {
    update: XOR<structUpdateWithoutForm_fieldInput, structUncheckedUpdateWithoutForm_fieldInput>
    create: XOR<structCreateWithoutForm_fieldInput, structUncheckedCreateWithoutForm_fieldInput>
    where?: structWhereInput
  }

  export type structUpdateToOneWithWhereWithoutForm_fieldInput = {
    where?: structWhereInput
    data: XOR<structUpdateWithoutForm_fieldInput, structUncheckedUpdateWithoutForm_fieldInput>
  }

  export type structUpdateWithoutForm_fieldInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    cms?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Media?: MediaUpdateOneWithoutStructNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutStructNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutStructNestedInput
  }

  export type structUncheckedUpdateWithoutForm_fieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    cms?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    media_id?: NullableIntFieldUpdateOperationsInput | number | null
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutStructNestedInput
  }

  export type MediaCreateWithoutOrg_detailsInput = {
    url: string
    alt_text?: string
    name?: string
    created_at?: Date | string
    updated_at: Date | string
    LinkPage?: LinkPageCreateNestedManyWithoutMediaInput
    Organization: OrganizationCreateNestedOneWithoutMediaInput
    Users?: UsersCreateNestedManyWithoutMediaInput
    author?: authorCreateNestedManyWithoutMediaInput
    struct?: structCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutOrg_detailsInput = {
    id?: number
    url: string
    alt_text?: string
    name?: string
    created_at?: Date | string
    organization_id: number
    updated_at: Date | string
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutMediaInput
    Users?: UsersUncheckedCreateNestedManyWithoutMediaInput
    author?: authorUncheckedCreateNestedManyWithoutMediaInput
    struct?: structUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutOrg_detailsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutOrg_detailsInput, MediaUncheckedCreateWithoutOrg_detailsInput>
  }

  export type OrganizationCreateWithoutOrg_detailsInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutOrg_detailsInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutOrg_detailsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutOrg_detailsInput, OrganizationUncheckedCreateWithoutOrg_detailsInput>
  }

  export type MediaUpsertWithoutOrg_detailsInput = {
    update: XOR<MediaUpdateWithoutOrg_detailsInput, MediaUncheckedUpdateWithoutOrg_detailsInput>
    create: XOR<MediaCreateWithoutOrg_detailsInput, MediaUncheckedCreateWithoutOrg_detailsInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutOrg_detailsInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutOrg_detailsInput, MediaUncheckedUpdateWithoutOrg_detailsInput>
  }

  export type MediaUpdateWithoutOrg_detailsInput = {
    url?: StringFieldUpdateOperationsInput | string
    alt_text?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    LinkPage?: LinkPageUpdateManyWithoutMediaNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutMediaNestedInput
    Users?: UsersUpdateManyWithoutMediaNestedInput
    author?: authorUpdateManyWithoutMediaNestedInput
    struct?: structUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutOrg_detailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    alt_text?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    LinkPage?: LinkPageUncheckedUpdateManyWithoutMediaNestedInput
    Users?: UsersUncheckedUpdateManyWithoutMediaNestedInput
    author?: authorUncheckedUpdateManyWithoutMediaNestedInput
    struct?: structUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type OrganizationUpsertWithoutOrg_detailsInput = {
    update: XOR<OrganizationUpdateWithoutOrg_detailsInput, OrganizationUncheckedUpdateWithoutOrg_detailsInput>
    create: XOR<OrganizationCreateWithoutOrg_detailsInput, OrganizationUncheckedCreateWithoutOrg_detailsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutOrg_detailsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutOrg_detailsInput, OrganizationUncheckedUpdateWithoutOrg_detailsInput>
  }

  export type OrganizationUpdateWithoutOrg_detailsInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutOrg_detailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type form_fieldCreateWithoutStructInput = {
    name: string
    required?: boolean
    created_at?: Date | string
    updated_at: Date | string
    type: $Enums.field_type
    default_value?: string | null
    help?: string | null
    order?: number
    description?: string | null
    label: string
    placeholder?: string | null
    regex?: string | null
    options?: form_fieldCreateoptionsInput | InputJsonValue[]
    Collection?: CollectionCreateNestedOneWithoutForm_fieldInput
    Organization: OrganizationCreateNestedOneWithoutForm_fieldInput
  }

  export type form_fieldUncheckedCreateWithoutStructInput = {
    id?: number
    name: string
    required?: boolean
    created_at?: Date | string
    updated_at: Date | string
    type: $Enums.field_type
    default_value?: string | null
    help?: string | null
    order?: number
    description?: string | null
    label: string
    placeholder?: string | null
    regex?: string | null
    organization_id: number
    collection_id?: number | null
    options?: form_fieldCreateoptionsInput | InputJsonValue[]
  }

  export type form_fieldCreateOrConnectWithoutStructInput = {
    where: form_fieldWhereUniqueInput
    create: XOR<form_fieldCreateWithoutStructInput, form_fieldUncheckedCreateWithoutStructInput>
  }

  export type form_fieldCreateManyStructInputEnvelope = {
    data: form_fieldCreateManyStructInput | form_fieldCreateManyStructInput[]
    skipDuplicates?: boolean
  }

  export type MediaCreateWithoutStructInput = {
    url: string
    alt_text?: string
    name?: string
    created_at?: Date | string
    updated_at: Date | string
    LinkPage?: LinkPageCreateNestedManyWithoutMediaInput
    Organization: OrganizationCreateNestedOneWithoutMediaInput
    Users?: UsersCreateNestedManyWithoutMediaInput
    author?: authorCreateNestedManyWithoutMediaInput
    org_details?: org_detailsCreateNestedOneWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutStructInput = {
    id?: number
    url: string
    alt_text?: string
    name?: string
    created_at?: Date | string
    organization_id: number
    updated_at: Date | string
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutMediaInput
    Users?: UsersUncheckedCreateNestedManyWithoutMediaInput
    author?: authorUncheckedCreateNestedManyWithoutMediaInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutStructInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutStructInput, MediaUncheckedCreateWithoutStructInput>
  }

  export type OrganizationCreateWithoutStructInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutStructInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutStructInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutStructInput, OrganizationUncheckedCreateWithoutStructInput>
  }

  export type struct_set_instanceCreateWithoutStructInput = {
    created_at?: Date | string
    updated_at: Date | string
    instance_data: JsonNullValueInput | InputJsonValue
    key: string
    Organization: OrganizationCreateNestedOneWithoutStruct_set_instanceInput
    struct_set: struct_setCreateNestedOneWithoutStruct_set_instanceInput
  }

  export type struct_set_instanceUncheckedCreateWithoutStructInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    instance_data: JsonNullValueInput | InputJsonValue
    organization_id: number
    struct_set_id: number
    key: string
  }

  export type struct_set_instanceCreateOrConnectWithoutStructInput = {
    where: struct_set_instanceWhereUniqueInput
    create: XOR<struct_set_instanceCreateWithoutStructInput, struct_set_instanceUncheckedCreateWithoutStructInput>
  }

  export type struct_set_instanceCreateManyStructInputEnvelope = {
    data: struct_set_instanceCreateManyStructInput | struct_set_instanceCreateManyStructInput[]
    skipDuplicates?: boolean
  }

  export type form_fieldUpsertWithWhereUniqueWithoutStructInput = {
    where: form_fieldWhereUniqueInput
    update: XOR<form_fieldUpdateWithoutStructInput, form_fieldUncheckedUpdateWithoutStructInput>
    create: XOR<form_fieldCreateWithoutStructInput, form_fieldUncheckedCreateWithoutStructInput>
  }

  export type form_fieldUpdateWithWhereUniqueWithoutStructInput = {
    where: form_fieldWhereUniqueInput
    data: XOR<form_fieldUpdateWithoutStructInput, form_fieldUncheckedUpdateWithoutStructInput>
  }

  export type form_fieldUpdateManyWithWhereWithoutStructInput = {
    where: form_fieldScalarWhereInput
    data: XOR<form_fieldUpdateManyMutationInput, form_fieldUncheckedUpdateManyWithoutStructInput>
  }

  export type MediaUpsertWithoutStructInput = {
    update: XOR<MediaUpdateWithoutStructInput, MediaUncheckedUpdateWithoutStructInput>
    create: XOR<MediaCreateWithoutStructInput, MediaUncheckedCreateWithoutStructInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutStructInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutStructInput, MediaUncheckedUpdateWithoutStructInput>
  }

  export type MediaUpdateWithoutStructInput = {
    url?: StringFieldUpdateOperationsInput | string
    alt_text?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    LinkPage?: LinkPageUpdateManyWithoutMediaNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutMediaNestedInput
    Users?: UsersUpdateManyWithoutMediaNestedInput
    author?: authorUpdateManyWithoutMediaNestedInput
    org_details?: org_detailsUpdateOneWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutStructInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    alt_text?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    LinkPage?: LinkPageUncheckedUpdateManyWithoutMediaNestedInput
    Users?: UsersUncheckedUpdateManyWithoutMediaNestedInput
    author?: authorUncheckedUpdateManyWithoutMediaNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutMediaNestedInput
  }

  export type OrganizationUpsertWithoutStructInput = {
    update: XOR<OrganizationUpdateWithoutStructInput, OrganizationUncheckedUpdateWithoutStructInput>
    create: XOR<OrganizationCreateWithoutStructInput, OrganizationUncheckedCreateWithoutStructInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutStructInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutStructInput, OrganizationUncheckedUpdateWithoutStructInput>
  }

  export type OrganizationUpdateWithoutStructInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutStructInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type struct_set_instanceUpsertWithWhereUniqueWithoutStructInput = {
    where: struct_set_instanceWhereUniqueInput
    update: XOR<struct_set_instanceUpdateWithoutStructInput, struct_set_instanceUncheckedUpdateWithoutStructInput>
    create: XOR<struct_set_instanceCreateWithoutStructInput, struct_set_instanceUncheckedCreateWithoutStructInput>
  }

  export type struct_set_instanceUpdateWithWhereUniqueWithoutStructInput = {
    where: struct_set_instanceWhereUniqueInput
    data: XOR<struct_set_instanceUpdateWithoutStructInput, struct_set_instanceUncheckedUpdateWithoutStructInput>
  }

  export type struct_set_instanceUpdateManyWithWhereWithoutStructInput = {
    where: struct_set_instanceScalarWhereInput
    data: XOR<struct_set_instanceUpdateManyMutationInput, struct_set_instanceUncheckedUpdateManyWithoutStructInput>
  }

  export type OrganizationCreateWithoutStruct_setInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutStruct_setInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set_instance?: struct_set_instanceUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutStruct_setInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutStruct_setInput, OrganizationUncheckedCreateWithoutStruct_setInput>
  }

  export type struct_set_instanceCreateWithoutStruct_setInput = {
    created_at?: Date | string
    updated_at: Date | string
    instance_data: JsonNullValueInput | InputJsonValue
    key: string
    Organization: OrganizationCreateNestedOneWithoutStruct_set_instanceInput
    struct: structCreateNestedOneWithoutStruct_set_instanceInput
  }

  export type struct_set_instanceUncheckedCreateWithoutStruct_setInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    instance_data: JsonNullValueInput | InputJsonValue
    organization_id: number
    struct_id: number
    key: string
  }

  export type struct_set_instanceCreateOrConnectWithoutStruct_setInput = {
    where: struct_set_instanceWhereUniqueInput
    create: XOR<struct_set_instanceCreateWithoutStruct_setInput, struct_set_instanceUncheckedCreateWithoutStruct_setInput>
  }

  export type struct_set_instanceCreateManyStruct_setInputEnvelope = {
    data: struct_set_instanceCreateManyStruct_setInput | struct_set_instanceCreateManyStruct_setInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutStruct_setInput = {
    update: XOR<OrganizationUpdateWithoutStruct_setInput, OrganizationUncheckedUpdateWithoutStruct_setInput>
    create: XOR<OrganizationCreateWithoutStruct_setInput, OrganizationUncheckedCreateWithoutStruct_setInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutStruct_setInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutStruct_setInput, OrganizationUncheckedUpdateWithoutStruct_setInput>
  }

  export type OrganizationUpdateWithoutStruct_setInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutStruct_setInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type struct_set_instanceUpsertWithWhereUniqueWithoutStruct_setInput = {
    where: struct_set_instanceWhereUniqueInput
    update: XOR<struct_set_instanceUpdateWithoutStruct_setInput, struct_set_instanceUncheckedUpdateWithoutStruct_setInput>
    create: XOR<struct_set_instanceCreateWithoutStruct_setInput, struct_set_instanceUncheckedCreateWithoutStruct_setInput>
  }

  export type struct_set_instanceUpdateWithWhereUniqueWithoutStruct_setInput = {
    where: struct_set_instanceWhereUniqueInput
    data: XOR<struct_set_instanceUpdateWithoutStruct_setInput, struct_set_instanceUncheckedUpdateWithoutStruct_setInput>
  }

  export type struct_set_instanceUpdateManyWithWhereWithoutStruct_setInput = {
    where: struct_set_instanceScalarWhereInput
    data: XOR<struct_set_instanceUpdateManyMutationInput, struct_set_instanceUncheckedUpdateManyWithoutStruct_setInput>
  }

  export type OrganizationCreateWithoutStruct_set_instanceInput = {
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionCreateNestedManyWithoutOrganizationInput
    Comment?: CommentCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageCreateNestedManyWithoutOrganizationInput
    Content?: ContentCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageCreateNestedManyWithoutOrganizationInput
    Media?: MediaCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesCreateNestedManyWithoutOrganizationInput
    Page?: PageCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadCreateNestedManyWithoutOrganizationInput
    Usage?: UsageCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Users?: UsersCreateNestedManyWithoutOrganizationInput
    author?: authorCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsCreateNestedOneWithoutOrganizationInput
    struct?: structCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutStruct_set_instanceInput = {
    id?: number
    company_name: string
    address?: string | null
    country?: string | null
    phone: string
    email: string
    company_description: string
    domain?: string | null
    logo?: string | null
    token: string
    stripe_customer_id?: string | null
    stripe_price_id?: string
    stripe_is_subscribed?: boolean
    ai_subscription_id?: string | null
    notify_by_email?: boolean
    notify_by_sms?: boolean
    slack_webhook_url?: string | null
    city?: string | null
    postal_code?: string | null
    state?: string | null
    street_address?: string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutOrganizationInput
    Collection?: CollectionUncheckedCreateNestedManyWithoutOrganizationInput
    Comment?: CommentUncheckedCreateNestedManyWithoutOrganizationInput
    CompletionUsage?: CompletionUsageUncheckedCreateNestedManyWithoutOrganizationInput
    Content?: ContentUncheckedCreateNestedManyWithoutOrganizationInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedCreateNestedManyWithoutOrganizationInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutOrganizationInput
    LinkPage?: LinkPageUncheckedCreateNestedManyWithoutOrganizationInput
    Media?: MediaUncheckedCreateNestedManyWithoutOrganizationInput
    Messages?: MessagesUncheckedCreateNestedManyWithoutOrganizationInput
    Page?: PageUncheckedCreateNestedManyWithoutOrganizationInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Thread?: ThreadUncheckedCreateNestedManyWithoutOrganizationInput
    Usage?: UsageUncheckedCreateNestedManyWithoutOrganizationInput
    UserOrganization?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Users?: UsersUncheckedCreateNestedManyWithoutOrganizationInput
    author?: authorUncheckedCreateNestedManyWithoutOrganizationInput
    form_field?: form_fieldUncheckedCreateNestedManyWithoutOrganizationInput
    org_details?: org_detailsUncheckedCreateNestedOneWithoutOrganizationInput
    struct?: structUncheckedCreateNestedManyWithoutOrganizationInput
    struct_set?: struct_setUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutStruct_set_instanceInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutStruct_set_instanceInput, OrganizationUncheckedCreateWithoutStruct_set_instanceInput>
  }

  export type structCreateWithoutStruct_set_instanceInput = {
    created_at?: Date | string
    updated_at: Date | string
    name: string
    group: string
    cms?: boolean
    description?: string | null
    form_field?: form_fieldCreateNestedManyWithoutStructInput
    Media?: MediaCreateNestedOneWithoutStructInput
    Organization: OrganizationCreateNestedOneWithoutStructInput
  }

  export type structUncheckedCreateWithoutStruct_set_instanceInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    name: string
    group: string
    organization_id: number
    cms?: boolean
    description?: string | null
    media_id?: number | null
    form_field?: form_fieldUncheckedCreateNestedManyWithoutStructInput
  }

  export type structCreateOrConnectWithoutStruct_set_instanceInput = {
    where: structWhereUniqueInput
    create: XOR<structCreateWithoutStruct_set_instanceInput, structUncheckedCreateWithoutStruct_set_instanceInput>
  }

  export type struct_setCreateWithoutStruct_set_instanceInput = {
    name: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
    icon: string
    pinned?: boolean
    Organization: OrganizationCreateNestedOneWithoutStruct_setInput
  }

  export type struct_setUncheckedCreateWithoutStruct_set_instanceInput = {
    id?: number
    name: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
    organization_id: number
    icon: string
    pinned?: boolean
  }

  export type struct_setCreateOrConnectWithoutStruct_set_instanceInput = {
    where: struct_setWhereUniqueInput
    create: XOR<struct_setCreateWithoutStruct_set_instanceInput, struct_setUncheckedCreateWithoutStruct_set_instanceInput>
  }

  export type OrganizationUpsertWithoutStruct_set_instanceInput = {
    update: XOR<OrganizationUpdateWithoutStruct_set_instanceInput, OrganizationUncheckedUpdateWithoutStruct_set_instanceInput>
    create: XOR<OrganizationCreateWithoutStruct_set_instanceInput, OrganizationUncheckedCreateWithoutStruct_set_instanceInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutStruct_set_instanceInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutStruct_set_instanceInput, OrganizationUncheckedUpdateWithoutStruct_set_instanceInput>
  }

  export type OrganizationUpdateWithoutStruct_set_instanceInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUpdateManyWithoutOrganizationNestedInput
    Page?: PageUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUpdateManyWithoutOrganizationNestedInput
    author?: authorUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUpdateOneWithoutOrganizationNestedInput
    struct?: structUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutStruct_set_instanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_description?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_is_subscribed?: BoolFieldUpdateOperationsInput | boolean
    ai_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    notify_by_email?: BoolFieldUpdateOperationsInput | boolean
    notify_by_sms?: BoolFieldUpdateOperationsInput | boolean
    slack_webhook_url?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutOrganizationNestedInput
    Collection?: CollectionUncheckedUpdateManyWithoutOrganizationNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutOrganizationNestedInput
    CompletionUsage?: CompletionUsageUncheckedUpdateManyWithoutOrganizationNestedInput
    Content?: ContentUncheckedUpdateManyWithoutOrganizationNestedInput
    ImageGenerationBilling?: ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutOrganizationNestedInput
    LinkPage?: LinkPageUncheckedUpdateManyWithoutOrganizationNestedInput
    Media?: MediaUncheckedUpdateManyWithoutOrganizationNestedInput
    Messages?: MessagesUncheckedUpdateManyWithoutOrganizationNestedInput
    Page?: PageUncheckedUpdateManyWithoutOrganizationNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Thread?: ThreadUncheckedUpdateManyWithoutOrganizationNestedInput
    Usage?: UsageUncheckedUpdateManyWithoutOrganizationNestedInput
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Users?: UsersUncheckedUpdateManyWithoutOrganizationNestedInput
    author?: authorUncheckedUpdateManyWithoutOrganizationNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutOrganizationNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutOrganizationNestedInput
    struct?: structUncheckedUpdateManyWithoutOrganizationNestedInput
    struct_set?: struct_setUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type structUpsertWithoutStruct_set_instanceInput = {
    update: XOR<structUpdateWithoutStruct_set_instanceInput, structUncheckedUpdateWithoutStruct_set_instanceInput>
    create: XOR<structCreateWithoutStruct_set_instanceInput, structUncheckedCreateWithoutStruct_set_instanceInput>
    where?: structWhereInput
  }

  export type structUpdateToOneWithWhereWithoutStruct_set_instanceInput = {
    where?: structWhereInput
    data: XOR<structUpdateWithoutStruct_set_instanceInput, structUncheckedUpdateWithoutStruct_set_instanceInput>
  }

  export type structUpdateWithoutStruct_set_instanceInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    cms?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    form_field?: form_fieldUpdateManyWithoutStructNestedInput
    Media?: MediaUpdateOneWithoutStructNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutStructNestedInput
  }

  export type structUncheckedUpdateWithoutStruct_set_instanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    cms?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    media_id?: NullableIntFieldUpdateOperationsInput | number | null
    form_field?: form_fieldUncheckedUpdateManyWithoutStructNestedInput
  }

  export type struct_setUpsertWithoutStruct_set_instanceInput = {
    update: XOR<struct_setUpdateWithoutStruct_set_instanceInput, struct_setUncheckedUpdateWithoutStruct_set_instanceInput>
    create: XOR<struct_setCreateWithoutStruct_set_instanceInput, struct_setUncheckedCreateWithoutStruct_set_instanceInput>
    where?: struct_setWhereInput
  }

  export type struct_setUpdateToOneWithWhereWithoutStruct_set_instanceInput = {
    where?: struct_setWhereInput
    data: XOR<struct_setUpdateWithoutStruct_set_instanceInput, struct_setUncheckedUpdateWithoutStruct_set_instanceInput>
  }

  export type struct_setUpdateWithoutStruct_set_instanceInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    Organization?: OrganizationUpdateOneRequiredWithoutStruct_setNestedInput
  }

  export type struct_setUncheckedUpdateWithoutStruct_set_instanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization_id?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CategoryCreateManyCategoryInput = {
    id?: number
    name: string
    organization_id: number
    slug: string
    description?: string | null
    collection_id: number
    created_at?: Date | string
    updated_at: Date | string
    short_name: string
  }

  export type CategoryUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    short_name?: StringFieldUpdateOperationsInput | string
    Collection?: CollectionUpdateOneRequiredWithoutCategoryNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutCategoryNestedInput
    other_Category?: CategoryUpdateManyWithoutCategoryNestedInput
    Content?: ContentUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    collection_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    short_name?: StringFieldUpdateOperationsInput | string
    other_Category?: CategoryUncheckedUpdateManyWithoutCategoryNestedInput
    Content?: ContentUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    collection_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    short_name?: StringFieldUpdateOperationsInput | string
  }

  export type ContentUpdateWithoutCategoryInput = {
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: JsonNullValueInput | InputJsonValue
    html?: StringFieldUpdateOperationsInput | string
    archive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    draft?: BoolFieldUpdateOperationsInput | boolean
    slug?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comments_enabled?: BoolFieldUpdateOperationsInput | boolean
    featured?: BoolFieldUpdateOperationsInput | boolean
    content_category?: ContentUpdatecontent_categoryInput | string[]
    Comment?: CommentUpdateManyWithoutContentNestedInput
    author?: authorUpdateOneWithoutContentNestedInput
    Collection?: CollectionUpdateOneRequiredWithoutContentNestedInput
    Organization?: OrganizationUpdateOneWithoutContentNestedInput
    ContentTemplateInstance?: ContentTemplateInstanceUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: JsonNullValueInput | InputJsonValue
    html?: StringFieldUpdateOperationsInput | string
    archive?: BoolFieldUpdateOperationsInput | boolean
    collection_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    draft?: BoolFieldUpdateOperationsInput | boolean
    slug?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comments_enabled?: BoolFieldUpdateOperationsInput | boolean
    organization_id?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    content_category?: ContentUpdatecontent_categoryInput | string[]
    Comment?: CommentUncheckedUpdateManyWithoutContentNestedInput
    ContentTemplateInstance?: ContentTemplateInstanceUncheckedUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: JsonNullValueInput | InputJsonValue
    html?: StringFieldUpdateOperationsInput | string
    archive?: BoolFieldUpdateOperationsInput | boolean
    collection_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    draft?: BoolFieldUpdateOperationsInput | boolean
    slug?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comments_enabled?: BoolFieldUpdateOperationsInput | boolean
    organization_id?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    content_category?: ContentUpdatecontent_categoryInput | string[]
  }

  export type CategoryCreateManyCollectionInput = {
    id?: number
    name: string
    organization_id: number
    slug: string
    description?: string | null
    parent_id?: number | null
    created_at?: Date | string
    updated_at: Date | string
    short_name: string
  }

  export type ContentCreateManyCollectionInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    blocks: JsonNullValueInput | InputJsonValue
    html: string
    archive?: boolean
    description?: string | null
    draft?: boolean
    slug: string
    title?: string | null
    comments_enabled?: boolean
    organization_id?: number | null
    author_id?: number | null
    featured?: boolean
    content_category?: ContentCreatecontent_categoryInput | string[]
  }

  export type FieldCreateManyCollectionInput = {
    id?: number
    name: string
    type: string
    required: boolean
    options?: FieldCreateoptionsInput | string[]
    created_at?: Date | string
    updated_at: Date | string
    template_id?: number | null
  }

  export type TemplateCreateManyCollectionInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type form_fieldCreateManyCollectionInput = {
    id?: number
    name: string
    required?: boolean
    created_at?: Date | string
    updated_at: Date | string
    type: $Enums.field_type
    default_value?: string | null
    help?: string | null
    order?: number
    description?: string | null
    label: string
    placeholder?: string | null
    regex?: string | null
    organization_id: number
    options?: form_fieldCreateoptionsInput | InputJsonValue[]
    struct_id?: number | null
  }

  export type CategoryUpdateWithoutCollectionInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    short_name?: StringFieldUpdateOperationsInput | string
    Organization?: OrganizationUpdateOneRequiredWithoutCategoryNestedInput
    Category?: CategoryUpdateOneWithoutOther_CategoryNestedInput
    other_Category?: CategoryUpdateManyWithoutCategoryNestedInput
    Content?: ContentUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutCollectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    short_name?: StringFieldUpdateOperationsInput | string
    other_Category?: CategoryUncheckedUpdateManyWithoutCategoryNestedInput
    Content?: ContentUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutCollectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    short_name?: StringFieldUpdateOperationsInput | string
  }

  export type ContentUpdateWithoutCollectionInput = {
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: JsonNullValueInput | InputJsonValue
    html?: StringFieldUpdateOperationsInput | string
    archive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    draft?: BoolFieldUpdateOperationsInput | boolean
    slug?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comments_enabled?: BoolFieldUpdateOperationsInput | boolean
    featured?: BoolFieldUpdateOperationsInput | boolean
    content_category?: ContentUpdatecontent_categoryInput | string[]
    Comment?: CommentUpdateManyWithoutContentNestedInput
    author?: authorUpdateOneWithoutContentNestedInput
    Organization?: OrganizationUpdateOneWithoutContentNestedInput
    ContentTemplateInstance?: ContentTemplateInstanceUpdateManyWithoutContentNestedInput
    Category?: CategoryUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutCollectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: JsonNullValueInput | InputJsonValue
    html?: StringFieldUpdateOperationsInput | string
    archive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    draft?: BoolFieldUpdateOperationsInput | boolean
    slug?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comments_enabled?: BoolFieldUpdateOperationsInput | boolean
    organization_id?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    content_category?: ContentUpdatecontent_categoryInput | string[]
    Comment?: CommentUncheckedUpdateManyWithoutContentNestedInput
    ContentTemplateInstance?: ContentTemplateInstanceUncheckedUpdateManyWithoutContentNestedInput
    Category?: CategoryUncheckedUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateManyWithoutCollectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: JsonNullValueInput | InputJsonValue
    html?: StringFieldUpdateOperationsInput | string
    archive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    draft?: BoolFieldUpdateOperationsInput | boolean
    slug?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comments_enabled?: BoolFieldUpdateOperationsInput | boolean
    organization_id?: NullableIntFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    content_category?: ContentUpdatecontent_categoryInput | string[]
  }

  export type FieldUpdateWithoutCollectionInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    options?: FieldUpdateoptionsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Template?: TemplateUpdateOneWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutCollectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    options?: FieldUpdateoptionsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    template_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FieldUncheckedUpdateManyWithoutCollectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    options?: FieldUpdateoptionsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    template_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TemplateUpdateWithoutCollectionInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Field?: FieldUpdateManyWithoutTemplateNestedInput
    TemplateInstance?: TemplateInstanceUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateUncheckedUpdateWithoutCollectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Field?: FieldUncheckedUpdateManyWithoutTemplateNestedInput
    TemplateInstance?: TemplateInstanceUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateUncheckedUpdateManyWithoutCollectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type form_fieldUpdateWithoutCollectionInput = {
    name?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfield_typeFieldUpdateOperationsInput | $Enums.field_type
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    help?: NullableStringFieldUpdateOperationsInput | string | null
    order?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    regex?: NullableStringFieldUpdateOperationsInput | string | null
    options?: form_fieldUpdateoptionsInput | InputJsonValue[]
    Organization?: OrganizationUpdateOneRequiredWithoutForm_fieldNestedInput
    struct?: structUpdateOneWithoutForm_fieldNestedInput
  }

  export type form_fieldUncheckedUpdateWithoutCollectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfield_typeFieldUpdateOperationsInput | $Enums.field_type
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    help?: NullableStringFieldUpdateOperationsInput | string | null
    order?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    regex?: NullableStringFieldUpdateOperationsInput | string | null
    organization_id?: IntFieldUpdateOperationsInput | number
    options?: form_fieldUpdateoptionsInput | InputJsonValue[]
    struct_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type form_fieldUncheckedUpdateManyWithoutCollectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfield_typeFieldUpdateOperationsInput | $Enums.field_type
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    help?: NullableStringFieldUpdateOperationsInput | string | null
    order?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    regex?: NullableStringFieldUpdateOperationsInput | string | null
    organization_id?: IntFieldUpdateOperationsInput | number
    options?: form_fieldUpdateoptionsInput | InputJsonValue[]
    struct_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommentCreateManyCommentInput = {
    id?: number
    text: string
    author: string
    content_id: number
    created_at?: Date | string
    updated_at: Date | string
    approved?: boolean
    organization_id: number
    email: string
    image_url?: string | null
    rating?: number | null
  }

  export type CommentUpdateWithoutCommentInput = {
    text?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    Content?: ContentUpdateOneRequiredWithoutCommentNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutCommentNestedInput
    other_Comment?: CommentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    content_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    organization_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    other_Comment?: CommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    content_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    organization_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommentCreateManyContentInput = {
    id?: number
    text: string
    author: string
    parent_id?: number | null
    created_at?: Date | string
    updated_at: Date | string
    approved?: boolean
    organization_id: number
    email: string
    image_url?: string | null
    rating?: number | null
  }

  export type ContentTemplateInstanceCreateManyContentInput = {
    id?: number
    template_instance_id: number
  }

  export type CommentUpdateWithoutContentInput = {
    text?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    Organization?: OrganizationUpdateOneRequiredWithoutCommentNestedInput
    Comment?: CommentUpdateOneWithoutOther_CommentNestedInput
    other_Comment?: CommentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    organization_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    other_Comment?: CommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    organization_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContentTemplateInstanceUpdateWithoutContentInput = {
    TemplateInstance?: TemplateInstanceUpdateOneRequiredWithoutContentTemplateInstanceNestedInput
  }

  export type ContentTemplateInstanceUncheckedUpdateWithoutContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    template_instance_id?: IntFieldUpdateOperationsInput | number
  }

  export type ContentTemplateInstanceUncheckedUpdateManyWithoutContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    template_instance_id?: IntFieldUpdateOperationsInput | number
  }

  export type CategoryUpdateWithoutContentInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    short_name?: StringFieldUpdateOperationsInput | string
    Collection?: CollectionUpdateOneRequiredWithoutCategoryNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutCategoryNestedInput
    Category?: CategoryUpdateOneWithoutOther_CategoryNestedInput
    other_Category?: CategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    collection_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    short_name?: StringFieldUpdateOperationsInput | string
    other_Category?: CategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    collection_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    short_name?: StringFieldUpdateOperationsInput | string
  }

  export type LinkPageCreateManyMediaInput = {
    id?: number
    organization_id: number
    created_at?: Date | string
    updated_at: Date | string
    description?: string | null
    title?: string | null
    links?: LinkPageCreatelinksInput | InputJsonValue[]
  }

  export type UsersCreateManyMediaInput = {
    id?: number
    email: string
    username: string
    password: string
    security_pin?: string | null
    created_at?: Date | string
    organization_id: number
    updated_at: Date | string
    role?: string
  }

  export type authorCreateManyMediaInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    name: string
    description: string
    organization_id: number
    slug: string
  }

  export type structCreateManyMediaInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    name: string
    group: string
    organization_id: number
    cms?: boolean
    description?: string | null
  }

  export type LinkPageUpdateWithoutMediaInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    links?: LinkPageUpdatelinksInput | InputJsonValue[]
    Organization?: OrganizationUpdateOneRequiredWithoutLinkPageNestedInput
  }

  export type LinkPageUncheckedUpdateWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    organization_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    links?: LinkPageUpdatelinksInput | InputJsonValue[]
  }

  export type LinkPageUncheckedUpdateManyWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    organization_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    links?: LinkPageUpdatelinksInput | InputJsonValue[]
  }

  export type UsersUpdateWithoutMediaInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    security_pin?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    UserOrganization?: UserOrganizationUpdateManyWithoutUsersNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    security_pin?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateManyWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    security_pin?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type authorUpdateWithoutMediaInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    Content?: ContentUpdateManyWithoutAuthorNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutAuthorNestedInput
  }

  export type authorUncheckedUpdateWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    Content?: ContentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type authorUncheckedUpdateManyWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type structUpdateWithoutMediaInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    cms?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    form_field?: form_fieldUpdateManyWithoutStructNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutStructNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutStructNestedInput
  }

  export type structUncheckedUpdateWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    cms?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    form_field?: form_fieldUncheckedUpdateManyWithoutStructNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutStructNestedInput
  }

  export type structUncheckedUpdateManyWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    cms?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryCreateManyOrganizationInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    parent_id?: number | null
    collection_id: number
    created_at?: Date | string
    updated_at: Date | string
    short_name: string
  }

  export type CollectionCreateManyOrganizationInput = {
    id?: number
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
    icon: string
    page_content?: boolean
    enable_author?: boolean
    enable_comments?: boolean
    enable_featured_posts?: boolean
    enable_rating?: boolean
    path_prefix?: string | null
    title?: string | null
  }

  export type CommentCreateManyOrganizationInput = {
    id?: number
    text: string
    author: string
    content_id: number
    parent_id?: number | null
    created_at?: Date | string
    updated_at: Date | string
    approved?: boolean
    email: string
    image_url?: string | null
    rating?: number | null
  }

  export type CompletionUsageCreateManyOrganizationInput = {
    created_at?: Date | string
    prompt_tokens: number
    completion_tokens: number
    total_tokens: number
    prompt_tokens_cost: number
    completion_tokens_cost: number
    total_tokens_cost: number
    prompt_tokens_price: number
    completion_tokens_price: number
    total_tokens_price: number
    id?: number
  }

  export type ContentCreateManyOrganizationInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    blocks: JsonNullValueInput | InputJsonValue
    html: string
    archive?: boolean
    collection_id: number
    description?: string | null
    draft?: boolean
    slug: string
    title?: string | null
    comments_enabled?: boolean
    author_id?: number | null
    featured?: boolean
    content_category?: ContentCreatecontent_categoryInput | string[]
  }

  export type ImageGenerationBillingCreateManyOrganizationInput = {
    id: string
    completed_at: Date | string
    started_at: Date | string
    created_at: Date | string
    predict_time: number
    model: string
    status: string
    cost: number
    price: number
  }

  export type InvoiceCreateManyOrganizationInput = {
    amount_paid: number
    currency: string
    paid_at: Date | string
    pdf: string
    url: string
    id: string
  }

  export type LinkPageCreateManyOrganizationInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    description?: string | null
    media_id?: number | null
    title?: string | null
    links?: LinkPageCreatelinksInput | InputJsonValue[]
  }

  export type MediaCreateManyOrganizationInput = {
    id?: number
    url: string
    alt_text?: string
    name?: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type MessagesCreateManyOrganizationInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    message: string
    first_name: string
    email: string
    phone_number?: string | null
    last_name?: string | null
    other_fields?: NullableJsonNullValueInput | InputJsonValue
    viewed?: boolean
    archived?: boolean
  }

  export type PageCreateManyOrganizationInput = {
    id?: number
    title: string
    slug: string
    created_at?: Date | string
    updated_at: Date | string
    published?: boolean
    archive?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubscriptionCreateManyOrganizationInput = {
    id?: number
    stripe_subscription_id: string
  }

  export type ThreadCreateManyOrganizationInput = {
    thread_id: string
    title?: string
    created_at?: Date | string
    updated_at: Date | string
    should_hide_thread?: boolean
  }

  export type UsageCreateManyOrganizationInput = {
    run_id: string
    prompt_tokens: number
    completion_tokens: number
    total_tokens: number
    created_at?: Date | string
  }

  export type UserOrganizationCreateManyOrganizationInput = {
    user_id: number
    role?: string
    created_at?: Date | string
  }

  export type UsersCreateManyOrganizationInput = {
    id?: number
    email: string
    username: string
    password: string
    security_pin?: string | null
    created_at?: Date | string
    updated_at: Date | string
    role?: string
    media_id?: number | null
  }

  export type authorCreateManyOrganizationInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    name: string
    description: string
    media_id: number
    slug: string
  }

  export type form_fieldCreateManyOrganizationInput = {
    id?: number
    name: string
    required?: boolean
    created_at?: Date | string
    updated_at: Date | string
    type: $Enums.field_type
    default_value?: string | null
    help?: string | null
    order?: number
    description?: string | null
    label: string
    placeholder?: string | null
    regex?: string | null
    collection_id?: number | null
    options?: form_fieldCreateoptionsInput | InputJsonValue[]
    struct_id?: number | null
  }

  export type structCreateManyOrganizationInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    name: string
    group: string
    cms?: boolean
    description?: string | null
    media_id?: number | null
  }

  export type struct_setCreateManyOrganizationInput = {
    id?: number
    name: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
    icon: string
    pinned?: boolean
  }

  export type struct_set_instanceCreateManyOrganizationInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    instance_data: JsonNullValueInput | InputJsonValue
    struct_set_id: number
    struct_id: number
    key: string
  }

  export type CategoryUpdateWithoutOrganizationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    short_name?: StringFieldUpdateOperationsInput | string
    Collection?: CollectionUpdateOneRequiredWithoutCategoryNestedInput
    Category?: CategoryUpdateOneWithoutOther_CategoryNestedInput
    other_Category?: CategoryUpdateManyWithoutCategoryNestedInput
    Content?: ContentUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    collection_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    short_name?: StringFieldUpdateOperationsInput | string
    other_Category?: CategoryUncheckedUpdateManyWithoutCategoryNestedInput
    Content?: ContentUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    collection_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    short_name?: StringFieldUpdateOperationsInput | string
  }

  export type CollectionUpdateWithoutOrganizationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    page_content?: BoolFieldUpdateOperationsInput | boolean
    enable_author?: BoolFieldUpdateOperationsInput | boolean
    enable_comments?: BoolFieldUpdateOperationsInput | boolean
    enable_featured_posts?: BoolFieldUpdateOperationsInput | boolean
    enable_rating?: BoolFieldUpdateOperationsInput | boolean
    path_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUpdateManyWithoutCollectionNestedInput
    Content?: ContentUpdateManyWithoutCollectionNestedInput
    Field?: FieldUpdateManyWithoutCollectionNestedInput
    Template?: TemplateUpdateManyWithoutCollectionNestedInput
    form_field?: form_fieldUpdateManyWithoutCollectionNestedInput
  }

  export type CollectionUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    page_content?: BoolFieldUpdateOperationsInput | boolean
    enable_author?: BoolFieldUpdateOperationsInput | boolean
    enable_comments?: BoolFieldUpdateOperationsInput | boolean
    enable_featured_posts?: BoolFieldUpdateOperationsInput | boolean
    enable_rating?: BoolFieldUpdateOperationsInput | boolean
    path_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: CategoryUncheckedUpdateManyWithoutCollectionNestedInput
    Content?: ContentUncheckedUpdateManyWithoutCollectionNestedInput
    Field?: FieldUncheckedUpdateManyWithoutCollectionNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutCollectionNestedInput
    form_field?: form_fieldUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type CollectionUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    page_content?: BoolFieldUpdateOperationsInput | boolean
    enable_author?: BoolFieldUpdateOperationsInput | boolean
    enable_comments?: BoolFieldUpdateOperationsInput | boolean
    enable_featured_posts?: BoolFieldUpdateOperationsInput | boolean
    enable_rating?: BoolFieldUpdateOperationsInput | boolean
    path_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUpdateWithoutOrganizationInput = {
    text?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    Content?: ContentUpdateOneRequiredWithoutCommentNestedInput
    Comment?: CommentUpdateOneWithoutOther_CommentNestedInput
    other_Comment?: CommentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    content_id?: IntFieldUpdateOperationsInput | number
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    other_Comment?: CommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    content_id?: IntFieldUpdateOperationsInput | number
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CompletionUsageUpdateWithoutOrganizationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt_tokens?: IntFieldUpdateOperationsInput | number
    completion_tokens?: IntFieldUpdateOperationsInput | number
    total_tokens?: IntFieldUpdateOperationsInput | number
    prompt_tokens_cost?: FloatFieldUpdateOperationsInput | number
    completion_tokens_cost?: FloatFieldUpdateOperationsInput | number
    total_tokens_cost?: FloatFieldUpdateOperationsInput | number
    prompt_tokens_price?: FloatFieldUpdateOperationsInput | number
    completion_tokens_price?: FloatFieldUpdateOperationsInput | number
    total_tokens_price?: FloatFieldUpdateOperationsInput | number
  }

  export type CompletionUsageUncheckedUpdateWithoutOrganizationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt_tokens?: IntFieldUpdateOperationsInput | number
    completion_tokens?: IntFieldUpdateOperationsInput | number
    total_tokens?: IntFieldUpdateOperationsInput | number
    prompt_tokens_cost?: FloatFieldUpdateOperationsInput | number
    completion_tokens_cost?: FloatFieldUpdateOperationsInput | number
    total_tokens_cost?: FloatFieldUpdateOperationsInput | number
    prompt_tokens_price?: FloatFieldUpdateOperationsInput | number
    completion_tokens_price?: FloatFieldUpdateOperationsInput | number
    total_tokens_price?: FloatFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
  }

  export type CompletionUsageUncheckedUpdateManyWithoutOrganizationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt_tokens?: IntFieldUpdateOperationsInput | number
    completion_tokens?: IntFieldUpdateOperationsInput | number
    total_tokens?: IntFieldUpdateOperationsInput | number
    prompt_tokens_cost?: FloatFieldUpdateOperationsInput | number
    completion_tokens_cost?: FloatFieldUpdateOperationsInput | number
    total_tokens_cost?: FloatFieldUpdateOperationsInput | number
    prompt_tokens_price?: FloatFieldUpdateOperationsInput | number
    completion_tokens_price?: FloatFieldUpdateOperationsInput | number
    total_tokens_price?: FloatFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
  }

  export type ContentUpdateWithoutOrganizationInput = {
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: JsonNullValueInput | InputJsonValue
    html?: StringFieldUpdateOperationsInput | string
    archive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    draft?: BoolFieldUpdateOperationsInput | boolean
    slug?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comments_enabled?: BoolFieldUpdateOperationsInput | boolean
    featured?: BoolFieldUpdateOperationsInput | boolean
    content_category?: ContentUpdatecontent_categoryInput | string[]
    Comment?: CommentUpdateManyWithoutContentNestedInput
    author?: authorUpdateOneWithoutContentNestedInput
    Collection?: CollectionUpdateOneRequiredWithoutContentNestedInput
    ContentTemplateInstance?: ContentTemplateInstanceUpdateManyWithoutContentNestedInput
    Category?: CategoryUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: JsonNullValueInput | InputJsonValue
    html?: StringFieldUpdateOperationsInput | string
    archive?: BoolFieldUpdateOperationsInput | boolean
    collection_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    draft?: BoolFieldUpdateOperationsInput | boolean
    slug?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comments_enabled?: BoolFieldUpdateOperationsInput | boolean
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    content_category?: ContentUpdatecontent_categoryInput | string[]
    Comment?: CommentUncheckedUpdateManyWithoutContentNestedInput
    ContentTemplateInstance?: ContentTemplateInstanceUncheckedUpdateManyWithoutContentNestedInput
    Category?: CategoryUncheckedUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: JsonNullValueInput | InputJsonValue
    html?: StringFieldUpdateOperationsInput | string
    archive?: BoolFieldUpdateOperationsInput | boolean
    collection_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    draft?: BoolFieldUpdateOperationsInput | boolean
    slug?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comments_enabled?: BoolFieldUpdateOperationsInput | boolean
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    content_category?: ContentUpdatecontent_categoryInput | string[]
  }

  export type ImageGenerationBillingUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    predict_time?: FloatFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ImageGenerationBillingUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    predict_time?: FloatFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ImageGenerationBillingUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    predict_time?: FloatFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type InvoiceUpdateWithoutOrganizationInput = {
    amount_paid?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paid_at?: DateTimeFieldUpdateOperationsInput | Date | string
    pdf?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceUncheckedUpdateWithoutOrganizationInput = {
    amount_paid?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paid_at?: DateTimeFieldUpdateOperationsInput | Date | string
    pdf?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceUncheckedUpdateManyWithoutOrganizationInput = {
    amount_paid?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paid_at?: DateTimeFieldUpdateOperationsInput | Date | string
    pdf?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type LinkPageUpdateWithoutOrganizationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    links?: LinkPageUpdatelinksInput | InputJsonValue[]
    Media?: MediaUpdateOneWithoutLinkPageNestedInput
  }

  export type LinkPageUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    media_id?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    links?: LinkPageUpdatelinksInput | InputJsonValue[]
  }

  export type LinkPageUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    media_id?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    links?: LinkPageUpdatelinksInput | InputJsonValue[]
  }

  export type MediaUpdateWithoutOrganizationInput = {
    url?: StringFieldUpdateOperationsInput | string
    alt_text?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    LinkPage?: LinkPageUpdateManyWithoutMediaNestedInput
    Users?: UsersUpdateManyWithoutMediaNestedInput
    author?: authorUpdateManyWithoutMediaNestedInput
    org_details?: org_detailsUpdateOneWithoutMediaNestedInput
    struct?: structUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    alt_text?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    LinkPage?: LinkPageUncheckedUpdateManyWithoutMediaNestedInput
    Users?: UsersUncheckedUpdateManyWithoutMediaNestedInput
    author?: authorUncheckedUpdateManyWithoutMediaNestedInput
    org_details?: org_detailsUncheckedUpdateOneWithoutMediaNestedInput
    struct?: structUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    alt_text?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessagesUpdateWithoutOrganizationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    other_fields?: NullableJsonNullValueInput | InputJsonValue
    viewed?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessagesUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    other_fields?: NullableJsonNullValueInput | InputJsonValue
    viewed?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessagesUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    other_fields?: NullableJsonNullValueInput | InputJsonValue
    viewed?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PageUpdateWithoutOrganizationInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    archive?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PageUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    archive?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PageUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    archive?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubscriptionUpdateWithoutOrganizationInput = {
    stripe_subscription_id?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    stripe_subscription_id?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    stripe_subscription_id?: StringFieldUpdateOperationsInput | string
  }

  export type ThreadUpdateWithoutOrganizationInput = {
    thread_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    should_hide_thread?: BoolFieldUpdateOperationsInput | boolean
    Run?: RunUpdateManyWithoutThreadNestedInput
    ThreadMessage?: ThreadMessageUpdateManyWithoutThreadNestedInput
  }

  export type ThreadUncheckedUpdateWithoutOrganizationInput = {
    thread_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    should_hide_thread?: BoolFieldUpdateOperationsInput | boolean
    Run?: RunUncheckedUpdateManyWithoutThreadNestedInput
    ThreadMessage?: ThreadMessageUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type ThreadUncheckedUpdateManyWithoutOrganizationInput = {
    thread_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    should_hide_thread?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsageUpdateWithoutOrganizationInput = {
    prompt_tokens?: IntFieldUpdateOperationsInput | number
    completion_tokens?: IntFieldUpdateOperationsInput | number
    total_tokens?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Run?: RunUpdateOneRequiredWithoutUsageNestedInput
  }

  export type UsageUncheckedUpdateWithoutOrganizationInput = {
    run_id?: StringFieldUpdateOperationsInput | string
    prompt_tokens?: IntFieldUpdateOperationsInput | number
    completion_tokens?: IntFieldUpdateOperationsInput | number
    total_tokens?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageUncheckedUpdateManyWithoutOrganizationInput = {
    run_id?: StringFieldUpdateOperationsInput | string
    prompt_tokens?: IntFieldUpdateOperationsInput | number
    completion_tokens?: IntFieldUpdateOperationsInput | number
    total_tokens?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOrganizationUpdateWithoutOrganizationInput = {
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneRequiredWithoutUserOrganizationNestedInput
  }

  export type UserOrganizationUncheckedUpdateWithoutOrganizationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOrganizationUncheckedUpdateManyWithoutOrganizationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersUpdateWithoutOrganizationInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    security_pin?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    UserOrganization?: UserOrganizationUpdateManyWithoutUsersNestedInput
    Media?: MediaUpdateOneWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    security_pin?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    media_id?: NullableIntFieldUpdateOperationsInput | number | null
    UserOrganization?: UserOrganizationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    security_pin?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    media_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type authorUpdateWithoutOrganizationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    Content?: ContentUpdateManyWithoutAuthorNestedInput
    Media?: MediaUpdateOneRequiredWithoutAuthorNestedInput
  }

  export type authorUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    media_id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    Content?: ContentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type authorUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    media_id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type form_fieldUpdateWithoutOrganizationInput = {
    name?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfield_typeFieldUpdateOperationsInput | $Enums.field_type
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    help?: NullableStringFieldUpdateOperationsInput | string | null
    order?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    regex?: NullableStringFieldUpdateOperationsInput | string | null
    options?: form_fieldUpdateoptionsInput | InputJsonValue[]
    Collection?: CollectionUpdateOneWithoutForm_fieldNestedInput
    struct?: structUpdateOneWithoutForm_fieldNestedInput
  }

  export type form_fieldUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfield_typeFieldUpdateOperationsInput | $Enums.field_type
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    help?: NullableStringFieldUpdateOperationsInput | string | null
    order?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    regex?: NullableStringFieldUpdateOperationsInput | string | null
    collection_id?: NullableIntFieldUpdateOperationsInput | number | null
    options?: form_fieldUpdateoptionsInput | InputJsonValue[]
    struct_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type form_fieldUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfield_typeFieldUpdateOperationsInput | $Enums.field_type
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    help?: NullableStringFieldUpdateOperationsInput | string | null
    order?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    regex?: NullableStringFieldUpdateOperationsInput | string | null
    collection_id?: NullableIntFieldUpdateOperationsInput | number | null
    options?: form_fieldUpdateoptionsInput | InputJsonValue[]
    struct_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type structUpdateWithoutOrganizationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    cms?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    form_field?: form_fieldUpdateManyWithoutStructNestedInput
    Media?: MediaUpdateOneWithoutStructNestedInput
    struct_set_instance?: struct_set_instanceUpdateManyWithoutStructNestedInput
  }

  export type structUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    cms?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    media_id?: NullableIntFieldUpdateOperationsInput | number | null
    form_field?: form_fieldUncheckedUpdateManyWithoutStructNestedInput
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutStructNestedInput
  }

  export type structUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    cms?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    media_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type struct_setUpdateWithoutOrganizationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    struct_set_instance?: struct_set_instanceUpdateManyWithoutStruct_setNestedInput
  }

  export type struct_setUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    struct_set_instance?: struct_set_instanceUncheckedUpdateManyWithoutStruct_setNestedInput
  }

  export type struct_setUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type struct_set_instanceUpdateWithoutOrganizationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_data?: JsonNullValueInput | InputJsonValue
    key?: StringFieldUpdateOperationsInput | string
    struct?: structUpdateOneRequiredWithoutStruct_set_instanceNestedInput
    struct_set?: struct_setUpdateOneRequiredWithoutStruct_set_instanceNestedInput
  }

  export type struct_set_instanceUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_data?: JsonNullValueInput | InputJsonValue
    struct_set_id?: IntFieldUpdateOperationsInput | number
    struct_id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
  }

  export type struct_set_instanceUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_data?: JsonNullValueInput | InputJsonValue
    struct_set_id?: IntFieldUpdateOperationsInput | number
    struct_id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
  }

  export type ThreadMessageCreateManyRunInput = {
    id: string
    created_at: Date | string
    thread_id: string
    role: string
    content: string
    assistant_id?: string | null
  }

  export type ThreadMessageUpdateWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    assistant_id?: NullableStringFieldUpdateOperationsInput | string | null
    Thread?: ThreadUpdateOneRequiredWithoutThreadMessageNestedInput
  }

  export type ThreadMessageUncheckedUpdateWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    thread_id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    assistant_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ThreadMessageUncheckedUpdateManyWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    thread_id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    assistant_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FieldCreateManyTemplateInput = {
    id?: number
    name: string
    type: string
    required: boolean
    options?: FieldCreateoptionsInput | string[]
    created_at?: Date | string
    updated_at: Date | string
    collection_id?: number | null
  }

  export type TemplateInstanceCreateManyTemplateInput = {
    id?: number
    values: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    title: string
  }

  export type FieldUpdateWithoutTemplateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    options?: FieldUpdateoptionsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Collection?: CollectionUpdateOneWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    options?: FieldUpdateoptionsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FieldUncheckedUpdateManyWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    options?: FieldUpdateoptionsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TemplateInstanceUpdateWithoutTemplateInput = {
    values?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    ContentTemplateInstance?: ContentTemplateInstanceUpdateManyWithoutTemplateInstanceNestedInput
  }

  export type TemplateInstanceUncheckedUpdateWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    ContentTemplateInstance?: ContentTemplateInstanceUncheckedUpdateManyWithoutTemplateInstanceNestedInput
  }

  export type TemplateInstanceUncheckedUpdateManyWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ContentTemplateInstanceCreateManyTemplateInstanceInput = {
    id?: number
    content_id: number
  }

  export type ContentTemplateInstanceUpdateWithoutTemplateInstanceInput = {
    Content?: ContentUpdateOneRequiredWithoutContentTemplateInstanceNestedInput
  }

  export type ContentTemplateInstanceUncheckedUpdateWithoutTemplateInstanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    content_id?: IntFieldUpdateOperationsInput | number
  }

  export type ContentTemplateInstanceUncheckedUpdateManyWithoutTemplateInstanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    content_id?: IntFieldUpdateOperationsInput | number
  }

  export type RunCreateManyThreadInput = {
    id: string
    created_at: Date | string
    assistant_id: string
    status: string
    started_at: Date | string
    expires_at?: Date | string | null
    cancelled_at?: Date | string | null
    failed_at?: Date | string | null
    completed_at?: Date | string | null
    last_error?: string | null
    model: string
    instructions?: string | null
  }

  export type ThreadMessageCreateManyThreadInput = {
    id: string
    created_at: Date | string
    role: string
    content: string
    assistant_id?: string | null
    run_id?: string | null
  }

  export type RunUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assistant_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_error?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    ThreadMessage?: ThreadMessageUpdateManyWithoutRunNestedInput
    Usage?: UsageUpdateOneWithoutRunNestedInput
  }

  export type RunUncheckedUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assistant_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_error?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    ThreadMessage?: ThreadMessageUncheckedUpdateManyWithoutRunNestedInput
    Usage?: UsageUncheckedUpdateOneWithoutRunNestedInput
  }

  export type RunUncheckedUpdateManyWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assistant_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_error?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ThreadMessageUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    assistant_id?: NullableStringFieldUpdateOperationsInput | string | null
    Run?: RunUpdateOneWithoutThreadMessageNestedInput
  }

  export type ThreadMessageUncheckedUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    assistant_id?: NullableStringFieldUpdateOperationsInput | string | null
    run_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ThreadMessageUncheckedUpdateManyWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    assistant_id?: NullableStringFieldUpdateOperationsInput | string | null
    run_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserOrganizationCreateManyUsersInput = {
    organization_id: number
    role?: string
    created_at?: Date | string
  }

  export type UserOrganizationUpdateWithoutUsersInput = {
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Organization?: OrganizationUpdateOneRequiredWithoutUserOrganizationNestedInput
  }

  export type UserOrganizationUncheckedUpdateWithoutUsersInput = {
    organization_id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOrganizationUncheckedUpdateManyWithoutUsersInput = {
    organization_id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentCreateManyAuthorInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    blocks: JsonNullValueInput | InputJsonValue
    html: string
    archive?: boolean
    collection_id: number
    description?: string | null
    draft?: boolean
    slug: string
    title?: string | null
    comments_enabled?: boolean
    organization_id?: number | null
    featured?: boolean
    content_category?: ContentCreatecontent_categoryInput | string[]
  }

  export type ContentUpdateWithoutAuthorInput = {
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: JsonNullValueInput | InputJsonValue
    html?: StringFieldUpdateOperationsInput | string
    archive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    draft?: BoolFieldUpdateOperationsInput | boolean
    slug?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comments_enabled?: BoolFieldUpdateOperationsInput | boolean
    featured?: BoolFieldUpdateOperationsInput | boolean
    content_category?: ContentUpdatecontent_categoryInput | string[]
    Comment?: CommentUpdateManyWithoutContentNestedInput
    Collection?: CollectionUpdateOneRequiredWithoutContentNestedInput
    Organization?: OrganizationUpdateOneWithoutContentNestedInput
    ContentTemplateInstance?: ContentTemplateInstanceUpdateManyWithoutContentNestedInput
    Category?: CategoryUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: JsonNullValueInput | InputJsonValue
    html?: StringFieldUpdateOperationsInput | string
    archive?: BoolFieldUpdateOperationsInput | boolean
    collection_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    draft?: BoolFieldUpdateOperationsInput | boolean
    slug?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comments_enabled?: BoolFieldUpdateOperationsInput | boolean
    organization_id?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    content_category?: ContentUpdatecontent_categoryInput | string[]
    Comment?: CommentUncheckedUpdateManyWithoutContentNestedInput
    ContentTemplateInstance?: ContentTemplateInstanceUncheckedUpdateManyWithoutContentNestedInput
    Category?: CategoryUncheckedUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blocks?: JsonNullValueInput | InputJsonValue
    html?: StringFieldUpdateOperationsInput | string
    archive?: BoolFieldUpdateOperationsInput | boolean
    collection_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    draft?: BoolFieldUpdateOperationsInput | boolean
    slug?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comments_enabled?: BoolFieldUpdateOperationsInput | boolean
    organization_id?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    content_category?: ContentUpdatecontent_categoryInput | string[]
  }

  export type form_fieldCreateManyStructInput = {
    id?: number
    name: string
    required?: boolean
    created_at?: Date | string
    updated_at: Date | string
    type: $Enums.field_type
    default_value?: string | null
    help?: string | null
    order?: number
    description?: string | null
    label: string
    placeholder?: string | null
    regex?: string | null
    organization_id: number
    collection_id?: number | null
    options?: form_fieldCreateoptionsInput | InputJsonValue[]
  }

  export type struct_set_instanceCreateManyStructInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    instance_data: JsonNullValueInput | InputJsonValue
    organization_id: number
    struct_set_id: number
    key: string
  }

  export type form_fieldUpdateWithoutStructInput = {
    name?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfield_typeFieldUpdateOperationsInput | $Enums.field_type
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    help?: NullableStringFieldUpdateOperationsInput | string | null
    order?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    regex?: NullableStringFieldUpdateOperationsInput | string | null
    options?: form_fieldUpdateoptionsInput | InputJsonValue[]
    Collection?: CollectionUpdateOneWithoutForm_fieldNestedInput
    Organization?: OrganizationUpdateOneRequiredWithoutForm_fieldNestedInput
  }

  export type form_fieldUncheckedUpdateWithoutStructInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfield_typeFieldUpdateOperationsInput | $Enums.field_type
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    help?: NullableStringFieldUpdateOperationsInput | string | null
    order?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    regex?: NullableStringFieldUpdateOperationsInput | string | null
    organization_id?: IntFieldUpdateOperationsInput | number
    collection_id?: NullableIntFieldUpdateOperationsInput | number | null
    options?: form_fieldUpdateoptionsInput | InputJsonValue[]
  }

  export type form_fieldUncheckedUpdateManyWithoutStructInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: Enumfield_typeFieldUpdateOperationsInput | $Enums.field_type
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    help?: NullableStringFieldUpdateOperationsInput | string | null
    order?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    regex?: NullableStringFieldUpdateOperationsInput | string | null
    organization_id?: IntFieldUpdateOperationsInput | number
    collection_id?: NullableIntFieldUpdateOperationsInput | number | null
    options?: form_fieldUpdateoptionsInput | InputJsonValue[]
  }

  export type struct_set_instanceUpdateWithoutStructInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_data?: JsonNullValueInput | InputJsonValue
    key?: StringFieldUpdateOperationsInput | string
    Organization?: OrganizationUpdateOneRequiredWithoutStruct_set_instanceNestedInput
    struct_set?: struct_setUpdateOneRequiredWithoutStruct_set_instanceNestedInput
  }

  export type struct_set_instanceUncheckedUpdateWithoutStructInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_data?: JsonNullValueInput | InputJsonValue
    organization_id?: IntFieldUpdateOperationsInput | number
    struct_set_id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
  }

  export type struct_set_instanceUncheckedUpdateManyWithoutStructInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_data?: JsonNullValueInput | InputJsonValue
    organization_id?: IntFieldUpdateOperationsInput | number
    struct_set_id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
  }

  export type struct_set_instanceCreateManyStruct_setInput = {
    id?: number
    created_at?: Date | string
    updated_at: Date | string
    instance_data: JsonNullValueInput | InputJsonValue
    organization_id: number
    struct_id: number
    key: string
  }

  export type struct_set_instanceUpdateWithoutStruct_setInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_data?: JsonNullValueInput | InputJsonValue
    key?: StringFieldUpdateOperationsInput | string
    Organization?: OrganizationUpdateOneRequiredWithoutStruct_set_instanceNestedInput
    struct?: structUpdateOneRequiredWithoutStruct_set_instanceNestedInput
  }

  export type struct_set_instanceUncheckedUpdateWithoutStruct_setInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_data?: JsonNullValueInput | InputJsonValue
    organization_id?: IntFieldUpdateOperationsInput | number
    struct_id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
  }

  export type struct_set_instanceUncheckedUpdateManyWithoutStruct_setInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_data?: JsonNullValueInput | InputJsonValue
    organization_id?: IntFieldUpdateOperationsInput | number
    struct_id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export declare const dmmf: runtime.BaseDMMF
}